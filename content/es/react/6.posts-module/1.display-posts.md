---
title: Mostrar Posts y Respuestas Anidadas
description: Domina componentes recursivos, estructuras de árbol y composición de componentes construyendo un sistema de comentarios anidados.
---

# Disclaimer

:::u-alert
---
title: Los comentarios en el código son solo educativos.
description: En proyectos reales, evita comentarios irrelevantes o redundantes.
color: warning
variant: subtle
icon: i-lucide-triangle-alert
---
:::

Los posts (respuestas a hilos) pueden tener respuestas anidadas, creando estructuras de árbol. Usaremos **recursión** - uno de los patrones más poderosos de React.

---

## Qué Estamos Construyendo

Un sistema de comentarios/respuestas como Reddit o Hacker News:

```
Hilo: "¿Cómo aprendo React?"
├─ Post #1 por @alice: "¡Empieza con la documentación oficial!"
│  ├─ Respuesta por @bob: "Yo encontré los videos más útiles"
│  │  └─ Respuesta por @alice: "¡Buen punto! ¿Alguna recomendación?"
│  └─ Respuesta por @charlie: "Documentación + proyectos es clave"
├─ Post #2 por @david: "¿Cuál es tu experiencia?"
└─ Post #3 por @eve: "Construye una app de tareas primero"
```

Cada post puede tener respuestas, y esas respuestas pueden tener respuestas, y así sucesivamente (anidación infinita).

---

## El Desafío: Datos Anidados

### Lista Plana vs Estructura Anidada

**Opción 1: Lista plana con `parentId` (nuestra elección)**
```typescript
[
  { id: '1', parentId: null, content: '¡Empieza con docs!' },
  { id: '2', parentId: '1', content: 'Prefiero videos' },
  { id: '3', parentId: '2', content: '¿Recomendaciones?' },
]
```

**Opción 2: Estructura anidada**
```typescript
[
  {
    id: '1',
    content: '¡Empieza con docs!',
    replies: [
      {
        id: '2',
        content: 'Prefiero videos',
        replies: [
          { id: '3', content: '¿Recomendaciones?', replies: [] }
        ]
      }
    ]
  }
]
```

**¿Por qué plano es mejor:**
- ✅ Más fácil de actualizar posts específicos
- ✅ Más fácil de obtener de la base de datos
- ✅ Más fácil de implementar actualizaciones optimistas
- ✅ No necesita atravesar árbol para encontrar post
- ❌ Necesita recursión para renderizar (pero ¡está bien!)

---

## Definición de Tipo Post

```typescript
// src/types/index.ts

export interface Post {
  id: string
  threadId: string
  authorId: string
  author: {
    id: string
    username: string
    displayName: string
    avatarUrl: string | null
    role: 'user' | 'moderator' | 'admin'
  }
  content: string
  contentHtml: string  // Markdown renderizado
  parentId: string | null  // null = post raíz, si no respuesta a parentId
  depth: number  // 0 = raíz, 1 = respuesta a raíz, 2 = respuesta a respuesta, etc.
  voteScore: number  // Puntuación neta (upvotes - downvotes)
  userVote: 'up' | 'down' | null  // Voto del usuario actual
  replyCount: number  // Cuenta de respuestas directas
  createdAt: string
  updatedAt: string
  isEdited: boolean
  isDeleted: boolean
}
```

**Campos clave:**
- `parentId`: Forma la estructura de árbol
- `depth`: Ayuda con sangría y límites de profundidad máxima
- `voteScore`: Para ordenar por popularidad
- `userVote`: Para mostrar estado de voto al usuario
- `contentHtml`: Markdown pre-renderizado (¡seguridad!)

---

## Recursión: El Patrón para Árboles

**Recursión** = Una función que se llama a sí misma.

### Recursión 101

```typescript
// Ejemplo: Cuenta regresiva
function countdown(n: number) {
  // CASO BASE: Cuándo detenerse
  if (n === 0) {
    console.log('¡Despegue!')
    return
  }
  
  // CASO RECURSIVO: Hacer trabajo + llamarse a sí misma
  console.log(n)
  countdown(n - 1)  // Llamarse a sí misma con entrada más simple
}

countdown(3)
// Salida: 3, 2, 1, ¡Despegue!
```

**Cada función recursiva necesita:**
1. **Caso base**: Condición para detenerse
2. **Caso recursivo**: Llamarse a sí misma con entrada más simple
3. **Progreso**: Cada llamada se acerca al caso base

### Recursión para Árboles

Los árboles son **naturalmente recursivos**:
- Un árbol es un nodo con hijos
- Cada hijo es un árbol
- Caso base: Nodo sin hijos

```
        Raíz
       /    \
     Hijo1  Hijo2
     /  \
  Nieto1 Nieto2
```

**Definición recursiva:**
```
render(nodo):
  1. Renderizar este nodo
  2. Para cada hijo:
     render(hijo)  // ¡Recursivo!
```

---

## PostCard: Componente Recursivo

```tsx
// src/components/posts/PostCard.tsx

import { useState } from 'react'
import { Link } from 'react-router-dom'
import { formatDistanceToNow } from 'date-fns'
import { VoteButtons } from './VoteButtons'
import { ReplyForm } from './ReplyForm'
import type { Post } from '@/types'

interface PostCardProps {
  post: Post
  allPosts: Post[]  // Necesario para encontrar hijos
  threadId: string
  depth?: number  // Nivel de anidación actual
  maxDepth?: number  // Máxima anidación antes de aplanar
}

/**
 * Componente de Tarjeta de Post Recursivo
 * 
 * Renderiza un solo post y recursivamente renderiza todas sus respuestas.
 * Esto crea la estructura de árbol de comentarios anidados.
 * 
 * Cómo funciona la recursión aquí:
 * 1. Renderizar este post
 * 2. Encontrar todos los hijos directos (posts donde parentId === id de este post)
 * 3. Para cada hijo, renderizar PostCard (¡llamada recursiva!)
 * 4. Cada hijo repite los pasos 1-3
 * 5. Caso base: Post sin hijos (detiene recursión)
 */
export function PostCard({
  post,
  allPosts,
  threadId,
  depth = 0,
  maxDepth = 10,
}: PostCardProps) {
  const [showReplyForm, setShowReplyForm] = useState(false)

  /**
   * Encontrar hijos directos de este post
   * 
   * Filtrar todos los posts para encontrar aquellos cuyo parentId coincide con el id de este post.
   * ¡Esta es la clave para construir la estructura de árbol desde datos planos!
   */
  const children = allPosts.filter((p) => p.parentId === post.id)

  /**
   * Verificar si alcanzamos la profundidad máxima
   * 
   * Después de cierta profundidad (ej. 10), aplanar respuestas restantes
   * para prevenir sangría excesiva y desbordamiento de pila
   */
  const isMaxDepth = depth >= maxDepth

  /**
   * Calcular sangría
   * 
   * Cada nivel añade 20px de padding izquierdo
   * Nivel 0: 0px, Nivel 1: 20px, Nivel 2: 40px, etc.
   */
  const indentPx = depth * 20

  /**
   * Determinar insignia de autor
   */
  const authorBadge = {
    admin: { label: 'Admin', color: 'bg-red-600' },
    moderator: { label: 'Mod', color: 'bg-blue-600' },
    user: null,
  }[post.author.role]

  return (
    <div
      style={{ marginLeft: `${indentPx}px` }}
      className="border-l-2 border-slate-800 pl-4 py-3"
    >
      {/* Encabezado del post */}
      <div className="flex items-center gap-2 mb-2">
        {/* Avatar */}
        <img
          src={post.author.avatarUrl || '/avatars/default.png'}
          alt={post.author.displayName}
          className="w-8 h-8 rounded-full"
        />

        {/* Info del autor */}
        <div className="flex items-center gap-2 text-sm">
          <Link
            to={`/users/${post.author.username}`}
            className="font-medium text-slate-200 hover:text-blue-400"
          >
            {post.author.displayName}
          </Link>

          {/* Insignia de rol */}
          {authorBadge && (
            <span className={`px-2 py-0.5 text-xs text-white rounded ${authorBadge.color}`}>
              {authorBadge.label}
            </span>
          )}

          {/* Timestamp */}
          <span className="text-slate-500">
            {formatDistanceToNow(new Date(post.createdAt), { addSuffix: true })}
          </span>

          {/* Indicador de editado */}
          {post.isEdited && (
            <span className="text-slate-500 text-xs">(editado)</span>
          )}
        </div>
      </div>

      {/* Contenido del post */}
      <div className="mb-3">
        {post.isDeleted ? (
          <p className="text-slate-500 italic">[eliminado]</p>
        ) : (
          <div
            className="prose prose-sm prose-invert max-w-none"
            dangerouslySetInnerHTML={{ __html: post.contentHtml }}
          />
        )}
      </div>

      {/* Acciones del post */}
      <div className="flex items-center gap-4">
        {/* Botones de voto */}
        <VoteButtons
          postId={post.id}
          score={post.voteScore}
          userVote={post.userVote}
        />

        {/* Botón de respuesta */}
        <button
          onClick={() => setShowReplyForm(!showReplyForm)}
          className="text-sm text-slate-400 hover:text-slate-200"
        >
          {showReplyForm ? 'Cancelar' : 'Responder'}
        </button>

        {/* Conteo de respuestas */}
        {children.length > 0 && (
          <span className="text-sm text-slate-500">
            {children.length} {children.length === 1 ? 'respuesta' : 'respuestas'}
          </span>
        )}
      </div>

      {/* Formulario de respuesta */}
      {showReplyForm && (
        <div className="mt-4">
          <ReplyForm
            threadId={threadId}
            parentId={post.id}
            onSuccess={() => setShowReplyForm(false)}
          />
        </div>
      )}

      {/* PARTE RECURSIVA: Renderizar hijos */}
      {children.length > 0 && !isMaxDepth && (
        <div className="mt-4 space-y-4">
          {children.map((child) => (
            <PostCard
              key={child.id}
              post={child}
              allPosts={allPosts}
              threadId={threadId}
              depth={depth + 1}  // Incrementar profundidad
              maxDepth={maxDepth}
            />
          ))}
        </div>
      )}

      {/* Advertencia de profundidad máxima */}
      {children.length > 0 && isMaxDepth && (
        <div className="mt-4 p-3 bg-slate-900 rounded-lg border border-slate-800">
          <p className="text-sm text-slate-400">
            {children.length} {children.length === 1 ? 'respuesta' : 'respuestas'} más...
          </p>
          <Link
            to={`/threads/${threadId}/post/${post.id}`}
            className="text-sm text-blue-400 hover:text-blue-300"
          >
            Ver hilo →
          </Link>
        </div>
      )}
    </div>
  )
}
```

---

## Cómo Funciona la Recursión: Traza Visual

Traza cómo la recursión construye el árbol:

**Datos:**
```typescript
[
  { id: '1', parentId: null, content: '¡Empieza con docs!' },
  { id: '2', parentId: '1', content: 'Prefiero videos' },
  { id: '3', parentId: '2', content: '¿Recomendaciones?' },
]
```

**Ejecución:**
```
PostCard(post#1, depth=0)
  → Renderiza post#1
  → Encuentra hijos: [post#2]
  → Llama PostCard(post#2, depth=1)
      → Renderiza post#2
      → Encuentra hijos: [post#3]
      → Llama PostCard(post#3, depth=2)
          → Renderiza post#3
          → Encuentra hijos: []
          → ¡Caso base! Sin hijos, detiene recursión
          → Retorna
      → post#2 terminó de renderizar
      → Retorna
  → post#1 terminó de renderizar
  → Retorna
```

**Resultado:**
```
Post #1
  └─ Post #2
      └─ Post #3
```

---

## PostList: Punto de Entrada

```tsx
// src/components/posts/PostList.tsx

import { PostCard } from './PostCard'
import type { Post } from '@/types'

interface PostListProps {
  posts: Post[]
  threadId: string
}

/**
 * PostList: Renderiza la raíz del árbol
 * 
 * Solo renderiza posts de NIVEL SUPERIOR (parentId === null).
 * PostCard maneja renderizar hijos recursivamente.
 */
export function PostList({ posts, threadId }: PostListProps) {
  /**
   * Filtrar solo posts raíz
   * 
   * No queremos renderizar todos los posts planos aquí.
   * PostCard renderizará recursivamente los hijos.
   */
  const rootPosts = posts.filter((post) => post.parentId === null)

  /**
   * Ordenar por puntuación de voto (populares primero) o por fecha (recientes primero)
   */
  const sortedPosts = [...rootPosts].sort((a, b) => {
    return b.voteScore - a.voteScore  // Mayor puntuación primero
  })

  if (posts.length === 0) {
    return (
      <div className="text-center py-12 bg-slate-900 rounded-lg border border-slate-800">
        <p className="text-slate-400">Sin respuestas aún. ¡Sé el primero!</p>
      </div>
    )
  }

  return (
    <div className="space-y-6">
      <h2 className="text-2xl font-bold text-slate-100">
        {posts.length} {posts.length === 1 ? 'Respuesta' : 'Respuestas'}
      </h2>

      <div className="space-y-4">
        {sortedPosts.map((post) => (
          <PostCard
            key={post.id}
            post={post}
            allPosts={posts}  // Pasar TODOS los posts para búsqueda de hijos
            threadId={threadId}
            depth={0}  // Empezar en profundidad 0
          />
        ))}
      </div>
    </div>
  )
}
```

---

## Rendimiento: Evitar Re-Renders

### Problema: Re-renderizar todo el árbol

Cada vez que CUALQUIER post se actualiza, todo el árbol se re-renderiza. Para hilos grandes (1000+ posts), esto es lento.

### Solución: React.memo

```tsx
import { memo } from 'react'

/**
 * PostCard Memoizado
 * 
 * Solo se re-renderiza si cambian los props.
 * Previene re-renders innecesarios de hijos cuando el padre se actualiza.
 */
export const PostCard = memo(function PostCard({
  post,
  allPosts,
  threadId,
  depth = 0,
  maxDepth = 10,
}: PostCardProps) {
  // ... código del componente
})
```

**Cómo funciona React.memo:**
```
Padre se actualiza
  → React verifica si los props de PostCard cambiaron
    → ¿Sin cambios? ¡Omitir re-render!
    → ¿Cambió? Re-renderizar esta tarjeta y hijos
```

### Avanzado: Comparación personalizada

```tsx
export const PostCard = memo(
  function PostCard(props) {
    // ... código del componente
  },
  (prevProps, nextProps) => {
    // Comparación personalizada
    // Devuelve true si los props son iguales (omitir re-render)
    return (
      prevProps.post.id === nextProps.post.id &&
      prevProps.post.voteScore === nextProps.post.voteScore &&
      prevProps.post.content === nextProps.post.content
    )
  }
)
```

---

## Avanzado: useDeferredValue para Listas Grandes

**Problema:** Con 1000+ posts, el renderizado toma tiempo. La entrada se vuelve lenta mientras React renderiza el árbol.

**Solución:** `useDeferredValue` difiere el renderizado de listas grandes, manteniendo la entrada responsiva.

### ¿Qué es useDeferredValue?

`useDeferredValue` te permite diferir la actualización de un valor no crítico. React hará:
1. Mantener las actualizaciones urgentes (entrada) responsivas
2. Procesar actualizaciones diferidas (lista grande) en segundo plano
3. Mostrar datos obsoletos mientras procesa

**Similar a useTransition, pero para valores en lugar de actualizaciones de estado.**

### Cómo Funciona

```tsx
import { useDeferredValue, useState } from 'react'

function ThreadPosts({ threadId }) {
  const [sortBy, setSortBy] = useState('newest')
  
  // Obtener todos los posts
  const [posts] = useState<Post[]>([...1000 posts...])
  
  /**
   * useDeferredValue: Diferir ordenamiento/filtrado
   * 
   * Cuando sortBy cambia:
   * 1. La entrada se actualiza inmediatamente
   * 2. deferredSortBy se actualiza en segundo plano
   * 3. La lista grande se re-renderiza con nuevo orden
   * 
   * Resultado: ¡La entrada siempre responsiva!
   */
  const deferredSortBy = useDeferredValue(sortBy)
  
  // Operación costosa: Ordenar 1000 posts
  const sortedPosts = useMemo(() => {
    console.log('Ordenando posts...')
    return [...posts].sort((a, b) => {
      if (deferredSortBy === 'newest') {
        return new Date(b.createdAt).getTime() - new Date(a.createdAt).getTime()
      }
      if (deferredSortBy === 'oldest') {
        return new Date(a.createdAt).getTime() - new Date(b.createdAt).getTime()
      }
      if (deferredSortBy === 'popular') {
        return b.voteScore - a.voteScore
      }
      return 0
    })
  }, [posts, deferredSortBy])
  
  // Mostrar indicador de carga mientras difiere
  const isPending = sortBy !== deferredSortBy
  
  return (
    <div>
      {/* Dropdown de orden - siempre responsivo */}
      <select 
        value={sortBy}
        onChange={(e) => setSortBy(e.target.value)}
      >
        <option value="newest">Más Recientes Primero</option>
        <option value="oldest">Más Antiguos Primero</option>
        <option value="popular">Más Populares</option>
      </select>
      
      {/* Indicador de carga */}
      {isPending && <p className="text-slate-400">Ordenando...</p>}
      
      {/* Lista grande - renderiza en segundo plano */}
      <div className={isPending ? 'opacity-50' : 'opacity-100'}>
        {sortedPosts.map(post => (
          <PostCard key={post.id} post={post} allPosts={sortedPosts} />
        ))}
      </div>
    </div>
  )
}
```

### Línea de Tiempo Visual

```
SIN useDeferredValue:
Usuario hace clic en "Popular"
  → La entrada se actualiza
  → Ordenando 1000 posts (¡lento!)
  → La entrada se congela ❌
  → El ordenamiento termina
  → La entrada vuelve a ser responsiva

CON useDeferredValue:
Usuario hace clic en "Popular"
  → La entrada se actualiza inmediatamente ✅
  → El ordenamiento comienza en segundo plano
  → La entrada permanece responsiva ✅
  → El ordenamiento termina
  → La lista se actualiza con nuevo orden
```

### useDeferredValue vs useTransition

| Aspecto | useTransition | useDeferredValue |
|---------|---------------|-----------------|
| **Qué difiere** | Actualizaciones de estado | Valores |
| **Sintaxis** | `startTransition(() => setState())` | `const deferred = useDeferredValue(value)` |
| **Caso de uso** | Múltiples actualizaciones de estado | Valor costoso único |
| **Ejemplo** | Resultados de búsqueda | Lista ordenada |
| **Estado pendiente** | `isPending` | Verificar `value !== deferredValue` |

### Ejemplo Completo: Posts de Hilo Ordenables

```tsx
function ThreadPosts({ threadId }: { threadId: string }) {
  const [posts, setPostsState] = useState<Post[]>([])
  const [sortBy, setSortBy] = useState<'newest' | 'oldest' | 'popular'>('newest')
  const [filterAuthor, setFilterAuthor] = useState<string | null>(null)
  
  // Diferir ordenamiento/filtrado costoso
  const deferredSortBy = useDeferredValue(sortBy)
  const deferredFilterAuthor = useDeferredValue(filterAuthor)
  
  // Costoso: Filtrar + Ordenar 1000 posts
  const processedPosts = useMemo(() => {
    let result = [...posts]
    
    // Filtrar por autor
    if (deferredFilterAuthor) {
      result = result.filter(p => p.author.id === deferredFilterAuthor)
    }
    
    // Ordenar
    result.sort((a, b) => {
      switch (deferredSortBy) {
        case 'newest':
          return new Date(b.createdAt).getTime() - new Date(a.createdAt).getTime()
        case 'oldest':
          return new Date(a.createdAt).getTime() - new Date(b.createdAt).getTime()
        case 'popular':
          return b.voteScore - a.voteScore
      }
    })
    
    return result
  }, [posts, deferredSortBy, deferredFilterAuthor])
  
  // Verificar si actualmente diferiendo
  const isProcessing = 
    sortBy !== deferredSortBy || 
    filterAuthor !== deferredFilterAuthor
  
  return (
    <div className="space-y-4">
      {/* Controles - siempre responsivos */}
      <div className="flex gap-4">
        <select 
          value={sortBy}
          onChange={(e) => setSortBy(e.target.value as any)}
          className="px-3 py-2 bg-slate-900 border border-slate-700 rounded"
        >
          <option value="newest">Más Recientes</option>
          <option value="oldest">Más Antiguos</option>
          <option value="popular">Populares</option>
        </select>
        
        <select 
          value={filterAuthor || ''}
          onChange={(e) => setFilterAuthor(e.target.value || null)}
          className="px-3 py-2 bg-slate-900 border border-slate-700 rounded"
        >
          <option value="">Todos los Autores</option>
          {/* Opciones de autor */}
        </select>
      </div>
      
      {/* Indicador de procesamiento */}
      {isProcessing && (
        <p className="text-slate-400 text-sm">Procesando...</p>
      )}
      
      {/* Lista grande - renderiza con valores diferidos */}
      <div className={isProcessing ? 'opacity-60' : 'opacity-100'}>
        {processedPosts.map(post => (
          <PostCard 
            key={post.id} 
            post={post} 
            allPosts={processedPosts}
            threadId={threadId}
          />
        ))}
      </div>
    </div>
  )
}
```

### Beneficios Clave

✅ **La entrada siempre responsiva** - Sin lag mientras procesa
✅ **UX suave** - Muestra datos obsoletos mientras actualiza
✅ **Automático** - React maneja la diferición
✅ **Simple** - Solo envuelve el valor
✅ **Escalable** - Funciona con cualquier tamaño de lista

### Cuándo Usar

- ✅ Listas grandes (1000+ elementos)
- ✅ Filtrado/ordenamiento costoso
- ✅ Quieres entrada responsiva
- ✅ Puedes mostrar datos obsoletos temporalmente

---

## Resumen

### Conceptos Clave

1. **Recursión**: Función se llama a sí misma
   - Caso base: Cuándo detenerse
   - Caso recursivo: Llamarse a sí misma con entrada más simple

2. **Estructuras de Árbol**: Naturalmente recursivas
   - Nodo con hijos
   - Cada hijo es un árbol

3. **Datos Planos + Recursión**: Mejor de ambos mundos
   - Almacenar datos planos (actualizaciones más fáciles)
   - Renderizar recursivamente (estructura de árbol)

4. **React.memo**: Prevenir re-renders innecesarios
   - Memoizar componentes
   - Comparación personalizada para optimización

### Mejores Prácticas

- ✅ Usar estructura de datos plana con `parentId`
- ✅ Implementar recursión cuidadosamente (¡evitar bucles infinitos!)
- ✅ Establecer profundidad máxima para prevenir anidación excesiva
- ✅ Memoizar componentes recursivos para rendimiento
- ✅ Ordenar en cada nivel (no solo raíz)
- ✅ Manejar estados vacíos elegantemente

---

Siguiente: [Crear Respuesta →](/es/react/6.posts-module/2.create-reply)
