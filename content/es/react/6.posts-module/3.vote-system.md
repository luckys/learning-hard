---
title: Sistema de Votos - UI Optimista y Gestión de Estado Compleja
description: Domina actualizaciones optimistas, lógica de toggle de votos, cálculos de puntuación, resolución de conflictos y patrones de retroalimentación instantánea. Construye votación estilo Reddit con UX perfecta.
---

# Disclaimer

:::u-alert
---
title: Los comentarios en el código son solo educativos.
description: En proyectos reales, evita comentarios irrelevantes o redundantes.
color: warning
variant: subtle
icon: i-lucide-triangle-alert
---
:::

Votar es engañosamente complejo. Parece simple (dos flechas y un número), pero requiere gestión cuidadosa del estado: **actualizaciones optimistas** para retroalimentación instantánea, **lógica de toggle** para cambiar votos, **cálculos de puntuación** que consideran el estado anterior, y **resolución de conflictos** cuando las cosas salen mal.

---

## Qué Estamos Construyendo

Un sistema de votación estilo Reddit/Hacker News:

**Visual:**
```
   ▲  Upvote (activo: azul, inactivo: gris)
  +5   Puntuación (verde si positivo, rojo si negativo, gris si cero)
   ▼  Downvote (activo: rojo, inactivo: gris)
```

**Interacciones del usuario:**
1. **Primer upvote**: `puntuación: 0 → 1`, `userVote: null → 'up'`
2. **Hacer clic en upvote de nuevo**: `puntuación: 1 → 0`, `userVote: 'up' → null` (toggle off)
3. **Cambiar a downvote**: `puntuación: 1 → -1`, `userVote: 'up' → 'down'` (remueve +1, añade -1 = neto -2)

**Requisitos:**
- **Retroalimentación instantánea**: UI se actualiza antes de que la API responda
- **Comportamiento de toggle**: Hacer clic en mismo botón dos veces para remover voto
- **Cambiar votos**: Hacer clic en botón opuesto para cambiar voto
- **Matemáticas correctas**: La puntuación se ajusta basada en voto anterior
- **Reversión en error**: Revertir UI si la API falla
- **UI optimista**: Mostrar nuevo estado inmediatamente
- **Sin doble voto**: Prevenir clics spam

---

## El Desafío: Matemáticas del Estado de Voto

### Entendiendo las Transiciones de Estado

Votar no es solo "añadir 1" o "restar 1". Debes considerar el **voto anterior**:

**Escenario 1: Primer upvote**
```
Antes: puntuación = 0, userVote = null
Acción: Usuario hace clic en upvote
Después:  puntuación = 1, userVote = 'up'
Cambio: +1
```

**Escenario 2: Toggle off upvote**
```
Antes: puntuación = 1, userVote = 'up'
Acción: Usuario hace clic en upvote de nuevo
Después:  puntuación = 0, userVote = null
Cambio: -1
```

**Escenario 3: Cambiar de upvote a downvote**
```
Antes: puntuación = 1, userVote = 'up'
Acción: Usuario hace clic en downvote
Después:  puntuación = -1, userVote = 'down'
Cambio: -2 (remueve +1, añade -1)
```

**Escenario 4: Cambiar de downvote a upvote**
```
Antes: puntuación = -1, userVote = 'down'
Acción: Usuario hace clic en upvote
Después:  puntuación = 1, userVote = 'up'
Cambio: +2 (remueve -1, añade +1)
```

### El Algoritmo

```typescript
function calculateNewScore(
  currentScore: number,
  oldVote: 'up' | 'down' | null,
  newVote: 'up' | 'down' | null
): number {
  let score = currentScore

  // Paso 1: Remover efecto del voto anterior
  if (oldVote === 'up') score -= 1
  if (oldVote === 'down') score += 1

  // Paso 2: Añadir efecto del nuevo voto
  if (newVote === 'up') score += 1
  if (newVote === 'down') score -= 1

  return score
}
```

**¿Por qué dos pasos?**
- Siempre empezar desde estado "neutral" (remover voto anterior)
- Luego aplicar nuevo voto
- Maneja todos los casos consistentemente

---

## Componente de Botones de Voto

```tsx
// src/components/posts/VoteButtons.tsx

import { useState } from 'react'
import { useMutation, useQueryClient } from '@tanstack/react-query'
import { apiClient } from '@/lib/api-client'
import { toast } from '@/lib/toast'

interface VoteButtonsProps {
  postId: string
  score: number
  userVote: 'up' | 'down' | null
}

/**
 * VoteButtons - Sistema de upvote/downvote estilo Reddit
 * 
 * Características:
 * - Retroalimentación instantánea (actualizaciones optimistas)
 * - Comportamiento de toggle (hacer clic de nuevo para remover)
 * - Matemáticas de puntuación correctas (considera voto anterior)
 * - Manejo de errores (reversión en fallo)
 * - Prevención de spam (deshabilitar durante solicitud)
 * - Retroalimentación visual (colores, estados hover)
 * 
 * Gestión de estado:
 * - Estado del servidor: React Query (caché + mutaciones)
 * - Actualizaciones optimistas: Actualizar caché antes de que la API responda
 * - Reversión: Restaurar estado anterior en error
 */
export function VoteButtons({ postId, score, userVote }: VoteButtonsProps) {
  const queryClient = useQueryClient()
  
  /**
   * Mutación de voto
   * 
   * Maneja tres operaciones:
   * 1. Añadir upvote: POST /posts/:id/vote { type: 'up' }
   * 2. Añadir downvote: POST /posts/:id/vote { type: 'down' }
   * 3. Remover voto: DELETE /posts/:id/vote
   */
  const voteMutation = useMutation({
    /**
     * mutationFn: La llamada API
     * 
     * Toma nuevo tipo de voto (o null para remover)
     * Devuelve respuesta de API
     */
    mutationFn: async (voteType: 'up' | 'down' | null) => {
      if (voteType === null) {
        // Remover voto
        return apiClient.delete(`/posts/${postId}/vote`)
      } else {
        // Añadir/cambiar voto
        return apiClient.post(`/posts/${postId}/vote`, { type: voteType })
      }
    },

    /**
     * onMutate: Se ejecuta ANTES de la llamada API
     * 
     * Aquí hacemos actualizaciones optimistas:
     * 1. Cancelar consultas salientes (prevenir condiciones de carrera)
     * 2. Guardar estado actual (para reversión)
     * 3. Actualizar caché con nuevo valor
     * 
     * Devuelve contexto (estado anterior) para reversión
     */
    onMutate: async (newVote) => {
      /**
       * Cancelar consultas salientes
       * 
       * Si ya hay una consulta obteniendo este post,
       * cancelarla para prevenir que sobreescriba nuestra
       * actualización optimista con datos obsoletos
       */
      await queryClient.cancelQueries({ queryKey: ['post', postId] })

      /**
       * Capturar estado actual
       * 
       * Guardarlo para poder revertir si la llamada API falla
       */
      const previousPost = queryClient.getQueryData(['post', postId])

      /**
       * Actualizar caché optimistamente
       * 
       * Actualizar la UI inmediatamente, antes de que la API responda
       */
      queryClient.setQueryData(['post', postId], (old: any) => {
        if (!old) return old

        /**
         * Calcular nueva puntuación
         * 
         * Debe considerar voto anterior:
         * - Si cambia de up a down, el cambio es -2
         * - Si hace toggle off, el cambio es -1 o +1
         * - Si es primer voto, el cambio es +1 o -1
         */
        let newScore = old.score
        const oldVote = old.userVote

        // Remover efecto del voto anterior
        if (oldVote === 'up') newScore -= 1
        if (oldVote === 'down') newScore += 1

        // Añadir efecto del nuevo voto
        if (newVote === 'up') newScore += 1
        if (newVote === 'down') newScore -= 1

        return {
          ...old,
          score: newScore,
          userVote: newVote,
        }
      })

      /**
       * Devolver contexto para reversión
       * 
       * Si la API falla, usaremos esto para restaurar el estado
       */
      return { previousPost }
    },

    /**
     * onError: Se ejecuta si la llamada API falla
     * 
     * Revertir actualización optimista
     */
    onError: (err, newVote, context) => {
      /**
       * Restaurar estado anterior
       * 
       * La actualización optimista falló, así que revertir UI
       */
      if (context?.previousPost) {
        queryClient.setQueryData(['post', postId], context.previousPost)
      }

      /**
       * Mostrar mensaje de error
       */
      toast.error('Falló votar. Por favor intenta de nuevo.')
    },

    /**
     * onSuccess: Se ejecuta si la llamada API tiene éxito
     * 
     * Actualizar caché con datos reales del servidor
     * (en caso de que el servidor calculó la puntuación diferente)
     */
    onSuccess: (response) => {
      /**
       * Reemplazar datos optimistas con datos reales
       */
      queryClient.setQueryData(['post', postId], response.data)
    },
  })

  /**
   * Manejar clic de voto
   * 
   * Implementa lógica de toggle:
   * - Hacer clic en mismo botón dos veces: remover voto
   * - Hacer clic en botón opuesto: cambiar voto
   */
  const handleVote = (type: 'up' | 'down') => {
    /**
     * Lógica de toggle
     * 
     * Si el usuario hace clic en mismo botón que ya votó:
     *   newVote = null (remover voto)
     * Si no:
     *   newVote = type (añadir o cambiar voto)
     */
    const newVote = userVote === type ? null : type

    /**
     * Disparar mutación
     * 
     * Esto hará:
     * 1. Ejecutar onMutate (actualización optimista)
     * 2. Llamar a API
     * 3. Ejecutar onSuccess u onError
     */
    voteMutation.mutate(newVote)
  }

  /**
   * Deshabilitar botones durante mutación
   * 
   * Previene clics spam y condiciones de carrera
   */
  const isDisabled = voteMutation.isPending

  return (
    <div className="flex items-center gap-2">
      {/* Botón Upvote */}
      <button
        onClick={() => handleVote('up')}
        disabled={isDisabled}
        className={`
          p-1.5 rounded transition-colors
          ${isDisabled ? 'cursor-not-allowed opacity-50' : ''}
          ${
            userVote === 'up'
              ? 'text-blue-500'  // Activo: azul
              : 'text-slate-500 hover:text-blue-400'  // Inactivo: gris, hover azul
          }
        `}
        aria-label="Upvote"
        aria-pressed={userVote === 'up'}
      >
        ▲
      </button>

      {/* Visualización de Puntuación */}
      <span
        className={`
          text-sm font-medium min-w-[2ch] text-center
          ${
            score > 0
              ? 'text-green-400'  // Positivo: verde
              : score < 0
              ? 'text-red-400'  // Negativo: rojo
              : 'text-slate-400'  // Cero: gris
          }
        `}
      >
        {score > 0 ? `+${score}` : score}
      </span>

      {/* Botón Downvote */}
      <button
        onClick={() => handleVote('down')}
        disabled={isDisabled}
        className={`
          p-1.5 rounded transition-colors
          ${isDisabled ? 'cursor-not-allowed opacity-50' : ''}
          ${
            userVote === 'down'
              ? 'text-red-500'  // Activo: rojo
              : 'text-slate-500 hover:text-red-400'  // Inactivo: gris, hover rojo
          }
        `}
        aria-label="Downvote"
        aria-pressed={userVote === 'down'}
      >
        ▼
      </button>
    </div>
  )
}
```

---

## Probando Lógica de Voto

```tsx
// src/components/posts/__tests__/VoteButtons.test.tsx

import { render, screen, waitFor } from '@testing-library/react'
import userEvent from '@testing-library/user-event'
import { VoteButtons } from '../VoteButtons'
import { apiClient } from '@/lib/api-client'
import { QueryClient, QueryClientProvider } from '@tanstack/react-query'

vi.mock('@/lib/api-client')

describe('VoteButtons', () => {
  const queryClient = new QueryClient()

  function renderVoteButtons(props: Partial<VoteButtonsProps> = {}) {
    return render(
      <QueryClientProvider client={queryClient}>
        <VoteButtons
          postId="post123"
          score={0}
          userVote={null}
          {...props}
        />
      </QueryClientProvider>
    )
  }

  it('upvota desde neutral', async () => {
    const user = userEvent.setup()
    vi.mocked(apiClient.post).mockResolvedValueOnce({
      data: { score: 1, userVote: 'up' },
    })

    renderVoteButtons()

    await user.click(screen.getByLabelText('Upvote'))

    // Debería mostrar +1 optimistamente
    expect(screen.getByText('+1')).toBeInTheDocument()

    // Debería llamar a API
    await waitFor(() => {
      expect(apiClient.post).toHaveBeenCalledWith(
        '/posts/post123/vote',
        { type: 'up' }
      )
    })
  })

  it('hace toggle off upvote', async () => {
    const user = userEvent.setup()
    vi.mocked(apiClient.delete).mockResolvedValueOnce({
      data: { score: 0, userVote: null },
    })

    renderVoteButtons({ score: 1, userVote: 'up' })

    await user.click(screen.getByLabelText('Upvote'))

    // Debería mostrar 0 optimistamente
    expect(screen.getByText('0')).toBeInTheDocument()

    // Debería llamar a DELETE
    await waitFor(() => {
      expect(apiClient.delete).toHaveBeenCalledWith('/posts/post123/vote')
    })
  })

  it('cambia de upvote a downvote', async () => {
    const user = userEvent.setup()
    vi.mocked(apiClient.post).mockResolvedValueOnce({
      data: { score: -1, userVote: 'down' },
    })

    renderVoteButtons({ score: 1, userVote: 'up' })

    await user.click(screen.getByLabelText('Downvote'))

    // Debería mostrar -1 (removió +1, añadió -1)
    expect(screen.getByText('-1')).toBeInTheDocument()
  })

  it('revierte en error', async () => {
    const user = userEvent.setup()
    vi.mocked(apiClient.post).mockRejectedValueOnce(new Error('Error de red'))

    renderVoteButtons({ score: 0, userVote: null })

    await user.click(screen.getByLabelText('Upvote'))

    // Debería revertir a 0 después del error
    await waitFor(() => {
      expect(screen.getByText('0')).toBeInTheDocument()
    })
  })
})
```

---

## Resumen

### Conceptos Clave Dominados

1. **Actualizaciones Optimistas**: Actualizar UI antes de que la API responda
   - Retroalimentación instantánea (mejor UX)
   - Reversión en error (confiabilidad)

2. **Lógica de Toggle**: Hacer clic en mismo botón dos veces para remover
   ```tsx
   const newVote = userVote === type ? null : type
   ```

3. **Matemáticas de Puntuación**: Considerar voto anterior
   ```tsx
   // Remover efecto del voto anterior
   if (oldVote === 'up') score -= 1
   if (oldVote === 'down') score += 1
   
   // Añadir efecto del nuevo voto
   if (newVote === 'up') score += 1
   if (newVote === 'down') score -= 1
   ```

4. **Mutaciones de React Query**: Manejar estado asíncrono
   - `onMutate`: Actualización optimista
   - `onError`: Reversión
   - `onSuccess`: Actualizar con datos reales

5. **Prevención de Condiciones de Carrera**: Cancelar consultas salientes
   ```tsx
   await queryClient.cancelQueries({ queryKey: ['post', postId] })
   ```

### Mejores Prácticas

- ✅ Actualizaciones optimistas para retroalimentación instantánea
- ✅ Reversión en error (no dejar UI en mal estado)
- ✅ Deshabilitar botones durante mutación (prevenir spam)
- ✅ Retroalimentación visual (colores para estado de voto)
- ✅ Accesibilidad (aria-label, aria-pressed)
- ✅ Probar todos los escenarios (neutral, toggle, cambiar)
- ✅ Manejar errores de red elegantemente

### Errores Comunes

- ❌ Olvidar considerar voto anterior en cálculos
- ❌ No cancelar consultas salientes (condiciones de carrera)
- ❌ No deshabilitar botones (bugs de doble clic)
- ❌ No revertir en error (UI corrupta)
- ❌ Codificar cambios de puntuación (+1/-1) en lugar de calcular

---

Siguiente: [Editar y Eliminar Posts →](/es/react/6.posts-module/4.edit-delete)
