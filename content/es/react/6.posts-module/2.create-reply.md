---
title: Crear Respuesta - Formularios Sensibles al Contexto y ComposiciÃ³n Inline
description: Domina formularios inline, propagaciÃ³n de contexto padre, composiciÃ³n markdown, actualizaciones optimistas y patrones de interacciÃ³n anidados. Construye un sistema de respuestas listo para producciÃ³n.
---

# Disclaimer

:::u-alert
---
title: Los comentarios en el cÃ³digo son solo educativos.
description: En proyectos reales, evita comentarios irrelevantes o redundantes.
color: warning
variant: subtle
icon: i-lucide-triangle-alert
---
:::

Crear respuestas es fundamentalmente diferente de crear hilos. Las respuestas son **contextuales** - deben conocer su padre, aparecer inline e integrarse perfectamente en el Ã¡rbol de conversaciÃ³n. Esto introduce nuevos patrones: formularios inline, propagaciÃ³n de contexto y gestiÃ³n de estado UI anidado.

---

## QuÃ© Estamos Construyendo

Un sofisticado sistema de respuestas con:
- **ComposiciÃ³n inline**: El formulario aparece debajo del post padre
- **Conciencia del contexto**: Conoce el post padre y el hilo
- **Soporte markdown**: Editor completo con vista previa
- **Menciones de usuario**: autocompletado @username
- **Guardado de borradores**: Auto-guardado a localStorage
- **Actualizaciones optimistas**: La respuesta aparece instantÃ¡neamente
- **Hilos anidados**: Soporte para profundidad de respuesta ilimitada
- **Atajos de teclado**: Cmd+Enter para enviar
- **Comportamiento de cancelaciÃ³n**: Descartar borrador con confirmaciÃ³n

**Flujo Visual:**
```
Post por @alice: "Â¿CÃ³mo aprendo React?"
  [BotÃ³n Responder]

Usuario hace clic en Responder â†’

Post por @alice: "Â¿CÃ³mo aprendo React?"
  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
  â”‚ [Editor Markdown]                    â”‚
  â”‚ Escribe tu respuesta...              â”‚
  â”‚                                     â”‚
  â”‚ [Vista Previa] [Cancelar] [Enviar]   â”‚
  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜

Usuario escribe y envÃ­a â†’

Post por @alice: "Â¿CÃ³mo aprendo React?"
  â””â”€ Post por @bob: "Â¡Empieza con la documentaciÃ³n!" (NUEVO)
     [BotÃ³n Responder]
```

---

## El DesafÃ­o: Formularios Inline vs Formularios Modales

### Dos Enfoques para Formularios de Respuesta

**Enfoque 1: Formulario Modal** âŒ
```tsx
<button onClick={() => setShowModal(true)}>Responder</button>
<Modal isOpen={showModal}>
  <ReplyForm />
</Modal>
```

**Problemas:**
- Pierde contexto (no puede ver el post padre)
- Disruptivo (cubre toda la pantalla)
- DifÃ­cil de referenciar contenido padre
- Pobre UX para respuestas rÃ¡pidas

**Enfoque 2: Formulario Inline** âœ…
```tsx
<Post>
  <button onClick={() => setShowForm(true)}>Responder</button>
  {showForm && <ReplyForm />}
</Post>
```

**Beneficios:**
- Contexto preservado (padre visible)
- No disruptivo (se mantiene en el flujo)
- FÃ¡cil de referenciar al padre
- Mejor UX para conversaciones

---

## GestiÃ³n de Estado: Â¿QuiÃ©n Posee el Formulario?

### El Problema: Estado Anidado

Cada post puede tener un formulario de respuesta. Â¿DÃ³nde vive el estado del formulario?

**OpciÃ³n 1: Componente Padre** âŒ
```tsx
function ThreadPage() {
  const [replyingTo, setReplyingTo] = useState<string | null>(null)
  
  return posts.map(post => (
    <Post
      post={post}
      isReplying={replyingTo === post.id}
      onReply={() => setReplyingTo(post.id)}
    />
  ))
}
```

**Problemas:**
- El padre se re-renderiza en cada acciÃ³n de respuesta
- DifÃ­cil de gestionar mÃºltiples formularios abiertos
- Prop drilling (pasar callbacks hacia abajo)

**OpciÃ³n 2: Estado a Nivel de Componente** âœ…
```tsx
function Post({ post }: { post: Post }) {
  const [showReplyForm, setShowReplyForm] = useState(false)
  
  return (
    <div>
      <PostContent />
      <button onClick={() => setShowReplyForm(true)}>Responder</button>
      {showReplyForm && <ReplyForm />}
    </div>
  )
}
```

**Beneficios:**
- Estado aislado (sin re-renders del padre)
- MÃºltiples formularios pueden estar abiertos
- Sin prop drilling
- Modelo mental mÃ¡s simple

---

## Entendiendo el Contexto: threadId + parentId

Cada respuesta necesita DOS piezas de contexto:

1. **threadId**: Â¿En quÃ© hilo estÃ¡ esta respuesta?
2. **parentId**: Â¿A quÃ© post estÃ¡ respondiendo?

```typescript
interface ReplyContext {
  threadId: string  // "01HXQK9Z3XAMPLE000001"
  parentId: string  // "01HXQK9Z3XAMPLE000002"
}
```

**Â¿Por quÃ© ambos?**
- `threadId`: Para endpoint de API (`POST /threads/:threadId/posts`)
- `parentId`: Para construir estructura anidada
- El backend necesita ambos para validar y organizar

**Ejemplo:**
```
Hilo: "Â¿CÃ³mo aprender React?"  (threadId: abc123)
â”œâ”€ Post #1 por @alice            (id: post1, parentId: null)
â”‚  â””â”€ Respuesta por @bob         (id: post2, parentId: post1, threadId: abc123)
â”‚     â””â”€ Respuesta por @alice    (id: post3, parentId: post2, threadId: abc123)
â””â”€ Post #2 por @charlie          (id: post4, parentId: null)
```

---

## Componente de ComposiciÃ³n de Respuesta

```tsx
// src/components/posts/ReplyComposer.tsx

import { useState, useRef, useEffect } from 'react'
import { useForm } from 'react-hook-form'
import { zodResolver } from '@hookform/resolvers/zod'
import { z } from 'zod'
import { MarkdownEditor } from '@/components/ui/MarkdownEditor'
import { apiClient } from '@/lib/api-client'
import { toast } from '@/lib/toast'
import type { Post } from '@/types'

/**
 * Esquema de validaciÃ³n de respuesta
 * 
 * Reglas:
 * - MÃ­nimo 10 caracteres (prevenir spam)
 * - MÃ¡ximo 10,000 caracteres (prevenir abuso)
 * - Recortar espacios en blanco
 */
const replySchema = z.object({
  content: z
    .string()
    .trim()
    .min(10, 'La respuesta debe tener al menos 10 caracteres')
    .max(10000, 'La respuesta debe tener menos de 10,000 caracteres'),
})

type ReplyInput = z.infer<typeof replySchema>

interface ReplyComposerProps {
  threadId: string
  parentId: string
  parentAuthor: string  // Para visualizaciÃ³n de contexto
  onSuccess: (post: Post) => void
  onCancel: () => void
}

/**
 * ReplyComposer - Formulario inline para crear respuestas
 * 
 * CaracterÃ­sticas:
 * - Editor markdown con vista previa
 * - Auto-guardar borradores a localStorage
 * - Atajos de teclado (Cmd+Enter para enviar)
 * - Actualizaciones optimistas
 * - VisualizaciÃ³n de contexto (respondiendo a...)
 * 
 * GestiÃ³n de estado:
 * - Estado del formulario: React Hook Form
 * - Borrador: localStorage (clave: `draft-reply-${parentId}`)
 * - Toggle de vista previa: estado local
 */
export function ReplyComposer({
  threadId,
  parentId,
  parentAuthor,
  onSuccess,
  onCancel,
}: ReplyComposerProps) {
  const [showPreview, setShowPreview] = useState(false)
  const editorRef = useRef<HTMLTextAreaElement>(null)

  /**
   * ConfiguraciÃ³n del formulario con React Hook Form + Zod
   */
  const {
    register,
    handleSubmit,
    watch,
    setValue,
    formState: { errors, isSubmitting },
  } = useForm<ReplyInput>({
    resolver: zodResolver(replySchema),
    defaultValues: {
      // Cargar borrador desde localStorage
      content: loadDraft(parentId),
    },
  })

  const content = watch('content')

  /**
   * Auto-guardar borrador a localStorage
   * 
   * Con debounce para evitar escrituras excesivas
   */
  useEffect(() => {
    const timer = setTimeout(() => {
      if (content) {
        saveDraft(parentId, content)
      }
    }, 1000)  // Debounce de 1 segundo

    return () => clearTimeout(timer)
  }, [content, parentId])

  /**
   * Enfocar editor al montar
   * 
   * Mejor UX: el usuario puede empezar a escribir inmediatamente
   */
  useEffect(() => {
    editorRef.current?.focus()
  }, [])

  /**
   * Atajos de teclado
   * 
   * Cmd+Enter (Mac) / Ctrl+Enter (Windows): Enviar
   * Escape: Cancelar
   */
  useEffect(() => {
    const handleKeyDown = (e: KeyboardEvent) => {
      // Cmd+Enter o Ctrl+Enter: Enviar
      if ((e.metaKey || e.ctrlKey) && e.key === 'Enter') {
        e.preventDefault()
        handleSubmit(onSubmit)()
      }

      // Escape: Cancelar
      if (e.key === 'Escape') {
        e.preventDefault()
        handleCancel()
      }
    }

    document.addEventListener('keydown', handleKeyDown)
    return () => document.removeEventListener('keydown', handleKeyDown)
  }, [])

  /**
   * Manejador de envÃ­o
   * 
   * 1. Validar con Zod
   * 2. Enviar a API
   * 3. Limpiar borrador
   * 4. Llamar a onSuccess con nuevo post
   * 5. Mostrar notificaciÃ³n toast
   */
  const onSubmit = async (data: ReplyInput) => {
    try {
      const response = await apiClient.post<Post>('/posts', {
        threadId,
        parentId,
        content: data.content,
      })

      // Limpiar borrador
      clearDraft(parentId)

      // Mostrar Ã©xito
      toast.success('Â¡Respuesta publicada!')

      // Notificar al padre (aÃ±adirÃ¡ a UI optimistamente)
      onSuccess(response.data)
    } catch (error) {
      // Manejar errores
      const message =
        error instanceof Error
          ? error.message
          : 'FallÃ³ publicar respuesta'
      toast.error(message)
    }
  }

  /**
   * Manejador de cancelaciÃ³n
   * 
   * Si existe borrador, confirmar antes de descartar
   */
  const handleCancel = () => {
    if (content && content.length > 10) {
      if (
        !window.confirm(
          'Tienes cambios no guardados. Â¿Descartar borrador?'
        )
      ) {
        return
      }
    }

    // Limpiar borrador
    clearDraft(parentId)

    // Notificar al padre para ocultar formulario
    onCancel()
  }

  return (
    <div className="mt-4 p-4 bg-slate-900 rounded-lg border border-slate-800">
      {/* Encabezado de Contexto */}
      <div className="mb-3 text-sm text-slate-400">
        Respondiendo a{' '}
        <span className="text-blue-400 font-medium">
          @{parentAuthor}
        </span>
      </div>

      {/* Formulario */}
      <form onSubmit={handleSubmit(onSubmit)} className="space-y-4">
        {/* Editor Markdown */}
        <div>
          <MarkdownEditor
            ref={editorRef}
            value={content}
            onChange={(value) => setValue('content', value)}
            placeholder="Escribe tu respuesta... (Markdown soportado)"
            showPreview={showPreview}
            minHeight={120}
          />

          {/* Error de ValidaciÃ³n */}
          {errors.content && (
            <p className="mt-2 text-sm text-red-400">
              {errors.content.message}
            </p>
          )}

          {/* Conteo de Caracteres */}
          <div className="mt-2 text-xs text-slate-500">
            {content.length} / 10,000 caracteres
          </div>
        </div>

        {/* Acciones */}
        <div className="flex items-center justify-between">
          {/* Izquierda: Toggle de Vista Previa */}
          <button
            type="button"
            onClick={() => setShowPreview(!showPreview)}
            className="text-sm text-slate-400 hover:text-slate-200"
          >
            {showPreview ? 'âœï¸ Editar' : 'ğŸ‘ï¸ Vista Previa'}
          </button>

          {/* Derecha: Cancelar + Enviar */}
          <div className="flex items-center gap-3">
            <button
              type="button"
              onClick={handleCancel}
              className="px-4 py-2 bg-slate-800 text-slate-200 rounded-lg hover:bg-slate-700 transition-colors"
            >
              Cancelar
            </button>

            <button
              type="submit"
              disabled={isSubmitting || !content.trim()}
              className={`
                px-4 py-2 rounded-lg font-medium transition-colors
                ${
                  isSubmitting || !content.trim()
                    ? 'bg-blue-600/50 text-white cursor-not-allowed'
                    : 'bg-blue-600 text-white hover:bg-blue-700'
                }
              `}
            >
              {isSubmitting ? 'Publicando...' : 'Publicar Respuesta'}
            </button>
          </div>
        </div>

        {/* Sugerencia de Teclado */}
        <p className="text-xs text-slate-500">
          <kbd className="px-2 py-1 bg-slate-800 rounded text-xs">
            {navigator.platform.includes('Mac') ? 'âŒ˜' : 'Ctrl'}+Enter
          </kbd>{' '}
          para publicar,{' '}
          <kbd className="px-2 py-1 bg-slate-800 rounded text-xs">
            Esc
          </kbd>{' '}
          para cancelar
        </p>
      </form>
    </div>
  )
}

/**
 * Utilidades de GestiÃ³n de Borradores
 * 
 * Almacenar borradores en localStorage con claves Ãºnicas por post padre
 */

function getDraftKey(parentId: string): string {
  return `draft-reply-${parentId}`
}

function loadDraft(parentId: string): string {
  try {
    return localStorage.getItem(getDraftKey(parentId)) || ''
  } catch {
    return ''
  }
}

function saveDraft(parentId: string, content: string): void {
  try {
    localStorage.setItem(getDraftKey(parentId), content)
  } catch (error) {
    console.error('FallÃ³ guardar borrador:', error)
  }
}

function clearDraft(parentId: string): void {
  try {
    localStorage.removeItem(getDraftKey(parentId))
  } catch (error) {
    console.error('FallÃ³ limpiar borrador:', error)
  }
}
```

---

## Resumen

### Patrones Clave Aprendidos

1. **Formularios Inline**: Mostrar formularios contextualmente, no en modales
2. **Estado a Nivel de Componente**: Aislar estado para prevenir re-renders del padre
3. **PropagaciÃ³n de Contexto**: Pasar threadId + parentId
4. **GestiÃ³n de Borradores**: Auto-guardar con localStorage
5. **Atajos de Teclado**: Cmd+Enter, Escape
6. **Actualizaciones Optimistas**: AÃ±adir a UI antes de confirmaciÃ³n de API
7. **DiÃ¡logos de ConfirmaciÃ³n**: Advertir antes de descartar borradores

### Mejores PrÃ¡cticas

- âœ… Auto-enfocar editor al montar
- âœ… Auto-guardar borradores con debounce
- âœ… Mostrar contexto ("Respondiendo a @usuario")
- âœ… Atajos de teclado para usuarios avanzados
- âœ… Conteo de caracteres para guÃ­a
- âœ… Deshabilitar envÃ­o cuando estÃ¡ vacÃ­o
- âœ… Confirmar antes de descartar borradores
- âœ… Mensajes de error claros

---

Siguiente: [Sistema de Votos â†’](/es/react/6.posts-module/3.vote-system)

---

## Componente de Respuesta con Contexto

```tsx
// src/components/posts/ReplyComposer.tsx

import { useState } from 'react'
import { useForm } from 'react-hook-form'
import { zodResolver } from '@hookform/resolvers/zod'
import { z } from 'zod'
import { MarkdownEditor } from '@/components/ui/MarkdownEditor'
import { apiClient } from '@/lib/api-client'
import { toast } from '@/lib/toast'
import type { Post } from '@/types'

const replySchema = z.object({
  content: z.string().min(10, 'La respuesta debe tener al menos 10 caracteres'),
})

type ReplyInput = z.infer<typeof replySchema>

interface ReplyComposerProps {
  threadId: string
  parentId: string  // ID del post siendo respondido
  onSuccess: (post: Post) => void
  onCancel: () => void
}

export function ReplyComposer({
  threadId,
  parentId,
  onSuccess,
  onCancel,
}: ReplyComposerProps) {
  const [showPreview, setShowPreview] = useState(false)

  const {
    register,
    handleSubmit,
    watch,
    formState: { errors, isSubmitting },
  } = useForm<ReplyInput>({
    resolver: zodResolver(replySchema),
    defaultValues: { content: '' },
  })

  const content = watch('content')

  const onSubmit = async (data: ReplyInput) => {
    try {
      const response = await apiClient.post<Post>('/posts', {
        threadId,
        parentId,
        content: data.content,
      })

      toast.success('Â¡Respuesta publicada!')
      onSuccess(response.data)
    } catch (error) {
      toast.error('FallÃ³ publicar respuesta')
    }
  }

  return (
    <form onSubmit={handleSubmit(onSubmit)} className="mt-4 p-4 bg-slate-900 rounded-lg border border-slate-800">
      <MarkdownEditor
        value={content}
        onChange={(value) => register('content').onChange({ target: { value } })}
        placeholder="Escribe tu respuesta..."
        showPreview={showPreview}
      />

      {errors.content && (
        <p className="mt-2 text-sm text-red-400">{errors.content.message}</p>
      )}

      <div className="flex items-center gap-3 mt-4">
        <button
          type="submit"
          disabled={isSubmitting}
          className="px-4 py-2 bg-blue-600 text-white rounded-lg hover:bg-blue-700"
        >
          {isSubmitting ? 'Publicando...' : 'Publicar Respuesta'}
        </button>

        <button
          type="button"
          onClick={onCancel}
          className="px-4 py-2 bg-slate-800 text-slate-200 rounded-lg hover:bg-slate-700"
        >
          Cancelar
        </button>

        <button
          type="button"
          onClick={() => setShowPreview(!showPreview)}
          className="ml-auto text-sm text-slate-400 hover:text-slate-200"
        >
          {showPreview ? 'Editar' : 'Vista Previa'}
        </button>
      </div>
    </form>
  )
}
```

---

## Integrando Compositor de Respuesta

```tsx
// src/components/posts/PostCard.tsx

import { useState } from 'react'
import { ReplyComposer } from './ReplyComposer'

export function PostCard({ post, allPosts, threadId }: PostCardProps) {
  const [showReplyForm, setShowReplyForm] = useState(false)
  const [localPosts, setLocalPosts] = useState(allPosts)

  const handleReplySuccess = (newPost: Post) => {
    setLocalPosts([...localPosts, newPost])
    setShowReplyForm(false)
  }

  return (
    <div className="border-l-2 border-slate-800 pl-4 py-3">
      {/* Contenido del post */}
      <div>
        {/* ... encabezado del post, contenido, acciones ... */}
        
        <button
          onClick={() => setShowReplyForm(!showReplyForm)}
          className="text-sm text-slate-400 hover:text-slate-200"
        >
          {showReplyForm ? 'Cancelar' : 'Responder'}
        </button>
      </div>

      {/* Formulario de respuesta */}
      {showReplyForm && (
        <ReplyComposer
          threadId={threadId}
          parentId={post.id}
          onSuccess={handleReplySuccess}
          onCancel={() => setShowReplyForm(false)}
        />
      )}

      {/* Respuestas anidadas (recursivas) */}
      {/* ... */}
    </div>
  )
}
```

---

## Resumen

### Patrones Clave

1. **Formularios Inline**: Mostrar/ocultar formularios contextualmente
2. **Contexto Padre**: Pasar threadId + parentId
3. **Actualizaciones Optimistas**: AÃ±adir a estado local inmediatamente
4. **AcciÃ³n de CancelaciÃ³n**: Permitir que los usuarios puedan salir

---

Siguiente: [Sistema de Votos â†’](/es/react/6.posts-module/3.vote-system)
