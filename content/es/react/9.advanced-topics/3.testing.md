---
title: Testing de Componentes React - Unit, Integration & E2E
description: Domina las estrategias de testing: unit tests, integration tests, mocking, buenas prácticas y cobertura. Gana confianza en el código de tu foro.
---

# Disclaimer

:::u-alert
---
title: Los comentarios en el código son solo educativos.
description: En proyectos reales, evita comentarios irrelevantes o redundantes.
color: warning
variant: subtle
icon: i-lucide-triangle-alert
---
:::

El testing garantiza que tu foro funcione correctamente. **Los tests son documentación viva.** Muestran cómo se espera que se comporte el código. En este módulo usamos **React Testing Library + Vitest**.

---

## Testing Pyramid: el equilibrio correcto

```
        /\
       /  \
      / E2E \        Few (expensive, slow)
     /______\
    /        \
   /Integration\    Some (moderate cost)
  /____________\
 /              \
/   Unit Tests   \  Many (cheap, fast)
/________________\
```

- **Unit tests**: prueban funciones/componentes individuales de forma aislada.
- **Integration tests**: prueban varios componentes trabajando juntos.
- **E2E tests**: prueban flujos completos de usuario (caros, usar con moderación).

El objetivo es tener **muchos unit tests**, algunos integration y pocos E2E.

---

## Filosofía de testing: prueba comportamiento, no implementación

```tsx
// ❌ BAD: Testing implementation details
it('sets state to true', () => {
  const { result } = renderHook(() => useState(false))
  act(() => {
    result.current[1](true)
  })
  expect(result.current[0]).toBe(true)
})

// ✅ GOOD: Testing user behavior
it('shows success message when form submitted', async () => {
  const user = userEvent.setup()
  render(<SignUpForm />)
  
  await user.type(screen.getByLabelText('Email'), 'alice@example.com')
  await user.type(screen.getByLabelText('Password'), 'SecurePass123!')
  await user.click(screen.getByRole('button', { name: /sign up/i }))
  
  await waitFor(() => {
    expect(screen.getByText('Account created!')).toBeInTheDocument()
  })
})
```

**Por qué:** los detalles internos cambian con refactors; el comportamiento de usuario debería permanecer estable.

- Evita testear hooks internos, estados concretos o nombres de clases.
- Prefiere testear **qué ve y hace el usuario**.

---

## Unit Tests: componentes en aislamiento

```tsx
// src/components/threads/__tests__/ThreadCard.test.tsx

import { render, screen } from '@testing-library/react'
import userEvent from '@testing-library/user-event'
import { BrowserRouter } from 'react-router-dom'
import { ThreadCard } from '../ThreadCard'
import type { Thread } from '@/types'

const createMockThread = (overrides?: Partial<Thread>): Thread => ({
  id: '01HXQK9Z3XAMPLE000001',
  title: 'How to learn React?',
  slug: 'how-to-learn-react',
  content: 'I want to learn React...',
  authorId: 'user-1',
  author: {
    id: 'user-1',
    username: 'alice',
    displayName: 'Alice Wonder',
    avatarUrl: null,
  },
  categoryId: 'cat-1',
  category: {
    id: 'cat-1',
    name: 'Learning',
    slug: 'learning',
  },
  isPinned: false,
  isLocked: false,
  viewCount: 42,
  replyCount: 5,
  createdAt: '2024-01-15T10:00:00Z',
  updatedAt: '2024-01-15T10:00:00Z',
  ...overrides,
})

describe('ThreadCard', () => {
  it('renders thread title', () => {
    const thread = createMockThread()
    
    render(
      <BrowserRouter>
        <ThreadCard thread={thread} />
      </BrowserRouter>
    )
    
    expect(screen.getByText('How to learn React?')).toBeInTheDocument()
  })

  it('shows reply count', () => {
    const thread = createMockThread({ replyCount: 5 })
    
    render(
      <BrowserRouter>
        <ThreadCard thread={thread} />
      </BrowserRouter>
    )
    
    expect(screen.getByText(/5 replies/i)).toBeInTheDocument()
  })

  it('shows singular reply for one reply', () => {
    const thread = createMockThread({ replyCount: 1 })
    
    render(
      <BrowserRouter>
        <ThreadCard thread={thread} />
      </BrowserRouter>
    )
    
    expect(screen.getByText(/1 reply/i)).toBeInTheDocument()
  })

  it('shows pinned indicator when thread is pinned', () => {
    const thread = createMockThread({ isPinned: true })
    
    render(
      <BrowserRouter>
        <ThreadCard thread={thread} />
      </BrowserRouter>
    )
    
    expect(screen.getByTitle('Pinned')).toBeInTheDocument()
  })

  it('navigates to thread on click', async () => {
    const user = userEvent.setup()
    const thread = createMockThread()
    
    render(
      <BrowserRouter>
        <ThreadCard thread={thread} />
      </BrowserRouter>
    )
    
    const link = screen.getByRole('link')
    expect(link).toHaveAttribute('href', '/threads/how-to-learn-react')
  })
})
```

Puntos clave de estos unit tests:

- Usan **mock factories** (`createMockThread`) para datos realistas.
- Renderizan el componente dentro de `BrowserRouter` cuando hay links.
- Verifican contenido visible (título, reply count, indicadores).

---

## Integration Tests: flujos de usuario

```tsx
// src/pages/__tests__/CreateThreadPage.test.tsx

import { render, screen, waitFor } from '@testing-library/react'
import userEvent from '@testing-library/user-event'
import { BrowserRouter } from 'react-router-dom'
import { QueryClientProvider, QueryClient } from '@tanstack/react-query'
import { CreateThreadPage } from '../CreateThreadPage'
import { apiClient } from '@/lib/api-client'

vi.mock('@/lib/api-client')

describe('Create Thread Flow', () => {
  const queryClient = new QueryClient()

  it('creates thread successfully', async () => {
    const user = userEvent.setup()
    
    vi.mocked(apiClient.post).mockResolvedValueOnce({
      data: {
        id: 'thread-1',
        title: 'New Thread',
        slug: 'new-thread',
      },
    })

    render(
      <QueryClientProvider client={queryClient}>
        <BrowserRouter>
          <CreateThreadPage />
        </BrowserRouter>
      </QueryClientProvider>
    )

    await user.type(
      screen.getByLabelText(/title/i),
      'New Thread',
    )
    await user.type(
      screen.getByLabelText(/content/i),
      'This is my new thread',
    )

    await user.click(screen.getByRole('button', { name: /create/i }))

    await waitFor(() => {
      expect(screen.getByText(/thread created/i)).toBeInTheDocument()
    })

    expect(apiClient.post).toHaveBeenCalledWith('/threads', {
      title: 'New Thread',
      content: 'This is my new thread',
    })
  })

  it('shows validation errors', async () => {
    const user = userEvent.setup()

    render(
      <QueryClientProvider client={queryClient}>
        <BrowserRouter>
          <CreateThreadPage />
        </BrowserRouter>
      </QueryClientProvider>
    )

    await user.click(screen.getByRole('button', { name: /create/i }))

    await waitFor(() => {
      expect(screen.getByText(/title required/i)).toBeInTheDocument()
      expect(screen.getByText(/content required/i)).toBeInTheDocument()
    })

    expect(apiClient.post).not.toHaveBeenCalled()
  })

  it('handles API errors gracefully', async () => {
    const user = userEvent.setup()
    
    vi.mocked(apiClient.post).mockRejectedValueOnce(
      new Error('Server error')
    )

    render(
      <QueryClientProvider client={queryClient}>
        <BrowserRouter>
          <CreateThreadPage />
        </BrowserRouter>
      </QueryClientProvider>
    )

    await user.type(screen.getByLabelText(/title/i), 'New Thread')
    await user.type(screen.getByLabelText(/content/i), 'Content')
    await user.click(screen.getByRole('button', { name: /create/i }))

    await waitFor(() => {
      expect(screen.getByText(/server error/i)).toBeInTheDocument()
    })
  })
})
```

Estos integration tests cubren un flujo completo:

1. El usuario rellena el formulario.
2. La validación del formulario se ejecuta.
3. Se llama a la API con los datos correctos.
4. Se muestran mensajes de éxito o error.

---

## Testing Best Practices

### 1. Usa semantic queries

```tsx
// ❌ BAD: Implementation details
screen.getByTestId('submit-btn')
screen.getByClassName('error-message')

// ✅ GOOD: User-facing queries
screen.getByRole('button', { name: /submit/i })
screen.getByText(/error/i)
```

Prefiere queries que imiten cómo un usuario real interactúa con la UI:

- `getByRole`
- `getByLabelText`
- `getByText`

### 2. Mock de dependencias externas

```tsx
// Mock API calls
vi.mock('@/lib/api-client')

// Mock router
vi.mock('react-router-dom', async () => ({
  ...await vi.importActual('react-router-dom'),
  useNavigate: () => vi.fn(),
}))
```

### 3. Testea casos de error

```tsx
it('handles network errors', async () => {
  vi.mocked(apiClient.get).mockRejectedValueOnce(
    new Error('Network error')
  )
  
  render(<ThreadList />)
  
  await waitFor(() => {
    expect(screen.getByText(/network error/i)).toBeInTheDocument()
  })
})
```

### 4. Usa test factories

```tsx
const createMockThread = (overrides?: Partial<Thread>): Thread => ({
  id: '1',
  title: 'Test',
  // ... defaults
  ...overrides,
})
```

---

## Testing Checklist

- ✅ Testea comportamiento de usuario, no implementación interna.
- ✅ Usa semantic queries (`getByRole`, `getByText`).
- ✅ Mockea dependencias externas (API, router).
- ✅ Incluye casos de error y estados de loading.
- ✅ Cubre edge cases (lista vacía, 1 item, muchos items).
- ✅ Usa factories para datos de prueba.
- ✅ Verifica accesibilidad básica (roles ARIA).
- ❌ No testees detalles internos (clases, estados).
- ❌ No abuses del mocking (rompe los integration tests).
- ❌ No escribas tests excesivamente frágiles.

---

Next: [Deployment →](/es/react/9.advanced-topics/4.deployment)
