---
title: Server Components - Arquitectura Full-Stack de React
description: Domina los Server Components de React (React 19). Construye aplicaciones full-stack con fetching de datos del lado del servidor, tamaÃ±o de bundle reducido e interactividad sin interrupciones del cliente. Ejemplos reales de foros.
---

# Advertencia

:::u-alert
---
title: Los comentarios en el cÃ³digo son solo para fines educativos.
description: En proyectos reales, evita agregar comentarios irrelevantes o redundantes.
color: warning
variant: subtle
icon: i-lucide-triangle-alert
---
:::

Los Server Components de React (RSC) representan un cambio de paradigma en la arquitectura de React. Permiten **React full-stack** - escribir componentes que se ejecutan en el servidor, acceden directamente a bases de datos y envÃ­an solo el resultado renderizado al cliente.

---

## El Problema: Cascadas de Fetching de Datos del Lado del Cliente

### Enfoque Tradicional del Lado del Cliente

```tsx
// bundle.js (enviado al navegador)
import { useState, useEffect } from 'react'

function ThreadDetail({ threadId }) {
  const [thread, setThread] = useState(null)
  const [author, setAuthor] = useState(null)
  const [loading, setLoading] = useState(true)

  useEffect(() => {
    // Primero fetch del thread
    fetch(`/api/threads/${threadId}`)
      .then(res => res.json())
      .then(data => {
        setThread(data)
        
        // LUEGO fetch del autor (Â¡cascada!)
        return fetch(`/api/authors/${data.authorId}`)
      })
      .then(res => res.json())
      .then(data => {
        setAuthor(data)
        setLoading(false)
      })
  }, [threadId])

  if (loading) return <div>Cargando...</div>
  
  return (
    <div>
      <h1>{thread.title}</h1>
      <p>Por: {author.name}</p>
      <p>{thread.content}</p>
    </div>
  )
}
```

**Problemas:**
- âŒ **Cascada**: Fetch thread â†’ Fetch author (secuencial, lento)
- âŒ **Bundle grande**: Todo el cÃ³digo de fetching enviado al navegador
- âŒ **First paint lento**: Los datos cargan DESPUÃ‰S de que la pÃ¡gina renderiza
- âŒ **Secretos expuestos**: Claves API visibles en cÃ³digo cliente
- âŒ **Sobrecarga de red**: MÃºltiples round-trips

**LÃ­nea de tiempo:**
```
t=0ms:    El navegador carga la pÃ¡gina
t=100ms:  JS descargado y parseado
t=150ms:  Primer render (vacÃ­o)
t=200ms:  Fetch thread (solicitud 1)
t=400ms:  Respuesta del thread, fetch autor (solicitud 2)
t=600ms:  Respuesta del autor, render completo
Total: 600ms para ver contenido âŒ
```

---

## La SoluciÃ³n: Server Components de React

### Server Components: Renderizar en el Servidor

```tsx
// app/thread-detail.tsx (Server Component)
// Â¡Este cÃ³digo NUNCA llega al navegador!

import db from '@/lib/database'

async function ThreadDetail({ threadId }: { threadId: string }) {
  // Fetch directo de la base de datos (Â¡sin llamada API!)
  const thread = await db.threads.findById(threadId)
  
  // Fetch autor en paralelo (Â¡sin cascada!)
  const author = await db.authors.findById(thread.authorId)

  return (
    <div>
      <h1>{thread.title}</h1>
      <p>Por: {author.name}</p>
      <p>{thread.content}</p>
    </div>
  )
}

export default ThreadDetail
```

**Beneficios:**
- âœ… **Fetching paralelo**: Ambas consultas se ejecutan simultÃ¡neamente
- âœ… **Bundle mÃ¡s pequeÃ±o**: El cÃ³digo de base de datos nunca se envÃ­a al navegador
- âœ… **First paint rÃ¡pido**: Contenido listo antes de que la pÃ¡gina cargue
- âœ… **Seguro**: Las claves API permanecen en el servidor
- âœ… **Solicitud Ãºnica**: Todos los datos obtenidos del lado del servidor

**LÃ­nea de tiempo:**
```
t=0ms:    El servidor recibe la solicitud
t=50ms:   Fetch thread + autor (Â¡en paralelo!)
t=100ms:  Renderizar componente a HTML
t=150ms:  El navegador recibe HTML
t=150ms:  PÃ¡gina visible con contenido âœ…
Total: 150ms para ver contenido (Â¡4x mÃ¡s rÃ¡pido!)
```

---

## Conceptos Clave: Server vs Client Components

### Server Components

```tsx
// âœ… Server Component (por defecto en Next.js)
// Se ejecuta en el servidor, nunca se envÃ­a al navegador

import db from '@/lib/database'

async function ThreadList() {
  // âœ… Puede usar async/await
  const threads = await db.threads.findAll()
  
  // âœ… Puede acceder a la base de datos directamente
  // âœ… Puede usar secretos (claves API, contraseÃ±as de DB)
  // âœ… Puede usar librerÃ­as grandes (sin impacto en el bundle)
  
  return (
    <div>
      {threads.map(thread => (
        <ThreadCard key={thread.id} thread={thread} />
      ))}
    </div>
  )
}

export default ThreadList
```

### Client Components

```tsx
// âŒ Client Component (usar directiva "use client")
// Se ejecuta en el navegador, se envÃ­a al cliente

'use client'

import { useState } from 'react'

function ThreadCard({ thread }: { thread: Thread }) {
  // âœ… Puede usar useState, useEffect, etc.
  const [liked, setLiked] = useState(false)
  
  // âŒ No puede usar async/await en el cuerpo del componente
  // âŒ No puede acceder a la base de datos directamente
  // âŒ No puede usar secretos
  
  return (
    <div>
      <h2>{thread.title}</h2>
      <button onClick={() => setLiked(!liked)}>
        {liked ? 'â¤ï¸' : 'ğŸ¤'} Like
      </button>
    </div>
  )
}

export default ThreadCard
```

### ComposiciÃ³n: Server + Client

```tsx
// Server Component (padre)
import db from '@/lib/database'
import ThreadCard from './thread-card' // Client Component

async function ThreadList() {
  // Fetch en el servidor
  const threads = await db.threads.findAll()
  
  return (
    <div>
      {threads.map(thread => (
        // Pasar datos al Client Component
        <ThreadCard key={thread.id} thread={thread} />
      ))}
    </div>
  )
}

export default ThreadList
```

---

## Ejemplo del Mundo Real: PÃ¡gina de Detalles del Hilo del Foro

### Arquitectura

```
ThreadDetailPage (Server)
â”œâ”€ Fetch thread de la DB
â”œâ”€ Fetch autor de la DB
â”œâ”€ Fetch posts de la DB
â””â”€ Renderizar a HTML
    â””â”€ ThreadHeader (Server)
    â””â”€ ThreadContent (Server)
    â””â”€ PostList (Server)
        â””â”€ PostCard (Client)
            â”œâ”€ BotÃ³n de voto (interactivo)
            â””â”€ BotÃ³n de respuesta (interactivo)
```

### ImplementaciÃ³n

```tsx
// app/threads/[id]/page.tsx (Server Component)
import db from '@/lib/database'
import { Suspense } from 'react'
import ThreadHeader from './thread-header'
import ThreadContent from './thread-content'
import PostList from './post-list'

async function ThreadDetailPage({ params }: { params: { id: string } }) {
  // Obtener todos los datos en paralelo en el servidor
  const [thread, author, posts] = await Promise.all([
    db.threads.findById(params.id),
    db.authors.findById(params.authorId),
    db.posts.findByThreadId(params.id),
  ])

  return (
    <div className="max-w-4xl mx-auto">
      {/* Server Components: renderizados en el servidor */}
      <ThreadHeader thread={thread} author={author} />
      <ThreadContent thread={thread} />
      
      {/* Suspense para streaming */}
      <Suspense fallback={<div>Cargando posts...</div>}>
        <PostList posts={posts} threadId={params.id} />
      </Suspense>
    </div>
  )
}

export default ThreadDetailPage
```

```tsx
// app/threads/[id]/thread-header.tsx (Server Component)
import db from '@/lib/database'

async function ThreadHeader({ 
  thread, 
  author 
}: { 
  thread: Thread
  author: Author
}) {
  // Puede obtener datos adicionales si es necesario
  const viewCount = await db.threadStats.getViewCount(thread.id)

  return (
    <header className="border-b border-slate-700 pb-4">
      <h1 className="text-3xl font-bold">{thread.title}</h1>
      <div className="flex items-center gap-2 mt-2 text-slate-400">
        <img 
          src={author.avatarUrl} 
          alt={author.name}
          className="w-8 h-8 rounded-full"
        />
        <span>{author.name}</span>
        <span>â€¢</span>
        <span>{viewCount} vistas</span>
      </div>
    </header>
  )
}

export default ThreadHeader
```

```tsx
// app/threads/[id]/post-card.tsx (Client Component)
'use client'

import { useState } from 'react'
import { useTransition } from 'react'

function PostCard({ post }: { post: Post }) {
  const [liked, setLiked] = useState(false)
  const [isPending, startTransition] = useTransition()

  const handleLike = () => {
    startTransition(async () => {
      // Llamar a Server Action para actualizar like
      await updatePostLike(post.id, !liked)
      setLiked(!liked)
    })
  }

  return (
    <div className="border border-slate-700 rounded-lg p-4">
      <div className="flex items-center gap-2 mb-2">
        <img 
          src={post.author.avatarUrl}
          alt={post.author.name}
          className="w-8 h-8 rounded-full"
        />
        <span className="font-medium">{post.author.name}</span>
      </div>
      
      <p className="text-slate-300 mb-4">{post.content}</p>
      
      <button
        onClick={handleLike}
        disabled={isPending}
        className="flex items-center gap-1 text-slate-400 hover:text-red-400"
      >
        {liked ? 'â¤ï¸' : 'ğŸ¤'} {post.likeCount}
      </button>
    </div>
  )
}

export default PostCard
```

---

## Server Components vs Enfoques Tradicionales

### Tabla Comparativa

| Aspecto | SPA Tradicional | Server Components |
|---------|-----------------|-------------------|
| **Data fetching** | Lado del cliente (useEffect) | Lado del servidor (async) |
| **TamaÃ±o del bundle** | Grande (incluye cÃ³digo de DB) | PequeÃ±o (sin cÃ³digo de DB) |
| **First paint** | Lento (esperar JS + fetch) | RÃ¡pido (HTML listo) |
| **Cascada** | SÃ­ (fetch â†’ render â†’ fetch) | No (fetches paralelos) |
| **Seguridad** | Secretos expuestos | Secretos seguros en servidor |
| **Interactividad** | Inmediata | Streaming |
| **SEO** | Requiere SSR | Incorporado |

---

## Avanzado: Streaming con Suspense

### Renderizado Progresivo

```tsx
// Server Component con streaming
import { Suspense } from 'react'
import db from '@/lib/database'

async function ThreadPage({ threadId }: { threadId: string }) {
  // Datos crÃ­ticos: obtener inmediatamente
  const thread = await db.threads.findById(threadId)

  return (
    <div>
      {/* Renderizar contenido crÃ­tico inmediatamente */}
      <ThreadHeader thread={thread} />
      
      {/* Stream de contenido no crÃ­tico */}
      <Suspense fallback={<PostsSkeleton />}>
        <PostList threadId={threadId} />
      </Suspense>
      
      <Suspense fallback={<CommentsSkeleton />}>
        <CommentSection threadId={threadId} />
      </Suspense>
    </div>
  )
}

async function PostList({ threadId }: { threadId: string }) {
  // Esto obtiene despuÃ©s de que la pÃ¡gina comienza a hacer streaming
  const posts = await db.posts.findByThreadId(threadId)
  
  return (
    <div>
      {posts.map(post => (
        <PostCard key={post.id} post={post} />
      ))}
    </div>
  )
}

async function CommentSection({ threadId }: { threadId: string }) {
  // Esto obtiene en paralelo con PostList
  const comments = await db.comments.findByThreadId(threadId)
  
  return (
    <div>
      {comments.map(comment => (
        <Comment key={comment.id} comment={comment} />
      ))}
    </div>
  )
}

export default ThreadPage
```

**LÃ­nea de tiempo con Streaming:**
```
t=0ms:    El servidor recibe la solicitud
t=50ms:   Fetch thread
t=100ms:  Enviar HTML con thread (el navegador comienza a renderizar)
t=150ms:  Fetch posts + comentarios (en paralelo)
t=300ms:  Enviar HTML de posts
t=400ms:  Enviar HTML de comentarios
t=400ms:  PÃ¡gina completamente interactiva

Â¡El usuario ve contenido progresivamente! âœ…
```

---

## MigraciÃ³n: MÃ³dulo de CategorÃ­as a Server Components

### Antes: Fetching del Lado del Cliente

```tsx
// ANTIGUO: Client Component
'use client'

import { useState, useEffect } from 'react'

function CategoriesPage() {
  const [categories, setCategories] = useState([])
  const [loading, setLoading] = useState(true)

  useEffect(() => {
    fetch('/api/categories')
      .then(res => res.json())
      .then(data => {
        setCategories(data)
        setLoading(false)
      })
  }, [])

  if (loading) return <div>Cargando...</div>

  return (
    <div className="grid gap-4">
      {categories.map(cat => (
        <CategoryCard key={cat.id} category={cat} />
      ))}
    </div>
  )
}
```

### DespuÃ©s: Server Component

```tsx
// NUEVO: Server Component
import db from '@/lib/database'
import CategoryCard from './category-card'

async function CategoriesPage() {
  // Obtener directamente de la base de datos
  const categories = await db.categories.findAll()

  return (
    <div className="grid gap-4">
      {categories.map(cat => (
        <CategoryCard key={cat.id} category={cat} />
      ))}
    </div>
  )
}

export default CategoriesPage
```

**Beneficios:**
- âœ… No se necesita estado de carga (datos listos antes del render)
- âœ… No se necesita useEffect (cÃ³digo mÃ¡s simple)
- âœ… No se necesita endpoint API
- âœ… Acceso directo a la base de datos
- âœ… Bundle mÃ¡s pequeÃ±o (sin cÃ³digo de fetch)
- âœ… First paint mÃ¡s rÃ¡pido

---

## Mejores PrÃ¡cticas

### âœ… HACER

- âœ… Obtener datos en Server Components
- âœ… Usar async/await para fetching de datos
- âœ… Mantener secretos en el servidor
- âœ… Usar Server Components por defecto
- âœ… Usar Client Components solo para interactividad
- âœ… Stream de contenido no crÃ­tico con Suspense

### âŒ NO HACER

- âŒ Usar useState en Server Components
- âŒ Usar APIs del navegador en Server Components
- âŒ Obtener datos en Client Components (a menos que sea necesario)
- âŒ Enviar librerÃ­as grandes al cliente
- âŒ Exponer secretos en Client Components
- âŒ Hacer Server Components interactivos

---

## Impacto en el Rendimiento

### ReducciÃ³n del TamaÃ±o del Bundle

```
SPA Tradicional:
â”œâ”€ LibrerÃ­a React: 42KB
â”œâ”€ React Router: 15KB
â”œâ”€ CÃ³digo de fetching de datos: 20KB
â”œâ”€ Drivers de base de datos: 50KB
â””â”€ Total: 127KB

Server Components:
â”œâ”€ LibrerÃ­a React: 42KB
â”œâ”€ React Router: 15KB
â”œâ”€ CÃ³digo de fetching de datos: 0KB (lado del servidor)
â”œâ”€ Drivers de base de datos: 0KB (lado del servidor)
â””â”€ Total: 57KB

ReducciÃ³n: Â¡55% de bundle mÃ¡s pequeÃ±o! ğŸš€
```

### Tiempo hasta la Interactividad

```
SPA Tradicional:
1. Descargar JS (100ms)
2. Parsear JS (50ms)
3. Renderizar (100ms)
4. Obtener datos (200ms)
5. Renderizar con datos (100ms)
Total: 550ms

Server Components:
1. Obtener datos (100ms)
2. Renderizar a HTML (50ms)
3. Enviar HTML (50ms)
4. Navegador renderiza (50ms)
Total: 250ms

Â¡4.4x mÃ¡s rÃ¡pido! ğŸ¯
```

---

## Resumen: Server Components

### Conceptos Clave

1. **Server Components**: Se ejecutan en el servidor, renderizan a HTML
2. **Client Components**: Se ejecutan en el navegador, manejan interactividad
3. **Componentes Async**: Usan async/await en Server Components
4. **Streaming**: EnvÃ­an HTML progresivamente con Suspense
5. **ComposiciÃ³n**: Mezclan Server y Client Components

### CuÃ¡ndo Usar

- âœ… **Server Components**: Fetching de datos, acceso a base de datos, secretos
- âœ… **Client Components**: Interactividad, estado, APIs del navegador

### Beneficios

- âœ… Bundles mÃ¡s pequeÃ±os
- âœ… First paint mÃ¡s rÃ¡pido
- âœ… Sin cascadas
- âœ… Seguro (secretos en servidor)
- âœ… Mejor SEO
- âœ… CÃ³digo mÃ¡s simple

---

Siguiente: [Deployment â†’](/es/react/9.advanced-topics/4.deployment)
