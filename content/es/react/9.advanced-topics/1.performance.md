---
title: Optimización de Rendimiento - Profiling, Memoización y Code Splitting
description: Domina la optimización de rendimiento: mide antes de optimizar, React.memo, useMemo, useCallback, code splitting, lazy loading y Web Vitals. Construye foros rápidos.
---

# Advertencia

:::u-alert
---
title: Los comentarios en el código son solo para fines educativos.
description: En proyectos reales, evita agregar comentarios irrelevantes o redundantes.
color: warning
variant: subtle
icon: i-lucide-triangle-alert
---
:::

El rendimiento importa. Un foro lento pierde usuarios. Pero la optimización prematura es la raíz de todos los males. **Mide primero, optimiza después.**

---

## La Mentalidad de Rendimiento

**La regla de oro**: No optimices sin datos.

```
1. Medir (Chrome DevTools)
2. Identificar cuello de botella
3. Optimizar
4. Medir de nuevo
5. Verificar mejora
```

**Errores comunes:**
- ❌ Optimizar código que no es lento
- ❌ Usar React.memo en todas partes
- ❌ Memorizar cálculos baratos
- ❌ Ignorar el rendimiento de red

---

## React.memo: Prevenir Re-renders Innecesarios

**Problema**: El padre se re-renderiza, todos los hijos se re-renderizan (incluso si los props no cambiaron).

**Solución**: React.memo omite el re-render si los props son iguales.

```tsx
/**
 * React.memo: Comparación superficial de props
 * 
 * Sin memo:
 * Padre renderiza → Todos los hijos renderizan (incluso si los props son iguales)
 * 
 * Con memo:
 * Padre renderiza → Los hijos solo renderizan si los props cambiaron
 */
const ThreadCard = memo(function ThreadCard({ thread }: { thread: Thread }) {
  console.log('ThreadCard renderizado')
  return <div>{thread.title}</div>
})

// Uso
function ThreadList({ threads }) {
  return (
    <div>
      {threads.map(thread => (
        <ThreadCard key={thread.id} thread={thread} />
      ))}
    </div>
  )
}

// Escenario:
// 1. Padre se re-renderiza (cambio de estado no relacionado)
// 2. Props de ThreadCard no cambiaron
// 3. ThreadCard omite el re-render ✅
```

**Cuándo usar:**
- ✅ El componente se renderiza a menudo
- ✅ Los props raramente cambian
- ✅ El componente es costoso de renderizar

**Cuándo NO usar:**
- ❌ El componente se renderiza raramente
- ❌ Los props siempre cambian
- ❌ El componente es barato de renderizar

---

## useMemo: Cachear Cálculos Costosos

**Problema**: Cálculo costoso se ejecuta en cada render.

**Solución**: useMemo cachea el resultado, solo recalcula cuando las dependencias cambian.

```tsx
/**
 * useMemo: Cachear cálculos costosos
 * 
 * Sin useMemo:
 * Cada render → Ordenar hilos (¡costoso!)
 * 
 * Con useMemo:
 * Solo cuando cambian los hilos → Ordenar hilos
 * Otros renders → Usar resultado cacheado
 */
function ThreadList({ threads, sortBy }) {
  // ❌ MAL: Ordena en cada render
  // const sorted = threads.sort((a, b) => b.score - a.score)
  
  // ✅ BIEN: Solo ordena cuando cambian los hilos
  const sorted = useMemo(() => {
    console.log('Ordenando hilos...')
    return threads.sort((a, b) => {
      if (sortBy === 'score') return b.score - a.score
      if (sortBy === 'date') return new Date(b.createdAt).getTime() - new Date(a.createdAt).getTime()
      return 0
    })
  }, [threads, sortBy])  // Dependencias
  
  return (
    <div>
      {sorted.map(thread => (
        <ThreadCard key={thread.id} thread={thread} />
      ))}
    </div>
  )
}
```

**Cuándo usar:**
- ✅ Cálculo costoso (ordenar, filtrar, mapear arrays grandes)
- ✅ El cálculo se ejecuta frecuentemente
- ✅ Las dependencias raramente cambian

**Cuándo NO usar:**
- ❌ Cálculo barato (matemáticas simples, concatenación de strings)
- ❌ El cálculo se ejecuta raramente
- ❌ Las dependencias siempre cambian

---

## useCallback: Memorizar Funciones

**Problema**: Nueva función creada en cada render, el hijo se re-renderiza innecesariamente.

**Solución**: useCallback devuelve la misma referencia de función.

```tsx
/**
 * useCallback: Memorizar funciones
 * 
 * Sin useCallback:
 * Cada render → Nueva función handleClick
 * Hijo ve nuevo prop → Se re-renderiza
 * 
 * Con useCallback:
 * Misma función handleClick (a menos que cambien las dependencias)
 * Hijo ve mismo prop → Omite re-render
 */
function ThreadList({ threads }) {
  // ❌ MAL: Nueva función en cada render
  // const handleClick = (id: string) => {
  //   console.log('Clicked', id)
  // }
  
  // ✅ BIEN: Misma referencia de función
  const handleClick = useCallback((id: string) => {
    console.log('Clicked', id)
  }, [])  // Sin dependencias = misma función siempre
  
  return (
    <div>
      {threads.map(thread => (
        <ThreadCard 
          key={thread.id} 
          thread={thread}
          onClick={handleClick}  // Referencia estable
        />
      ))}
    </div>
  )
}

// ThreadCard con memo
const ThreadCard = memo(function ThreadCard({ thread, onClick }) {
  return (
    <button onClick={() => onClick(thread.id)}>
      {thread.title}
    </button>
  )
})
```

**Cuándo usar:**
- ✅ Pasar callback a hijo memorizado
- ✅ Callback usado en array de dependencias
- ✅ Callback es costoso de crear

**Cuándo NO usar:**
- ❌ No pasar a hijo memorizado
- ❌ Callback barato de crear
- ❌ Las dependencias siempre cambian

---

## Code Splitting & Lazy Loading

**Problema**: Bundle demasiado grande, carga inicial lenta.

**Solución**: Dividir código, cargar solo cuando se necesita.

```tsx
import { lazy, Suspense } from 'react'

// Cargar AdminPanel solo cuando se necesite
const AdminPanel = lazy(() => import('./AdminPanel'))

function App() {
  const [showAdmin, setShowAdmin] = useState(false)
  
  return (
    <div>
      <button onClick={() => setShowAdmin(!showAdmin)}>
        Toggle Admin
      </button>
      
      {showAdmin && (
        <Suspense fallback={<div>Cargando admin...</div>}>
          <AdminPanel />
        </Suspense>
      )}
    </div>
  )
}
```

**Beneficios:**
- ✅ Bundle inicial más pequeño
- ✅ Primera carga de página más rápida
- ✅ Cargar código bajo demanda

---

## <Profiler>: Medir Rendimiento de Renderizado de Componentes

**Problema**: No sabes qué componentes son lentos. Chrome DevTools muestra rendimiento general, pero no por componente.

**Solución**: `<Profiler>` mide el tiempo de renderizado de árboles de componentes específicos.

### ¿Qué es <Profiler>?

`<Profiler>` es un componente React incorporado que mide cuánto tiempo tarda un árbol de componentes en renderizarse y comprometerse.

**Métricas clave:**
- **Render time**: Cuánto tiempo tardó el componente en renderizar
- **Commit time**: Cuánto tiempo tardó React en aplicar cambios al DOM
- **Phase**: "mount" (primer render) o "update" (re-render)

### Cómo Funciona

```tsx
import { Profiler } from 'react'

function onRenderCallback(
  id,           // Identificador del componente
  phase,        // "mount" o "update"
  actualDuration,    // Tiempo gastado en renderizar
  baseDuration,      // Tiempo estimado sin memoización
  startTime,    // Cuándo React comenzó a renderizar
  commitTime,   // Cuándo React comprometió los cambios
  interactions  // Conjunto de interacciones
) {
  console.log(`${id} (${phase}) tomó ${actualDuration}ms`)
}

function ThreadList() {
  return (
    <Profiler id="ThreadList" onRender={onRenderCallback}>
      <div>
        {threads.map(thread => (
          <ThreadCard key={thread.id} thread={thread} />
        ))}
      </div>
    </Profiler>
  )
}
```

### Ejemplo Real: Profileando Componentes del Foro

```tsx
import { Profiler } from 'react'

/**
 * Registrar métricas de rendimiento en consola
 */
function logPerformance(id, phase, actualDuration, baseDuration) {
  console.log(`
    Componente: ${id}
    Fase: ${phase}
    Actual: ${actualDuration.toFixed(2)}ms
    Estimado: ${baseDuration.toFixed(2)}ms
    Ahorro: ${(baseDuration - actualDuration).toFixed(2)}ms
  `)
}

/**
 * Enviar métricas a servicio de analítica
 */
async function sendToAnalytics(id, phase, actualDuration) {
  if (actualDuration > 100) {  // Solo registrar renders lentos
    await fetch('/api/performance', {
      method: 'POST',
      body: JSON.stringify({
        component: id,
        phase,
        duration: actualDuration,
        timestamp: new Date().toISOString(),
      })
    })
  }
}

export function ThreadsPage() {
  const [threads, setThreads] = useState<Thread[]>([])
  const [sortBy, setSortBy] = useState('newest')

  return (
    <div>
      {/* Profilear el dropdown de ordenamiento */}
      <Profiler id="SortControls" onRender={logPerformance}>
        <select value={sortBy} onChange={(e) => setSortBy(e.target.value)}>
          <option value="newest">Más Recientes</option>
          <option value="popular">Populares</option>
          <option value="oldest">Más Antiguos</option>
        </select>
      </Profiler>

      {/* Profilear la lista de hilos */}
      <Profiler id="ThreadList" onRender={sendToAnalytics}>
        <div className="space-y-4">
          {threads.map(thread => (
            <ThreadCard key={thread.id} thread={thread} />
          ))}
        </div>
      </Profiler>
    </div>
  )
}
```

### Profilers Anidados: Profilear Múltiples Componentes

```tsx
function App() {
  return (
    <Profiler id="App" onRender={logPerformance}>
      <Navbar />
      
      <Profiler id="Sidebar" onRender={logPerformance}>
        <Sidebar />
      </Profiler>
      
      <Profiler id="MainContent" onRender={logPerformance}>
        <MainContent />
      </Profiler>
    </Profiler>
  )
}

// Salida:
// App (mount) tomó 45.2ms
// Sidebar (mount) tomó 12.1ms
// MainContent (mount) tomó 28.5ms
```

### Profiler + React DevTools

React DevTools tiene una pestaña Profiler incorporada que visualiza datos de rendimiento:

1. Abrir React DevTools
2. Ir a la pestaña "Profiler"
3. Hacer clic en "Record"
4. Interactuar con tu app
5. Hacer clic en "Stop"
6. Ver desglose detallado de rendimiento

**Beneficios:**
- ✅ Representación visual de tiempos de render
- ✅ Identificar componentes lentos
- ✅ Ver qué props cambiaron
- ✅ Flamegraph muestra jerarquía de componentes

### Comparación de Rendimiento: Antes y Después

```tsx
// ANTES: Sin optimización
// ThreadList (update) tomó 450ms ❌ (renderiza todos los 1000 hilos)

// DESPUÉS: Con React.memo + useMemo
// ThreadList (update) tomó 12ms ✅ (solo re-renderiza hilos cambiados)

// Mejora: ¡37x más rápido!
```

### Cuándo Usar <Profiler>

- ✅ Identificar componentes lentos
- ✅ Verificar que las optimizaciones funcionan
- ✅ Monitorear rendimiento en producción
- ✅ Debug re-renders inesperados
- ✅ Rastrear rendimiento a lo largo del tiempo

### Flujo de Trabajo de Profileo de Rendimiento

```
1. Identificar característica lenta
   ↓
2. Envolver con <Profiler>
   ↓
3. Medir rendimiento base
   ↓
4. Aplicar optimización (React.memo, useMemo, etc.)
   ↓
5. Medir de nuevo con <Profiler>
   ↓
6. Verificar mejora
   ↓
7. Desplegar con confianza
```

### Puntos Clave

✅ **Mide antes de optimizar** - Usa Profiler para encontrar cuellos de botella
✅ **Profilea en producción** - Envía métricas a analítica
✅ **Profilers anidados** - Profilea múltiples niveles
✅ **Integración con React DevTools** - Análisis visual de rendimiento
✅ **Decisiones basadas en datos** - Optimiza lo que realmente es lento

---

## Web Vitals: Medir Rendimiento Real

```typescript
// Medir Core Web Vitals
import { getCLS, getFID, getFCP, getLCP, getTTFB } from 'web-vitals'

getCLS(console.log)  // Cumulative Layout Shift
getFID(console.log)  // First Input Delay
getFCP(console.log)  // First Contentful Paint
getLCP(console.log)  // Largest Contentful Paint
getTTFB(console.log) // Time to First Byte

// Objetivos buenos:
// LCP: < 2.5s
// FID: < 100ms
// CLS: < 0.1
```

---

## Checklist de Rendimiento

- ✅ Medir con Chrome DevTools
- ✅ Usar React.memo para componentes costosos
- ✅ Usar useMemo para cálculos costosos
- ✅ Usar useCallback para callbacks a hijos memorizados
- ✅ Implementar code splitting para características grandes
- ✅ Lazy load de imágenes (loading="lazy")
- ✅ Minimizar tamaño de bundle (tree-shaking, minificación)
- ✅ Monitorear Web Vitals
- ❌ No optimizar prematuramente
- ❌ No memorizar todo
- ❌ No ignorar el rendimiento de red

---

Siguiente: [Actualizaciones en Tiempo Real →](/es/react/9.advanced-topics/2.realtime)
