---
title: Actualizaciones en Tiempo Real - WebSockets, SSE y Funciones Live
description: Domina la comunicación en tiempo real en React. Construye notificaciones live, indicadores de escritura y actualizaciones instantáneas con WebSockets, Server-Sent Events y patrones listos para producción.
---

# Advertencia

:::u-alert
---
title: Los comentarios en el código son solo para fines educativos.
description: En proyectos reales, evita agregar comentarios irrelevantes o redundantes.
color: warning
variant: subtle
icon: i-lucide-triangle-alert
---
:::

Las actualizaciones en tiempo real transforman los foros de páginas estáticas a comunidades vivas. Los nuevos posts aparecen instantáneamente, los usuarios ven quién está escribiendo, las notificaciones llegan sin recargar. Esta es la diferencia entre un foro que se siente vivo y uno que se siente anticuado.

---

## El Problema: El Polling es Ineficiente

### Enfoque Tradicional de Polling

```tsx
// ❌ MAL: Polling cada 5 segundos
function ThreadPage() {
  const [posts, setPosts] = useState([])

  useEffect(() => {
    const interval = setInterval(() => {
      fetch('/api/posts')
        .then(res => res.json())
        .then(data => setPosts(data))
    }, 5000) // Poll cada 5 segundos

    return () => clearInterval(interval)
  }, [])

  return <div>{/* ... */}</div>
}
```

**Problemas:**
- ❌ **Desperdiciado**: 99% de las solicitudes no devuelven datos nuevos
- ❌ **Retrasado**: Hasta 5 segundos de retraso para contenido nuevo
- ❌ **Carga del servidor**: Solicitudes innecesarias constantes
- ❌ **Drenaje de batería**: Los dispositivos móviles sufren
- ❌ **Ancho de banda**: Desperdiciado en respuestas vacías

**Línea de tiempo:**
```
t=0s:     Poll (sin datos nuevos)
t=5s:     Poll (sin datos nuevos)
t=7s:     Nuevo post creado (¡el usuario aún no lo ve!)
t=10s:    Poll (ve el post nuevo, 3 segundos de retraso)
t=15s:    Poll (sin datos nuevos)
...
```

---

## Comparación de Tecnologías en Tiempo Real

### 1. WebSockets: Comunicación Bidireccional

**Cómo funciona:**
- Conexión full-duplex (cliente ↔ servidor)
- Conexión persistente
- Ambos lados pueden enviar mensajes en cualquier momento

**Pros:**
- ✅ Latencia más baja (instantáneo)
- ✅ Bidireccional (el cliente puede enviar al servidor)
- ✅ Eficiente (sin sobrecarga HTTP por mensaje)

**Contras:**
- ❌ Más complejo de implementar
- ❌ Requiere servidor WebSocket
- ❌ Más difícil de escalar (conexiones con estado)

**Casos de uso:**
- Aplicaciones de chat
- Edición colaborativa
- Gaming
- Dashboards en vivo

### 2. Server-Sent Events (SSE): Servidor → Cliente

**Cómo funciona:**
- Conexión HTTP mantenida abierta
- Servidor envía eventos al cliente
- Cliente no puede enviar (usar HTTP regular para eso)

**Pros:**
- ✅ Simple de implementar
- ✅ Reconexión incorporada
- ✅ Funciona sobre HTTP (sin servidor especial)
- ✅ Seguimiento automático de ID de eventos

**Contras:**
- ❌ Solo unidireccional (servidor → cliente)
- ❌ Soporte limitado del navegador (sin IE)
- ❌ Límite de conexión HTTP/1.1 (6 por dominio)

**Casos de uso:**
- Notificaciones
- Feeds en vivo
- Tickers de acciones
- Logs del servidor

### 3. Long Polling: Falso Tiempo Real

**Cómo funciona:**
- Cliente hace solicitud
- Servidor mantiene la solicitud hasta que haya datos disponibles
- Servidor responde, cliente solicita inmediatamente de nuevo

**Pros:**
- ✅ Funciona en todas partes (solo HTTP)
- ✅ No se necesita servidor especial

**Contras:**
- ❌ Mayor latencia que WebSockets/SSE
- ❌ Más recursos del servidor
- ❌ Todavía sobrecarga HTTP

**Casos de uso:**
- Soporte de navegadores heredados
- Mecanismo de fallback

### Tabla Comparativa

| Característica | WebSockets | SSE | Long Polling |
|----------------|------------|-----|--------------|
| **Latencia** | ~10ms | ~50ms | ~200ms |
| **Dirección** | Bidireccional | Servidor → Cliente | Bidireccional |
| **Protocolo** | ws:// | HTTP | HTTP |
| **Reconexión** | Manual | Automática | Manual |
| **Soporte del navegador** | Moderno | Moderno (sin IE) | Todos |
| **Complejidad** | Alta | Baja | Media |
| **Escalabilidad** | Difícil | Media | Media |

---

## Hook de WebSocket Listo para Producción

### Hook Básico con Reconexión

```tsx
// src/hooks/useWebSocket.ts

import { useEffect, useState, useRef, useCallback } from 'react'

interface UseWebSocketOptions {
  onOpen?: () => void
  onClose?: () => void
  onError?: (error: Event) => void
  onMessage?: (data: any) => void
  reconnectInterval?: number
  maxReconnectAttempts?: number
}

export function useWebSocket(url: string, options: UseWebSocketOptions = {}) {
  const {
    onOpen,
    onClose,
    onError,
    onMessage,
    reconnectInterval = 3000,
    maxReconnectAttempts = 5,
  } = options

  const [socket, setSocket] = useState<WebSocket | null>(null)
  const [lastMessage, setLastMessage] = useState<any>(null)
  const [connectionStatus, setConnectionStatus] = useState<
    'connecting' | 'connected' | 'disconnected' | 'error'
  >('connecting')
  
  const reconnectAttemptsRef = useRef(0)
  const reconnectTimeoutRef = useRef<NodeJS.Timeout>()
  const socketRef = useRef<WebSocket | null>(null)

  /**
   * Conectar al servidor WebSocket
   */
  const connect = useCallback(() => {
    try {
      setConnectionStatus('connecting')
      
      const ws = new WebSocket(url)
      socketRef.current = ws

      /**
       * Conexión abierta
       */
      ws.onopen = () => {
        console.log('WebSocket conectado')
        setConnectionStatus('connected')
        setSocket(ws)
        reconnectAttemptsRef.current = 0 // Reiniciar intentos al tener éxito
        onOpen?.()
      }

      /**
       * Mensaje recibido
       */
      ws.onmessage = (event) => {
        try {
          const data = JSON.parse(event.data)
          setLastMessage(data)
          onMessage?.(data)
        } catch (error) {
          console.error('Error al parsear mensaje WebSocket:', error)
        }
      }

      /**
       * Conexión cerrada
       */
      ws.onclose = () => {
        console.log('WebSocket desconectado')
        setConnectionStatus('disconnected')
        setSocket(null)
        onClose?.()

        // Intentar reconexión
        if (reconnectAttemptsRef.current < maxReconnectAttempts) {
          reconnectAttemptsRef.current++
          console.log(
            `Reconectando... (intento ${reconnectAttemptsRef.current}/${maxReconnectAttempts})`
          )
          
          reconnectTimeoutRef.current = setTimeout(() => {
            connect()
          }, reconnectInterval * reconnectAttemptsRef.current) // Backoff exponencial
        }
      }

      /**
       * Error ocurrido
       */
      ws.onerror = (error) => {
        console.error('Error WebSocket:', error)
        setConnectionStatus('error')
        onError?.(error)
      }
    } catch (error) {
      console.error('Error al crear WebSocket:', error)
      setConnectionStatus('error')
    }
  }, [url, onOpen, onClose, onError, onMessage, reconnectInterval, maxReconnectAttempts])

  /**
   * Enviar mensaje al servidor
   */
  const sendMessage = useCallback((data: any) => {
    if (socketRef.current?.readyState === WebSocket.OPEN) {
      socketRef.current.send(JSON.stringify(data))
    } else {
      console.warn('WebSocket no está conectado')
    }
  }, [])

  /**
   * Desconectar manualmente
   */
  const disconnect = useCallback(() => {
    if (reconnectTimeoutRef.current) {
      clearTimeout(reconnectTimeoutRef.current)
    }
    if (socketRef.current) {
      socketRef.current.close()
      socketRef.current = null
    }
  }, [])

  /**
   * Conectar al montar, limpiar al desmontar
   */
  useEffect(() => {
    connect()

    return () => {
      disconnect()
    }
  }, [connect, disconnect])

  return {
    socket,
    lastMessage,
    connectionStatus,
    sendMessage,
    disconnect,
    reconnect: connect,
  }
}
```

### Hook Avanzado con Heartbeat

```tsx
// src/hooks/useWebSocketWithHeartbeat.ts

import { useEffect, useRef } from 'react'
import { useWebSocket } from './useWebSocket'

interface UseWebSocketWithHeartbeatOptions {
  heartbeatInterval?: number
  heartbeatTimeout?: number
}

export function useWebSocketWithHeartbeat(
  url: string,
  options: UseWebSocketWithHeartbeatOptions = {}
) {
  const { heartbeatInterval = 30000, heartbeatTimeout = 5000 } = options

  const heartbeatIntervalRef = useRef<NodeJS.Timeout>()
  const heartbeatTimeoutRef = useRef<NodeJS.Timeout>()

  const { socket, connectionStatus, sendMessage, ...rest } = useWebSocket(url, {
    onOpen: () => {
      // Iniciar heartbeat cuando está conectado
      startHeartbeat()
    },
    onClose: () => {
      // Detener heartbeat cuando está desconectado
      stopHeartbeat()
    },
    onMessage: (data) => {
      // Reiniciar timeout de heartbeat en cualquier mensaje
      if (data.type === 'pong') {
        resetHeartbeatTimeout()
      }
    },
  })

  /**
   * Iniciar envío de pings de heartbeat
   */
  const startHeartbeat = () => {
    heartbeatIntervalRef.current = setInterval(() => {
      sendMessage({ type: 'ping' })

      // Establecer timeout para detectar conexión muerta
      heartbeatTimeoutRef.current = setTimeout(() => {
        console.warn('Timeout de heartbeat - la conexión puede estar muerta')
        socket?.close() // Forzar reconexión
      }, heartbeatTimeout)
    }, heartbeatInterval)
  }

  /**
   * Detener heartbeat
   */
  const stopHeartbeat = () => {
    if (heartbeatIntervalRef.current) {
      clearInterval(heartbeatIntervalRef.current)
    }
    if (heartbeatTimeoutRef.current) {
      clearTimeout(heartbeatTimeoutRef.current)
    }
  }

  /**
   * Reiniciar timeout de heartbeat (recibió pong)
   */
  const resetHeartbeatTimeout = () => {
    if (heartbeatTimeoutRef.current) {
      clearTimeout(heartbeatTimeoutRef.current)
    }
  }

  useEffect(() => {
    return () => {
      stopHeartbeat()
    }
  }, [])

  return {
    socket,
    connectionStatus,
    sendMessage,
    ...rest,
  }
}
```

---

## Ejemplos del Mundo Real

### 1. Notificaciones en Vivo

```tsx
// src/components/notifications/LiveNotifications.tsx

import { useWebSocket } from '@/hooks/useWebSocket'
import { useState, useEffect } from 'react'
import { toast } from 'sonner'

interface Notification {
  id: string
  type: 'new_post' | 'new_reply' | 'mention' | 'like'
  title: string
  message: string
  threadId?: string
  postId?: string
  createdAt: string
}

export function LiveNotifications() {
  const [notifications, setNotifications] = useState<Notification[]>([])
  const { lastMessage, connectionStatus } = useWebSocket('ws://localhost:3001/notifications', {
    onMessage: (data) => {
      if (data.type === 'notification') {
        const notification = data.payload as Notification
        
        // Agregar a la lista
        setNotifications(prev => [notification, ...prev])
        
        // Mostrar toast
        toast(notification.title, {
          description: notification.message,
          action: notification.threadId ? {
            label: 'Ver',
            onClick: () => {
              window.location.href = `/threads/${notification.threadId}`
            },
          } : undefined,
        })
      }
    },
  })

  return (
    <div className="relative">
      {/* Indicador de estado de conexión */}
      <div className="flex items-center gap-2">
        <div
          className={`w-2 h-2 rounded-full ${
            connectionStatus === 'connected'
              ? 'bg-green-500'
              : connectionStatus === 'connecting'
              ? 'bg-yellow-500 animate-pulse'
              : 'bg-red-500'
          }`}
        />
        <span className="text-sm text-slate-400">
          {connectionStatus === 'connected' && 'En vivo'}
          {connectionStatus === 'connecting' && 'Conectando...'}
          {connectionStatus === 'disconnected' && 'Desconectado'}
        </span>
      </div>

      {/* Lista de notificaciones */}
      <div className="mt-4 space-y-2">
        {notifications.map(notification => (
          <div
            key={notification.id}
            className="p-3 bg-slate-900 border border-slate-700 rounded-lg"
          >
            <h4 className="font-medium text-slate-100">{notification.title}</h4>
            <p className="text-sm text-slate-400 mt-1">{notification.message}</p>
          </div>
        ))}
      </div>
    </div>
  )
}
```

### 2. Indicadores de Escritura

```tsx
// src/components/thread/TypingIndicators.tsx

import { useWebSocket } from '@/hooks/useWebSocket'
import { useState, useEffect, useRef } from 'react'

interface TypingUser {
  userId: string
  username: string
  lastTyped: number
}

export function TypingIndicators({ threadId }: { threadId: string }) {
  const [typingUsers, setTypingUsers] = useState<TypingUser[]>([])
  const typingTimeoutRef = useRef<Map<string, NodeJS.Timeout>>(new Map())

  const { sendMessage } = useWebSocket('ws://localhost:3001/threads', {
    onMessage: (data) => {
      if (data.type === 'user_typing' && data.threadId === threadId) {
        const { userId, username } = data

        // Agregar o actualizar usuario escribiendo
        setTypingUsers(prev => {
          const existing = prev.find(u => u.userId === userId)
          if (existing) {
            return prev.map(u =>
              u.userId === userId ? { ...u, lastTyped: Date.now() } : u
            )
          }
          return [...prev, { userId, username, lastTyped: Date.now() }]
        })

        // Limpiar timeout existente
        const existingTimeout = typingTimeoutRef.current.get(userId)
        if (existingTimeout) {
          clearTimeout(existingTimeout)
        }

        // Establecer timeout para eliminar usuario después de 3 segundos
        const timeout = setTimeout(() => {
          setTypingUsers(prev => prev.filter(u => u.userId !== userId))
          typingTimeoutRef.current.delete(userId)
        }, 3000)

        typingTimeoutRef.current.set(userId, timeout)
      }
    },
  })

  /**
   * Notificar al servidor cuando el usuario está escribiendo
   */
  const handleTyping = () => {
    sendMessage({
      type: 'user_typing',
      threadId,
    })
  }

  if (typingUsers.length === 0) return null

  return (
    <div className="flex items-center gap-2 text-sm text-slate-400 py-2">
      <div className="flex -space-x-2">
        {typingUsers.slice(0, 3).map(user => (
          <div
            key={user.userId}
            className="w-6 h-6 rounded-full bg-blue-500 border-2 border-slate-900 flex items-center justify-center text-xs text-white"
          >
            {user.username[0].toUpperCase()}
          </div>
        ))}
      </div>
      <span>
        {typingUsers.length === 1 && `${typingUsers[0].username} está escribiendo...`}
        {typingUsers.length === 2 &&
          `${typingUsers[0].username} y ${typingUsers[1].username} están escribiendo...`}
        {typingUsers.length > 2 &&
          `${typingUsers[0].username} y ${typingUsers.length - 1} otros están escribiendo...`}
      </span>
      <div className="flex gap-1">
        <div className="w-2 h-2 bg-slate-400 rounded-full animate-bounce" style={{ animationDelay: '0ms' }} />
        <div className="w-2 h-2 bg-slate-400 rounded-full animate-bounce" style={{ animationDelay: '150ms' }} />
        <div className="w-2 h-2 bg-slate-400 rounded-full animate-bounce" style={{ animationDelay: '300ms' }} />
      </div>
    </div>
  )
}
```

### 3. Actualizaciones de Posts en Vivo

```tsx
// src/pages/ThreadDetailPage.tsx

import { useWebSocket } from '@/hooks/useWebSocket'
import { useState, useEffect } from 'react'
import { useParams } from 'react-router-dom'
import { PostCard } from '@/components/posts/PostCard'

export function ThreadDetailPage() {
  const { threadId } = useParams()
  const [posts, setPosts] = useState<Post[]>([])

  const { lastMessage, connectionStatus } = useWebSocket('ws://localhost:3001/threads', {
    onOpen: () => {
      // Suscribirse a actualizaciones del hilo
      sendMessage({
        type: 'subscribe',
        threadId,
      })
    },
    onMessage: (data) => {
      if (data.threadId !== threadId) return

      switch (data.type) {
        case 'new_post':
          // Agregar nuevo post a la lista
          setPosts(prev => [...prev, data.post])
          break

        case 'post_updated':
          // Actualizar post existente
          setPosts(prev =>
            prev.map(p => (p.id === data.post.id ? data.post : p))
          )
          break

        case 'post_deleted':
          // Eliminar post eliminado
          setPosts(prev => prev.filter(p => p.id !== data.postId))
          break

        case 'post_liked':
          // Actualizar conteo de likes
          setPosts(prev =>
            prev.map(p =>
              p.id === data.postId
                ? { ...p, likeCount: p.likeCount + 1 }
                : p
            )
          )
          break
      }
    },
  })

  return (
    <div>
      {/* Indicador de conexión */}
      {connectionStatus !== 'connected' && (
        <div className="bg-yellow-900/20 border border-yellow-700 rounded-lg p-3 mb-4">
          <p className="text-yellow-400 text-sm">
            {connectionStatus === 'connecting' && 'Conectando a actualizaciones en vivo...'}
            {connectionStatus === 'disconnected' && 'Desconectado. Reconectando...'}
            {connectionStatus === 'error' && 'Error de conexión. Reintentando...'}
          </p>
        </div>
      )}

      {/* Posts */}
      <div className="space-y-4">
        {posts.map(post => (
          <PostCard key={post.id} post={post} />
        ))}
      </div>
    </div>
  )
}
```

---

## Escalabilidad: Redis Pub/Sub

Para producción, usa Redis Pub/Sub para escalar servidores WebSocket:

```typescript
// server/websocket-server.ts

import { createServer } from 'http'
import { WebSocketServer } from 'ws'
import { createClient } from 'redis'

const server = createServer()
const wss = new WebSocketServer({ server })

// Clientes Redis
const publisher = createClient()
const subscriber = createClient()

await publisher.connect()
await subscriber.connect()

// Suscribirse a canales
await subscriber.subscribe('notifications', (message) => {
  const data = JSON.parse(message)
  
  // Broadcast a todos los clientes conectados
  wss.clients.forEach(client => {
    if (client.readyState === WebSocket.OPEN) {
      client.send(JSON.stringify(data))
    }
  })
})

// Manejar conexiones WebSocket
wss.on('connection', (ws) => {
  console.log('Cliente conectado')

  ws.on('message', async (message) => {
    const data = JSON.parse(message.toString())
    
    // Publicar en Redis (otros servidores lo recibirán)
    await publisher.publish('notifications', JSON.stringify(data))
  })

  ws.on('close', () => {
    console.log('Cliente desconectado')
  })
})

server.listen(3001)
```

---

## Mejores Prácticas

### ✅ HACER

- ✅ Implementar reconexión con backoff exponencial
- ✅ Usar heartbeat/ping-pong para detectar conexiones muertas
- ✅ Manejar estado de conexión en la UI
- ✅ Validar y sanitizar mensajes
- ✅ Usar colas de mensajes para confiabilidad
- ✅ Implementar autenticación (enviar token al conectar)
- ✅ Usar Redis Pub/Sub para escalado horizontal

### ❌ NO HACER

- ❌ Enviar datos sensibles sin cifrado
- ❌ Olvidar limpiar conexiones
- ❌ Ignorar lógica de reconexión
- ❌ Enviar payloads grandes (usar referencias en su lugar)
- ❌ Olvidar manejar escenarios offline
- ❌ Saltar manejo de errores

---

## Resumen

### Conceptos Clave

1. **WebSockets**: Bidireccional, baja latencia, conexiones persistentes
2. **SSE**: Servidor → Cliente, reconexión automática, más simple
3. **Reconexión**: Backoff exponencial, intentos máximos
4. **Heartbeat**: Detectar conexiones muertas, keep-alive
5. **Escalabilidad**: Redis Pub/Sub para múltiples servidores

### Características en Tiempo Real

- ✅ Notificaciones en vivo
- ✅ Indicadores de escritura
- ✅ Actualizaciones instantáneas de posts
- ✅ Presencia online
- ✅ Confirmaciones de lectura

---

Siguiente: [Testing →](/es/react/9.advanced-topics/3.testing)
