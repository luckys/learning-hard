---
title: Eliminar Categoría - Operaciones Destructivas y Portales
description: Domina los Portales de React para modales, diálogos de confirmación, advertencias en cascada, accesibilidad de teclado y patrones de eliminación seguros. Aprende a manejar operaciones destructivas responsablemente con capacidades de rollback.
---

# Disclaimer

:::u-alert
---
title: Los comentarios en el código son solo educativos.
description: En proyectos reales, evita comentarios irrelevantes o redundantes.
color: warning
variant: subtle
icon: i-lucide-triangle-alert
---
:::

Eliminar es la operación más **peligrosa** en cualquier aplicación. A diferencia de las ediciones (que pueden revertirse), la eliminación es permanente. Necesitamos múltiples capas de seguridad: diálogos de confirmación, advertencias en cascada, verificaciones de autorización y capacidades de rollback.

**Por qué la eliminación es especial:**
- ❌ **Irreversible**: Sin botón de deshacer
- ❌ **Efectos en cascada**: Puede eliminar datos relacionados
- ❌ **Propenso a errores de usuario**: Fácil hacer clic en el botón equivocado
- ❌ **Crítico para la seguridad**: Debe verificar permisos

**Nuestras capas de seguridad:**
1. **Autorización**: Solo los administradores pueden eliminar
2. **Modal de confirmación**: Verificación doble de la intención del usuario
3. **Advertencia en cascada**: Mostrar qué más se eliminará
4. **Estado de carga**: Prevenir dobles clics
5. **Manejo de errores**: Mensajes claros y rollback
6. **UI optimista**: Retroalimentación instantánea con rollback en caso de fallo

---

## El Desafío: Modales y el Árbol DOM

Antes de construir la funcionalidad de eliminación, necesitamos entender un problema fundamental: **dónde renderizar los modales en el árbol DOM**.

### Entendiendo el Árbol DOM

El DOM (Document Object Model) es una estructura de árbol:

```
<html>
  <body>
    <div id="root">
      <App>
        <Navbar />
        <CategoryPage>
          <CategoryCard>
            <DeleteButton />
            <Modal />  ← ¿Dónde debería renderizarse esto?
          </CategoryCard>
        </CategoryPage>
      </App>
    </div>
  </body>
</html>
```

**Problema**: Si `<Modal />` renderiza dentro de `<CategoryCard>`, hereda todos los estilos y restricciones del padre.

### Contexto de Apilamiento CSS: La Causa Raíz

El **contexto de apilamiento** determina qué elementos aparecen sobre otros. Es creado por:
- `position: relative/absolute/fixed` con `z-index`
- `transform`, `filter`, `opacity < 1`
- `overflow: hidden`

**Problema de ejemplo:**

```tsx
<div style={{ position: 'relative', overflow: 'hidden', zIndex: 1 }}>
  <CategoryCard />
  <Modal style={{ zIndex: 9999 }} />  {/* ¡Todavía se recorta! */}
</div>
```

**Por qué falla:**
- El modal está dentro de un padre con `overflow: hidden`
- El modal se recorta por los límites del padre
- `z-index` solo funciona dentro del mismo contexto de apilamiento
- El modal no puede escapar del contexto de apilamiento del padre

**Visual:**
```
┌─────────────────────────────────┐
│ Padre (overflow: hidden)        │
│  ┌──────────────┐              │
│  │ CategoryCard │              │
│  └──────────────┘              │
│  ┌────────────────────┐        │ ← ¡El modal se recorta!
│  │ Modal              │        │
│  │ (quiere ser completo│        │
│  └────────────────────┘        │
└─────────────────────────────────┘
```

### La Solución: Portales de React

Los **Portales** nos permiten renderizar componentes **fuera de la jerarquía DOM del padre**, rompiendo libre de las restricciones del contexto de apilamiento.

```
<html>
  <body>
    <div id="root">
      <App>
        <CategoryCard>
          <DeleteButton />  ← El botón activa el modal
        </CategoryCard>
      </App>
    </div>
    
    <!-- El modal renderiza aquí vía portal -->
    <div class="modal-overlay">
      <Modal />  ← ¡Renderizado a nivel del body!
    </div>
  </body>
</html>
```

**Beneficios:**
- ✅ El modal siempre aparece encima
- ✅ Sin problemas de contexto de apilamiento
- ✅ Control completo del viewport
- ✅ Comportamiento de z-index adecuado
- ✅ Sin herencia de estilos del padre

---

## Portales de React: API createPortal

```tsx
import { createPortal } from 'react-dom'

/**
 * createPortal(children, container, key?)
 * 
 * Argumentos:
 * 1. children: Elemento React a renderizar
 * 2. container: Nodo DOM donde renderizar
 * 3. key?: Clave opcional para reconciliación de React
 * 
 * Devuelve: Portal de React
 */
const modal = createPortal(
  <div>Contenido del modal</div>,
  document.body
)
```

**Comportamiento clave:**
- El burbujeo de eventos todavía sigue el árbol de React (no el árbol DOM)
- El contexto funciona normalmente
- Las refs funcionan normalmente
- Solo cambia la ubicación de renderizado

---

## Implementación del Modal de Confirmación

```tsx
// src/components/ui/ConfirmModal.tsx

import { createPortal } from 'react-dom'
import { useEffect } from 'react'

interface ConfirmModalProps {
  isOpen: boolean
  onClose: () => void
  onConfirm: () => void
  title: string
  message: string
  confirmText?: string
  cancelText?: string
  variant?: 'danger' | 'warning'
}

/**
 * Modal de confirmación usando Portal de React
 * 
 * Portal: Renderizar componente en diferente ubicación DOM
 * Útil para modales, tooltips, dropdowns
 */
export function ConfirmModal({
  isOpen,
  onClose,
  onConfirm,
  title,
  message,
  confirmText = 'Confirmar',
  cancelText = 'Cancelar',
  variant = 'danger',
}: ConfirmModalProps) {
  /**
   * Cerrar modal con tecla Escape
   */
  useEffect(() => {
    const handleEscape = (e: KeyboardEvent) => {
      if (e.key === 'Escape') {
        onClose()
      }
    }

    if (isOpen) {
      document.addEventListener('keydown', handleEscape)
      // Prevenir scroll del body cuando el modal está abierto
      document.body.style.overflow = 'hidden'
    }

    return () => {
      document.removeEventListener('keydown', handleEscape)
      document.body.style.overflow = 'unset'
    }
  }, [isOpen, onClose])

  if (!isOpen) return null

  /**
   * createPortal renderiza el modal a nivel de document.body
   * 
   * Esto rompe libre de:
   * - Restricciones de overflow del padre
   * - Contextos de apilamiento del padre  
   * - Transform/filter/clip-path del padre
   * 
   * Pero mantiene:
   * - Burbujeo de eventos de React
   * - Acceso al contexto
   * - Acceso a refs
   */
  return createPortal(
    <>
      {/* Fondo */}
      <div
        className="fixed inset-0 bg-black/50 z-40"
        onClick={onClose}
        aria-hidden="true"
      />

      {/* Modal */}
      <div className="fixed inset-0 z-50 flex items-center justify-center p-4">
        <div
          className="bg-slate-900 rounded-lg border border-slate-800 shadow-xl max-w-md w-full"
          role="dialog"
          aria-modal="true"
          aria-labelledby="modal-title"
        >
          {/* Encabezado */}
          <div className="p-6 pb-4">
            <h2
              id="modal-title"
              className="text-xl font-bold text-slate-100"
            >
              {title}
            </h2>
          </div>

          {/* Contenido */}
          <div className="px-6 pb-6">
            <p className="text-slate-300">{message}</p>
          </div>

          {/* Acciones */}
          <div className="flex gap-3 px-6 pb-6">
            <button
              type="button"
              onClick={onClose}
              className="flex-1 px-4 py-2 bg-slate-800 text-slate-200 rounded-md hover:bg-slate-700"
            >
              {cancelText}
            </button>
            <button
              type="button"
              onClick={onConfirm}
              className={`flex-1 px-4 py-2 rounded-md ${
                variant === 'danger'
                  ? 'bg-red-600 text-white hover:bg-red-700'
                  : 'bg-yellow-600 text-white hover:bg-yellow-700'
              }`}
            >
              {confirmText}
            </button>
          </div>
        </div>
      </div>
    </>,
    document.body  // Renderizar a nivel del body
  )
}
```

### ¿Por Qué Portales?

**Problema sin portal:**
```tsx
<div style={{ overflow: 'hidden', position: 'relative' }}>
  <Modal />  {/* ¡El modal se recorta por el padre! */}
</div>
```

**Solución con portal:**
```tsx
createPortal(<Modal />, document.body)
// El modal renderiza a nivel del body, ignora las restricciones del padre
```

---

## Botón de Eliminar con Modal

```tsx
// src/features/categories/components/DeleteCategoryButton.tsx

import { useState } from 'react'
import { useNavigate } from 'react-router-dom'
import { ConfirmModal } from '@/components/ui/ConfirmModal'
import { apiClient } from '@/lib/api-client'
import { toast } from '@/lib/toast'
import type { Category } from '@/types'

interface DeleteCategoryButtonProps {
  category: Category
}

export function DeleteCategoryButton({ category }: DeleteCategoryButtonProps) {
  const navigate = useNavigate()
  const [showModal, setShowModal] = useState(false)
  const [isDeleting, setIsDeleting] = useState(false)

  const handleDelete = async () => {
    setIsDeleting(true)

    try {
      await apiClient.delete(`/categories/${category.id}`)
      
      toast.success('Categoría eliminada exitosamente')
      
      // Navegar fuera de la categoría eliminada
      navigate('/categories')
    } catch (error) {
      toast.error(error instanceof Error ? error.message : 'Falló eliminar categoría')
    } finally {
      setIsDeleting(false)
      setShowModal(false)
    }
  }

  return (
    <>
      <button
        type="button"
        onClick={() => setShowModal(true)}
        className="px-4 py-2 bg-red-600 text-white rounded-md hover:bg-red-700"
      >
        Eliminar Categoría
      </button>

      <ConfirmModal
        isOpen={showModal}
        onClose={() => setShowModal(false)}
        onConfirm={handleDelete}
        title="¿Eliminar Categoría?"
        message={`¿Estás seguro de que quieres eliminar "${category.name}"? Esta acción no se puede deshacer.`}
        confirmText={isDeleting ? 'Eliminando...' : 'Eliminar'}
        variant="danger"
      />
    </>
  )
}
```

---

## Advertencia en Cascada

Verificar si la categoría tiene hilos antes de eliminar.

```tsx
export function DeleteCategoryButton({ category }: DeleteCategoryButtonProps) {
  const navigate = useNavigate()
  const [showModal, setShowModal] = useState(false)
  const [isDeleting, setIsDeleting] = useState(false)

  /**
   * Obtener mensaje de advertencia basado en el conteo de hilos
   */
  const getWarningMessage = () => {
    if (category.threadCount === 0) {
      return `¿Estás seguro de que quieres eliminar "${category.name}"?`
    }

    return `"${category.name}" tiene ${category.threadCount} hilo(s). Eliminar esta categoría también eliminará todos los hilos. Esta acción no se puede deshacer.`
  }

  const handleDelete = async () => {
    setIsDeleting(true)

    try {
      /**
       * La API debería manejar la eliminación en cascada:
       * 1. Eliminar todos los hilos en la categoría
       * 2. Eliminar todos los posts en esos hilos
       * 3. Eliminar la categoría
       */
      await apiClient.delete(`/categories/${category.id}`)
      
      toast.success('Categoría e hilos asociados eliminados')
      navigate('/categories')
    } catch (error) {
      toast.error(error instanceof Error ? error.message : 'Falló eliminar categoría')
    } finally {
      setIsDeleting(false)
      setShowModal(false)
    }
  }

  return (
    <>
      <button
        type="button"
        onClick={() => setShowModal(true)}
        className="px-4 py-2 bg-red-600 text-white rounded-md hover:bg-red-700"
      >
        Eliminar Categoría
      </button>

      <ConfirmModal
        isOpen={showModal}
        onClose={() => setShowModal(false)}
        onConfirm={handleDelete}
        title="¿Eliminar Categoría?"
        message={getWarningMessage()}
        confirmText={isDeleting ? 'Eliminando...' : 'Eliminar'}
        variant={category.threadCount > 0 ? 'danger' : 'warning'}
      />
    </>
  )
}
```

---

## Verificación de Autorización

Solo permitir que administradores/moderadores eliminen categorías.

```tsx
import { useAuth } from '@/features/auth/hooks/useAuth'

export function DeleteCategoryButton({ category }: DeleteCategoryButtonProps) {
  const { user } = useAuth()

  // Solo mostrar botón a usuarios autorizados
  if (!user || (user.role !== 'admin' && user.role !== 'moderator')) {
    return null
  }

  // ... resto del componente
}
```

---

## Eliminación Optimista

Eliminar de la UI inmediatamente para mejor UX.

```tsx
export function useCategoryDelete() {
  const queryClient = useQueryClient()

  return useMutation({
    mutationFn: async (categoryId: string) => {
      return apiClient.delete(`/categories/${categoryId}`)
    },

    /**
     * Eliminar optimistamente del caché
     */
    onMutate: async (categoryId) => {
      // Cancelar consultas salientes
      await queryClient.cancelQueries({ queryKey: ['categories'] })

      // Capturar estado anterior
      const previous = queryClient.getQueryData<Category[]>(['categories'])

      // Eliminar categoría del caché
      if (previous) {
        queryClient.setQueryData<Category[]>(
          ['categories'],
          previous.filter((cat) => cat.id !== categoryId)
        )
      }

      return { previous }
    },

    /**
     * Rollback en caso de error
     */
    onError: (err, variables, context) => {
      if (context?.previous) {
        queryClient.setQueryData(['categories'], context.previous)
      }
      toast.error('Falló eliminar categoría')
    },

    onSuccess: () => {
      toast.success('Categoría eliminada')
    },
  })
}
```

---

## Resumen

### Nuevos Conceptos
1. **Portal de React**: Renderizar componente fuera del árbol padre
   ```tsx
   createPortal(<Modal />, document.body)
   ```

2. **Patrones de Modal**:
   - El fondo previene clics en el fondo
   - La tecla Escape cierra el modal
   - Prevenir scroll del body cuando está abierto
   - Trampa de enfoque para accesibilidad

3. **Eliminación en Cascada**: Advertir a usuarios sobre consecuencias

4. **Autorización**: Verificar permisos de usuario antes de mostrar acciones

### Mejores Prácticas
- ✅ Siempre confirmar acciones destructivas
- ✅ Mostrar mensajes de advertencia claros
- ✅ Deshabilitar botones durante la eliminación
- ✅ Verificar autorización antes de mostrar botón de eliminar
- ✅ Manejar eliminación en cascada apropiadamente
- ✅ Usar actualizaciones optimistas para retroalimentación instantánea

---

## Accesibilidad de Teclado

```tsx
export function ConfirmModal({ isOpen, onClose, onConfirm }) {
  const modalRef = useRef<HTMLDivElement>(null)
  const previousFocusRef = useRef<HTMLElement | null>(null)

  useEffect(() => {
    if (!isOpen) return

    // Guardar elemento enfocado actualmente
    previousFocusRef.current = document.activeElement as HTMLElement

    // Enfocar modal
    modalRef.current?.focus()

    // Atrapar enfoque dentro del modal
    const handleTab = (e: KeyboardEvent) => {
      if (e.key !== 'Tab') return

      const focusable = modalRef.current?.querySelectorAll(
        'button, [href], input, select, textarea, [tabindex]:not([tabindex="-1"])'
      )
      if (!focusable || focusable.length === 0) return

      const first = focusable[0] as HTMLElement
      const last = focusable[focusable.length - 1] as HTMLElement

      if (e.shiftKey && document.activeElement === first) {
        e.preventDefault()
        last.focus()
      } else if (!e.shiftKey && document.activeElement === last) {
        e.preventDefault()
        first.focus()
      }
    }

    document.addEventListener('keydown', handleTab)

    return () => {
      document.removeEventListener('keydown', handleTab)
      // Restaurar enfoque
      previousFocusRef.current?.focus()
    }
  }, [isOpen])

  // ... resto del componente
}
```

---

## Flujo Completo de Eliminación

```tsx
// src/features/categories/components/DeleteCategoryButton.tsx

import { useState } from 'react'
import { useNavigate } from 'react-router-dom'
import { useMutation, useQueryClient } from '@tanstack/react-query'
import { ConfirmModal } from '@/components/ui/ConfirmModal'
import { apiClient } from '@/lib/api-client'
import { toast } from '@/lib/toast'
import { useAuth } from '@/features/auth/hooks/useAuth'
import type { Category } from '@/types'

interface DeleteCategoryButtonProps {
  category: Category
}

export function DeleteCategoryButton({ category }: DeleteCategoryButtonProps) {
  const { user } = useAuth()
  const navigate = useNavigate()
  const queryClient = useQueryClient()
  const [showModal, setShowModal] = useState(false)

  /**
   * Verificación de autorización
   */
  const canDelete = user && ['admin', 'moderator'].includes(user.role)

  /**
   * Mutación de eliminación con actualizaciones optimistas
   */
  const deleteMutation = useMutation({
    mutationFn: async () => {
      return apiClient.delete(`/categories/${category.id}`)
    },

    onMutate: async () => {
      // Cancelar consultas salientes
      await queryClient.cancelQueries({ queryKey: ['categories'] })

      // Captura para rollback
      const previous = queryClient.getQueryData<Category[]>(['categories'])

      // Eliminar optimistamente
      if (previous) {
        queryClient.setQueryData<Category[]>(
          ['categories'],
          previous.filter((c) => c.id !== category.id)
        )
      }

      return { previous }
    },

    onError: (err, variables, context) => {
      // Rollback
      if (context?.previous) {
        queryClient.setQueryData(['categories'], context.previous)
      }
      toast.error('Falló eliminar categoría')
    },

    onSuccess: () => {
      toast.success(`"${category.name}" eliminada exitosamente`)
      setShowModal(false)
      navigate('/categories')
    },
  })

  if (!canDelete) return null

  const warningMessage =
    category.threadCount === 0
      ? `¿Estás seguro de que quieres eliminar "${category.name}"? Esta acción no se puede deshacer.`
      : `Advertencia: "${category.name}" contiene ${category.threadCount} hilo(s). Eliminar esta categoría eliminará permanentemente todos los hilos y sus posts. Esta acción no se puede deshacer.`

  return (
    <>
      <button
        onClick={() => setShowModal(true)}
        className="px-4 py-2 bg-red-600 text-white rounded-lg hover:bg-red-700 font-medium transition-colors"
        aria-label={`Eliminar ${category.name}`}
      >
        Eliminar
      </button>

      <ConfirmModal
        isOpen={showModal}
        onClose={() => setShowModal(false)}
        onConfirm={() => deleteMutation.mutate()}
        title="¿Eliminar Categoría?"
        message={warningMessage}
        confirmText={deleteMutation.isPending ? 'Eliminando...' : 'Eliminar'}
        cancelText="Cancelar"
        variant={category.threadCount > 0 ? 'danger' : 'warning'}
        isLoading={deleteMutation.isPending}
      />
    </>
  )
}
```

---

## Probando el Flujo de Eliminación

```tsx
import { render, screen, waitFor } from '@testing-library/react'
import userEvent from '@testing-library/user-event'
import { DeleteCategoryButton } from '../DeleteCategoryButton'
import { apiClient } from '@/lib/api-client'

vi.mock('@/lib/api-client')

describe('DeleteCategoryButton', () => {
  const mockCategory: Category = {
    id: '1',
    name: 'Categoría de Prueba',
    slug: 'test',
    threadCount: 5,
  }

  it('muestra modal de confirmación con advertencia en cascada', async () => {
    const user = userEvent.setup()

    render(<DeleteCategoryButton category={mockCategory} />)

    await user.click(screen.getByText('Eliminar'))

    expect(screen.getByText(/Advertencia.*contiene 5 hilo/)).toBeInTheDocument()
  })

  it('llama a la API y elimina optimistamente', async () => {
    const user = userEvent.setup()
    vi.mocked(apiClient.delete).mockResolvedValueOnce({})

    render(<DeleteCategoryButton category={mockCategory} />)

    await user.click(screen.getByText('Eliminar'))
    await user.click(screen.getByText('Eliminar', { selector: 'button[type="button"]' }))

    await waitFor(() => {
      expect(apiClient.delete).toHaveBeenCalledWith('/categories/1')
    })
  })
})
```

---

## Resumen

### Conceptos Clave Dominados

1. **Portales de React**: Renderizar fuera de la jerarquía DOM
   - `createPortal(children, container)`
   - Rompe restricciones CSS, mantiene comportamiento React

2. **Contexto de Apilamiento CSS**: Por qué importan los portales
   - Creado por position, transform, overflow, etc.
   - z-index solo funciona dentro del mismo contexto

3. **Accesibilidad de Teclado**:
   - Trampa de enfoque (ciclo Tab)
   - ESC para cerrar
   - Restauración de enfoque
   - Roles ARIA

4. **Actualizaciones Optimistas**: Mejor UX
   - Actualizar UI inmediatamente
   - Rollback en caso de error
   - Mostrar estados de carga

5. **Advertencias en Cascada**: Seguridad del usuario
   - Mostrar impacto de la eliminación
   - Mensajería clara
   - Confirmación requerida

### Mejores Prácticas

- ✅ Siempre usar portales para modales
- ✅ Implementar trampa de enfoque
- ✅ Restaurar enfoque al cerrar
- ✅ Verificar autorización antes de mostrar eliminar
- ✅ Advertir sobre efectos en cascada
- ✅ Actualizaciones optimistas con rollback
- ✅ Estados de carga previenen dobles clics
- ✅ Probar flujos de eliminación exhaustivamente

---

Siguiente: [Categorías Anidadas →](/es/react/4.categories-module/5.nested-categories)
