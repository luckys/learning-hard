---
title: Listar Categor√≠as - Tu Primera Funcionalidad de React
description: Construye tu primera funcionalidad completa de React desde cero. Domina componentes, props, JSX, listas, TypeScript, pruebas y el modelo mental de React a trav√©s de la operaci√≥n CRUD m√°s simple.
---

# Disclaimer

:::u-alert
---
title: Los comentarios en el c√≥digo son solo educativos.
description: En proyectos reales, evita comentarios irrelevantes o redundantes.
color: warning
variant: subtle
icon: i-lucide-triangle-alert
---
:::

Comenzamos con la **funcionalidad m√°s simple posible**: mostrar una lista de categor√≠as del foro. Esto te ense√±a los fundamentos de React en un contexto del mundo real, construyendo confianza antes de abordar funcionalidades m√°s complejas.

**¬øPor qu√© empezar aqu√≠?**
- Sin llamadas a la API a√∫n (datos est√°ticos)
- Sin entrada de usuario (solo lectura)
- L√≥gica de renderizado pura
- Retroalimentaci√≥n visual inmediata
- Fundamento para todas las dem√°s funcionalidades

---

## Lo Que Estamos Construyendo

Una lista de categor√≠as para nuestro foro que muestra:
- Nombre y descripci√≥n de la categor√≠a
- Conteo de threads (no de posts - los threads son discusiones de nivel superior)
- Jerarqu√≠a visual (categor√≠as anidadas)
- Tarjetas clicables que navegan al detalle de la categor√≠a
- Layout de grid responsivo

**Estructura visual:**
```
üìÅ Discusi√≥n General (245 threads)
   "Un lugar para discusiones generales y chat de la comunidad"
   
üìÅ Soporte T√©cnico (89 threads)
   "Obt√©n ayuda con problemas t√©cnicos y preguntas"
   
  ‚îî‚îÄ üìÅ Reportes de Bugs (34 threads)
  ‚îî‚îÄ üìÅ Solicitudes de Funcionalidades (55 threads)
  
üìÅ Anuncios (12 threads)
   "Anuncios oficiales y noticias"
```

---

## Componentes de React: El Fundamento

### ¬øQu√© es un Componente?

Un **componente** es una funci√≥n de JavaScript que devuelve **JSX** (markup de UI). Es la forma de React de construir piezas reutilizables de UI.

**El componente m√°s simple:**
```tsx
function Greeting() {
  return <h1>¬°Hola, Mundo!</h1>
}
```

**Usando el componente:**
```tsx
<Greeting />  // Renderiza: <h1>¬°Hola, Mundo!</h1>
```

### Componentes vs Etiquetas HTML

| Etiqueta HTML | Componente de React |
|---------------|---------------------|
| `<div>` | Incorporado |
| `<button>` | Incorporado |
| `<CategoryCard>` | ¬°Tu componente personalizado! |
| `<ThreadList>` | ¬°Tu componente personalizado! |

**Piensa en los componentes como:**
- Etiquetas HTML personalizadas que defines
- Bloques de construcci√≥n de UI reutilizables
- Funciones que devuelven markup
- Piezas de LEGO que combinas

### ¬øPor Qu√© Funciones? (No Clases)

React comenz√≥ con componentes de clase (antes de 2019), luego cambi√≥ a funciones. As√≠ es como las funciones ganaron:

```tsx
// ‚ùå FORMA ANTIGUA: Componentes de clase (verbosos, confusos)
class Greeting extends React.Component {
  render() {
    return <h1>¬°Hola, {this.props.name}!</h1>
  }
}

// ‚úÖ FORMA NUEVA: Componentes de funci√≥n (simples, claros)
function Greeting({ name }) {
  return <h1>¬°Hola, {name}!</h1>
}
```

**Beneficios de las funciones:**
1. **Modelo mental m√°s simple**: `entrada (props) ‚Üí salida (JSX)`
2. **Sin palabra clave `this`**: Menos confusi√≥n
3. **M√°s f√°cil de probar**: Las funciones puras son probables
4. **Componibles**: Mezclar y combinar f√°cilmente
5. **Hooks**: Las caracter√≠sticas modernas de React solo funcionan en funciones
6. **Menos c√≥digo**: ~40% menos c√≥digo repetitivo

---

## Pensando en React: El Modelo Mental

Antes de escribir c√≥digo, necesitamos entender **c√≥mo piensa React**.

### La Filosof√≠a de React

React es **declarativo**, no imperativo:

**‚ùå Imperativo (forma jQuery):**
```javascript
// Dile al navegador C√ìMO actualizar
$('#counter').text('0')
$('#button').click(() => {
  let count = parseInt($('#counter').text())
  count++
  $('#counter').text(count)  // Actualizaci√≥n manual del DOM
})
```

**‚úÖ Declarativo (forma React):**
```tsx
// Dile a React QU√â deber√≠a verse la UI
function Counter() {
  const [count, setCount] = useState(0)
  
  return (
    <div>
      <p>{count}</p>
      <button onClick={() => setCount(count + 1)}>
        Incrementar
      </button>
    </div>
  )
  // React descubre C√ìMO actualizar el DOM
}
```

### UI como Funci√≥n del Estado

Este es el principio principal de React:

```
UI = f(estado)
```

Traducci√≥n: **Tu UI es una funci√≥n pura de tu estado.**

```tsx
function CategoryList({ categories }) {
  // Dadas categor√≠as (estado),
  // siempre renderiza la misma UI
  return (
    <div>
      {categories.map(cat => <CategoryCard key={cat.id} category={cat} />)}
    </div>
  )
}

// Misma entrada ‚Üí Misma salida (¬°predecible!)
```

**Beneficios:**
- **Predecible**: Mismo estado = misma UI
- **Depurable**: Conoce el estado = conoce la UI
- **Probable**: Entrada de estado, afirmar UI
- **Viaje en el tiempo**: Reproducir cambios de estado

---

## Descomponiendo la Funcionalidad

Descompongamos "listar categor√≠as" en componentes:

```
CategoriesPage
‚îú‚îÄ PageHeader
‚îÇ  ‚îú‚îÄ Title
‚îÇ  ‚îî‚îÄ CreateButton
‚îú‚îÄ CategoryList
‚îÇ  ‚îú‚îÄ CategoryCard (Discusi√≥n General)
‚îÇ  ‚îú‚îÄ CategoryCard (Soporte T√©cnico)
‚îÇ  ‚îî‚îÄ CategoryCard (Anuncios)
‚îî‚îÄ EmptyState (si no hay categor√≠as)
```

**Jerarqu√≠a de componentes visualizada:**
```tsx
<CategoriesPage>
  <PageHeader />
  <CategoryList>
    <CategoryCard />
    <CategoryCard />
    <CategoryCard />
  </CategoryList>
</CategoriesPage>
```

### Responsabilidad del Componente (Principio de Responsabilidad √önica)

Cada componente tiene **UN trabajo**:

| Componente | Responsabilidad |
|------------|-----------------|
| `CategoriesPage` | Layout, obtener datos (despu√©s) |
| `PageHeader` | T√≠tulo de p√°gina y acciones |
| `CategoryList` | Layout de grid para categor√≠as |
| `CategoryCard` | Mostrar UNA categor√≠a |
| `EmptyState` | Mostrar mensaje cuando no hay categor√≠as |

**¬øPor qu√© separar?**
- **M√°s f√°cil de entender**: Cada archivo es peque√±o
- **M√°s f√°cil de probar**: Probar una cosa a la vez
- **M√°s f√°cil de reutilizar**: Usar `CategoryCard` en cualquier lugar
- **M√°s f√°cil de cambiar**: Modificar tarjeta sin tocar la lista

### Descomponiendo UI en Componentes: El Modelo Mental

**C√≥mo pensar en componentes de React:**

**Paso 1: Dibuja recuadros alrededor de cada componente**

```
‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
‚îÇ CategoriesPage                         ‚îÇ
‚îÇ ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê ‚îÇ
‚îÇ ‚îÇ PageHeader ("Categor√≠as del Foro") ‚îÇ ‚îÇ
‚îÇ ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò ‚îÇ
‚îÇ ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê ‚îÇ
‚îÇ ‚îÇ CategoryList                       ‚îÇ ‚îÇ
‚îÇ ‚îÇ ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê ‚îÇ ‚îÇ
‚îÇ ‚îÇ ‚îÇ CategoryCard ‚îÇ ‚îÇ CategoryCard ‚îÇ ‚îÇ ‚îÇ
‚îÇ ‚îÇ ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò ‚îÇ ‚îÇ
‚îÇ ‚îÇ ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê                  ‚îÇ ‚îÇ
‚îÇ ‚îÇ ‚îÇ CategoryCard ‚îÇ                  ‚îÇ ‚îÇ
‚îÇ ‚îÇ ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò                  ‚îÇ ‚îÇ
‚îÇ ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò ‚îÇ
‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò
```

**Paso 2: Nombra cada recuadro**
- `CategoriesPage`: La p√°gina completa
- `PageHeader`: T√≠tulo y botones de acci√≥n
- `CategoryList`: Contenedor de grid
- `CategoryCard`: Categor√≠a individual

**Paso 3: Identifica jerarqu√≠a (relaciones padre/hijo)**
- `CategoriesPage` ‚Üí posee `PageHeader` y `CategoryList`
- `CategoryList` ‚Üí posee m√∫ltiples `CategoryCard`
- `CategoryCard` ‚Üí componente hoja (sin hijos)

**Paso 4: Determina flujo de datos**
- `CategoriesPage` tiene array de categor√≠as
- Pasa array a `CategoryList`
- `CategoryList` pasa categor√≠a individual a cada `CategoryCard`

**¬øCu√°ndo crear un nuevo componente?**

‚úÖ **Crea un nuevo componente cuando:**
- Se usa m√∫ltiples veces (reutilizaci√≥n)
- Hace una cosa clara (responsabilidad √∫nica)
- El padre est√° volvi√©ndose demasiado grande (>200 l√≠neas)
- Quieres probarlo por separado (probabilidad)
- Tiene su propio estado o l√≥gica (encapsulaci√≥n)

‚ùå **No crees un nuevo componente cuando:**
- Solo se usa una vez y es diminuto (<10 l√≠neas)
- Est√° estrechamente acoplado al padre (sin l√≠mite claro)
- Hace que el c√≥digo sea m√°s dif√≠cil de seguir (sobre-abstracci√≥n)

**√Årbol de decisi√≥n de ejemplo:**

```tsx
// CategoryCard renderiza la misma UI 10+ veces ‚Üí Extraer a componente ‚úÖ
{categories.map(cat => <CategoryCard category={cat} />)}

// CategoryHeader solo se usa una vez, 5 l√≠neas ‚Üí Mantener en l√≠nea ‚ùå
<div className="mb-4">
  <h1>Categor√≠as</h1>
</div>
```

---

## TypeScript: Seguridad de Tipos Primero

Antes de construir componentes, define la **estructura de datos**. TypeScript previene errores al detectar errores en tiempo de compilaci√≥n.

### ¬øPor Qu√© TypeScript?

```tsx
// ‚ùå JavaScript: Errores en tiempo de ejecuci√≥n
function CategoryCard({ category }) {
  return <h3>{category.nama}</h3>  // ¬°Error! Falla en tiempo de ejecuci√≥n
}

// ‚úÖ TypeScript: Errores en tiempo de compilaci√≥n
interface Category {
  name: string
}

function CategoryCard({ category }: { category: Category }) {
  return <h3>{category.nama}</h3>  // ¬°Error antes de ejecutar!
  // La propiedad 'nama' no existe en el tipo 'Category'
}
```

**Beneficios:**
- **Detecta errores temprano**: Antes de ejecutar el c√≥digo
- **Autocompletar**: El IDE sabe qu√© propiedades existen
- **Confianza en la refactorizaci√≥n**: Renombra de forma segura
- **Documentaci√≥n**: Los tipos son documentaci√≥n viva
- **Mejor DX**: IntelliSense, errores en l√≠nea

---

## Tipo de Categor√≠a

Primero, define la estructura de datos. TypeScript asegura que manejemos los datos correctamente.

```typescript
// src/types/index.ts

/**
 * Entidad Categor√≠a del modelo de dominio
 * Las categor√≠as organizan los threads del foro en temas
 */
export interface Category {
  id: string              // UUID v7
  name: string            // "Soporte T√©cnico"
  slug: string            // URL-friendly: "soporte-tecnico"
  description: string | null  // Tagline opcional
  parentId: string | null     // Para categor√≠as anidadas (null = ra√≠z)
  order: number           // Orden de visualizaci√≥n (m√°s bajo = primero)
  threadCount: number     // Conteo cacheado para rendimiento
  createdAt: string       // ISO 8601: "2024-01-15T10:30:00Z"
  updatedAt: string
}
```

**¬øPor qu√© estos campos?**
- `slug`: URLs amigables para SEO (`/categories/soporte-tecnico` no `/categories/abc-123`)
- `parentId`: Habilita categor√≠as anidadas (patr√≥n de respuestas a posts)
- `order`: Ordenamiento manual sin timestamps
- `threadCount`: Evita contar en cada renderizado

---

## JSX: JavaScript + XML

JSX parece HTML pero es JavaScript. React lo transforma en llamadas a funciones.

```tsx
// Lo que escribes
<div className="card">
  <h2>{category.name}</h2>
</div>

// Lo que ve React
React.createElement('div', { className: 'card' },
  React.createElement('h2', null, category.name)
)
```

**Reglas de JSX:**
1. **Devuelve ra√≠z √∫nica**: Envuelve m√∫ltiples elementos en `<div>` o `<>` (Fragment)
2. **Cierra todas las etiquetas**: `<img />` no `<img>`
3. **Atributos camelCase**: `className` no `class`, `onClick` no `onclick`
4. **Llaves para JS**: `{category.name}` no `category.name`

---

## Componente CategoryCard

```tsx
// src/components/categories/CategoryCard.tsx

interface CategoryCardProps {
  category: Category
}

/**
 * Muestra una sola categor√≠a con icono, nombre, descripci√≥n y conteo de posts
 * 
 * Decisiones de dise√±o:
 * - Clic en toda la tarjeta (no solo texto) para mejor UX
 * - Efecto hover para descubrimiento
 * - Icono para jerarqu√≠a visual
 * - Conteo de posts como indicador de actividad
 */
export function CategoryCard({ category }: CategoryCardProps) {
  return (
    <Link
      to={`/categories/${category.slug}`}
      className="block p-4 rounded-lg bg-slate-800 hover:bg-slate-700 transition-colors border border-slate-700"
    >
      {/* Fila Icono + T√≠tulo */}
      <div className="flex items-center gap-3 mb-2">
        {/* Icono de carpeta para reconocimiento visual */}
        <div className="text-2xl">üìÅ</div>
        
        {/* Nombre de categor√≠a - h3 sem√°ntico para accesibilidad */}
        <h3 className="text-lg font-semibold text-slate-100">
          {category.name}
        </h3>
      </div>

      {/* Descripci√≥n - renderizado condicional */}
      {category.description && (
        <p className="text-sm text-slate-400 mb-3">
          {category.description}
        </p>
      )}

      {/* Fila de metadatos */}
      <div className="flex items-center gap-4 text-xs text-slate-500">
        {/* Conteo de threads */}
        <span>
          {category.threadCount} {category.threadCount === 1 ? 'thread' : 'threads'}
        </span>
      </div>
    </Link>
  )
}
```

### Descomponiendo el Componente

**Interfaz de Props:**
```tsx
interface CategoryCardProps {
  category: Category  // Seguro de tipos: solo se permiten objetos Category
}
```

¬øPor qu√© interfaces?
- **Seguridad de tipos**: TypeScript detecta errores en tiempo de compilaci√≥n
- **Documentaci√≥n**: Las props son autodocumentadas
- **Autocompletar**: El IDE sabe qu√© propiedades existen

**Desestructuraci√≥n:**
```tsx
export function CategoryCard({ category }: CategoryCardProps) {
  // Desestructurar props en firma de funci√≥n
  // En lugar de: props.category.name
  // Escribimos: category.name
}
```

**Renderizado Condicional:**
```tsx
{category.description && (
  <p>{category.description}</p>
)}
```

Patr√≥n: `condici√≥n && <JSX>` (si la condici√≥n es verdadera, renderiza JSX)

¬øPor qu√© no `? :` (ternario)?
- M√°s limpio para l√≥gica "mostrar u ocultar"
- No se necesita `: null`

---

## Renderizando Listas: map()

React renderiza arrays de JSX. Usa `.map()` para transformar datos en componentes.

```tsx
// src/pages/CategoriesPage.tsx

import { CategoryCard } from '@/components/categories/CategoryCard'
import type { Category } from '@/types'

export function CategoriesPage() {
  // Datos mock (los obtendremos de la API despu√©s)
  const categories: Category[] = [
    {
      id: '01HXQK9Z3XAMPLE000001',
      name: 'Discusi√≥n General',
      slug: 'discusion-general',
      description: 'Temas generales y chat de la comunidad',
      parentId: null,
      order: 1,
      threadCount: 245,
      createdAt: '2024-01-15T10:00:00Z',
      updatedAt: '2024-01-15T10:00:00Z',
    },
    {
      id: '01HXQK9Z3XAMPLE000002',
      name: 'Soporte T√©cnico',
      slug: 'soporte-tecnico',
      description: 'Obt√©n ayuda con problemas t√©cnicos',
      parentId: null,
      order: 2,
      threadCount: 89,
      createdAt: '2024-01-15T10:05:00Z',
      updatedAt: '2024-01-15T10:05:00Z',
    },
  ]

  return (
    <div className="container mx-auto px-4 py-8">
      {/* Encabezado de p√°gina */}
      <h1 className="text-3xl font-bold text-slate-100 mb-6">
        Categor√≠as del Foro
      </h1>

      {/* Grid de categor√≠as */}
      <div className="grid gap-4 md:grid-cols-2 lg:grid-cols-3">
        {categories.map((category) => (
          <CategoryCard
            key={category.id}
            category={category}
          />
        ))}
      </div>
    </div>
  )
}
```

### La Prop `key`: Por Qu√© Importa

**CADA item de lista DEBE tener una `key` √∫nica:**

```tsx
{categories.map((category) => (
  <CategoryCard
    key={category.id}  // ‚úÖ Identificador √∫nico y estable
    category={category}
  />
))}
```

**¬øPor qu√© keys?**

React usa keys para:
1. **Identificar qu√© items cambiaron**: Actualizar solo lo que es diferente
2. **Preservar estado del componente**: Si reordenas, el estado se queda con el item correcto
3. **Optimizar rendimiento**: Evita recrear nodos DOM

**Keys malas:**
```tsx
key={index}  // ‚ùå MALO: Cambia cuando el array se reordena
key={Math.random()}  // ‚ùå MALO: Nueva key cada renderizado ‚Üí remontaje completo
```

**Keys buenas:**
```tsx
key={category.id}  // ‚úÖ BUENO: Identificador √∫nico y estable
```

---

## Composici√≥n de Componentes

Descomp√≥n UI en piezas m√°s peque√±as. Cada componente tiene **un trabajo**.

```tsx
// ‚ùå MALO: Componente gigante que hace todo
function CategoriesPage() {
  return (
    <div>
      {/* 200 l√≠neas de JSX... */}
    </div>
  )
}

// ‚úÖ BUENO: Compuesto de componentes m√°s peque√±os
function CategoriesPage() {
  return (
    <div>
      <PageHeader title="Categor√≠as" />
      <CategoryList categories={categories} />
    </div>
  )
}

function CategoryList({ categories }) {
  return (
    <div className="grid gap-4">
      {categories.map(category => (
        <CategoryCard key={category.id} category={category} />
      ))}
    </div>
  )
}
```

**Beneficios:**
- **M√°s f√°cil de probar**: Prueba `CategoryCard` en aislamiento
- **M√°s f√°cil de leer**: Entiende un componente a la vez
- **M√°s f√°cil de reutilizar**: Usa `CategoryCard` en cualquier lugar

---

## Props: Pasando Datos Hacia Abajo

Las props fluyen **hacia abajo** de padre a hijo (flujo de datos unidireccional).

```tsx
// Padre
<CategoryCard
  category={myCategory}  // Pasa datos hacia abajo
/>

// Hijo
function CategoryCard({ category }) {
  // category es de solo lectura aqu√≠
  // El hijo NO puede modificarlo
  return <div>{category.name}</div>
}
```

**Las props son inmutables:**
```tsx
function CategoryCard({ category }) {
  category.name = 'Nuevo Nombre'  // ‚ùå ERROR: No se pueden modificar props
}
```

¬øPor qu√© inmutables?
- **Predecible**: Los datos fluyen en una direcci√≥n (arriba ‚Üí abajo)
- **Depurable**: Sabes de d√≥nde vienen los datos
- **Seguro**: Sin mutaciones accidentales

### El Flujo de Datos de React: Calle de Un Solo Sentido

Los datos de React fluyen como el agua cuesta abajo: siempre HACIA ABAJO, nunca HACIA ARRIBA.

```
    CategoriesPage (tiene array de categor√≠as)
          ‚Üì props
    CategoryList (recibe array)
          ‚Üì props
    CategoryCard (recibe una categor√≠a)
```

**Principio clave**: Los hijos no pueden modificar directamente el estado del padre.

**¬øPor qu√© una sola direcci√≥n?**
- **M√°s f√°cil de depurar**: Los datos vienen de UN lugar (padre)
- **M√°s f√°cil de razonar**: Sigue los datos hacia abajo en el √°rbol
- **Previene errores**: Ning√∫n hijo puede romper accidentalmente al padre

### Levantar Estado Arriba: Cuando los Componentes Necesitan Compartir

**El problema**: ¬øQu√© pasa si dos componentes necesitan los mismos datos?

**Ejemplo**: Filtro de categor√≠a y lista de categor√≠as

```tsx
// ‚ùå EQUIVOCADO: Cada componente tiene su propio estado (¬°desincronizado!)
function CategoryFilters() {
  const [filter, setFilter] = useState('all')  // Estado de filtro aqu√≠
  return <button onClick={() => setFilter('tech')}>Mostrar Tech</button>
}

function CategoryList() {
  const [filter, setFilter] = useState('all')  // ¬°Estado duplicado!
  // El filtro siempre es 'all' aqu√≠, ¬°incluso si el usuario hizo clic en el bot√≥n de arriba!
  const filtered = categories.filter(cat => filterMatch(cat, filter))
  return <div>{/* ... */}</div>
}
```

¬°Est√°n **desincronizados**! El usuario hace clic en el bot√≥n, pero la lista no se actualiza. üò±

**La soluci√≥n: Levantar estado al padre com√∫n**

```tsx
// ‚úÖ CORRECTO: El padre posee el estado, los hijos lo comparten
function CategoriesPage() {
  // El estado vive en el padre (fuente √∫nica de verdad)
  const [filter, setFilter] = useState('all')

  // Filtrar categor√≠as basadas en el estado
  const filteredCategories = categories.filter(cat => {
    if (filter === 'all') return true
    if (filter === 'tech') return cat.name.includes('Tech')
    return true
  })

  return (
    <>
      {/* Pasa estado Y setter al componente de filtro */}
      <CategoryFilters 
        filter={filter} 
        onFilterChange={setFilter}  // El hijo puede solicitar cambios
      />
      
      {/* Pasa datos filtrados a la lista */}
      <CategoryList categories={filteredCategories} />
    </>
  )
}

function CategoryFilters({ filter, onFilterChange }) {
  return (
    <button onClick={() => onFilterChange('tech')}>
      Mostrar Tech
    </button>
  )
}

function CategoryList({ categories }) {
  return (
    <div>
      {categories.map(cat => <CategoryCard key={cat.id} category={cat} />)}
    </div>
  )
}
```

**C√≥mo funciona:**

1. **El padre posee el estado**: `CategoriesPage` tiene estado `filter`
2. **El padre pasa datos hacia abajo**: Ambos hijos reciben props
3. **El hijo solicita cambios**: `CategoryFilters` llama a `onFilterChange`
4. **El padre actualiza el estado**: `setFilter` cambia el filtro
5. **React vuelve a renderizar**: Ambos hijos reciben nuevas props
6. **La UI se actualiza**: La lista muestra categor√≠as filtradas

**Diagrama de flujo de datos:**

```
El usuario hace clic en el bot√≥n "Mostrar Tech"
         ‚Üì
  Se llama onFilterChange('tech')
         ‚Üì
  El setFilter('tech') del padre se ejecuta
         ‚Üì
  El padre vuelve a renderizar con filter='tech'
         ‚Üì
  ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
  ‚Üì                                  ‚Üì
CategoryFilters               CategoryList
obtiene filter='tech'       obtiene categor√≠as filtradas
```

**¬øCu√°ndo levantar estado arriba?**

‚úÖ **Levanta estado cuando:**
- Dos componentes necesitan los mismos datos
- Un hijo necesita cambiar los datos del padre
- Quieres una fuente √∫nica de verdad

‚ùå **No levantes estado cuando:**
- Solo un componente lo necesita (mantenlo local)
- El estado es completamente independiente
- Hace que el c√≥digo sea innecesariamente complejo

**Ejemplo del mundo real en nuestro foro:**

```tsx
// Despu√©s, cuando agreguemos filtrado:
function CategoriesPage() {
  const [categories, setCategories] = useState([])
  const [searchQuery, setSearchQuery] = useState('')
  const [selectedFilter, setSelectedFilter] = useState('all')

  // Categor√≠as filtradas y buscadas
  const displayedCategories = categories
    .filter(cat => cat.name.toLowerCase().includes(searchQuery.toLowerCase()))
    .filter(cat => selectedFilter === 'all' || cat.type === selectedFilter)

  return (
    <>
      <SearchBar query={searchQuery} onQueryChange={setSearchQuery} />
      <FilterButtons selected={selectedFilter} onFilterChange={setSelectedFilter} />
      <CategoryList categories={displayedCategories} />
    </>
  )
}
```

**Beneficios de levantar estado:**
- ‚úÖ Fuente √∫nica de verdad (un solo lugar para el estado `filter`)
- ‚úÖ Sincronizado (ambos componentes siempre sincronizados)
- ‚úÖ Probable (puede probar el padre con ambos hijos juntos)
- ‚úÖ Predecible (flujo de datos claro)

**La mentalidad de React:**
> "Cuando dos componentes necesitan coordinarse, mueve su estado a su padre com√∫n."

Veremos este patr√≥n en todas partes en React: autenticaci√≥n, formularios, filtros, modales y m√°s.

---

## Estado Vac√≠o

Siempre maneja el caso "sin datos" para una buena UX.

```tsx
export function CategoriesPage() {
  const categories: Category[] = []

  if (categories.length === 0) {
    return (
      <div className="container mx-auto px-4 py-8">
        <div className="text-center py-12">
          <div className="text-6xl mb-4">üìÅ</div>
          <h2 className="text-2xl font-bold text-slate-300 mb-2">
            A√∫n no hay categor√≠as
          </h2>
          <p className="text-slate-500">
            Las categor√≠as aparecer√°n aqu√≠ una vez creadas
          </p>
        </div>
      </div>
    )
  }

  return (
    <div className="container mx-auto px-4 py-8">
      <h1 className="text-3xl font-bold text-slate-100 mb-6">
        Categor√≠as del Foro
      </h1>
      <div className="grid gap-4 md:grid-cols-2 lg:grid-cols-3">
        {categories.map((category) => (
          <CategoryCard key={category.id} category={category} />
        ))}
      </div>
    </div>
  )
}
```

**Patr√≥n: Retorno temprano**
- Verifica estados de error/vac√≠o primero
- Retorna temprano
- La l√≥gica principal permanece sin sangr√≠a

---

## Avanzado: useReducer para Filtros Complejos

**Problema:** M√∫ltiples filtros (b√∫squeda, orden, visibilidad) con estado interdependiente.

**Sin useReducer:**
```tsx
const [searchQuery, setSearchQuery] = useState('')
const [sortBy, setSortBy] = useState('name')
const [showArchived, setShowArchived] = useState(false)
const [showEmpty, setShowEmpty] = useState(true)
// ¬°4 variables de estado separadas = dif√≠cil de gestionar!
```

**Con useReducer:**
```tsx
const [filters, dispatch] = useReducer(filterReducer, initialFilters)
// ¬°Un solo objeto de estado = m√°s f√°cil de gestionar!
```

### ¬øQu√© es useReducer?

`useReducer` es como `useState` pero para **l√≥gica de estado compleja**. En lugar de llamar a `setState`, despachas **acciones** que describen qu√© pas√≥.

**Analog√≠a:** Redux para un solo componente.

### C√≥mo Funciona

```tsx
import { useReducer } from 'react'

/**
 * Funci√≥n reductora: Toma estado actual y acci√≥n, devuelve nuevo estado
 * 
 * Funci√≥n pura: Misma entrada ‚Üí Misma salida
 */
function filterReducer(state, action) {
  switch (action.type) {
    case 'SET_SEARCH':
      return { ...state, searchQuery: action.payload }
    
    case 'SET_SORT':
      return { ...state, sortBy: action.payload }
    
    case 'TOGGLE_ARCHIVED':
      return { ...state, showArchived: !state.showArchived }
    
    case 'RESET':
      return initialFilters
    
    default:
      return state
  }
}

/**
 * Estado inicial
 */
const initialFilters = {
  searchQuery: '',
  sortBy: 'name',
  showArchived: false,
  showEmpty: true,
}

function CategoriesPage() {
  /**
   * useReducer devuelve [estado, dispatch]
   * - estado: Valores actuales del filtro
   * - dispatch: Funci√≥n para enviar acciones
   */
  const [filters, dispatch] = useReducer(filterReducer, initialFilters)

  return (
    <div>
      {/* Input de b√∫squeda */}
      <input
        value={filters.searchQuery}
        onChange={(e) => dispatch({
          type: 'SET_SEARCH',
          payload: e.target.value
        })}
        placeholder="Buscar categor√≠as..."
      />

      {/* Dropdown de orden */}
      <select
        value={filters.sortBy}
        onChange={(e) => dispatch({
          type: 'SET_SORT',
          payload: e.target.value
        })}
      >
        <option value="name">Nombre</option>
        <option value="threads">Conteo de Threads</option>
        <option value="recent">Actualizado Recientemente</option>
      </select>

      {/* Checkbox */}
      <label>
        <input
          type="checkbox"
          checked={filters.showArchived}
          onChange={() => dispatch({ type: 'TOGGLE_ARCHIVED' })}
        />
        Mostrar Archivados
      </label>

      {/* Bot√≥n de reset */}
      <button onClick={() => dispatch({ type: 'RESET' })}>
        Resetear Filtros
      </button>

      {/* Aplicar filtros */}
      {filteredCategories.map(cat => (
        <CategoryCard key={cat.id} category={cat} />
      ))}
    </div>
  )
}
```

### useReducer vs useState

| Aspecto | useState | useReducer |
|---------|----------|-----------|
| **Estado** | Valor √∫nico | Objeto complejo |
| **Actualizaciones** | Directas (setX) | Acciones (dispatch) |
| **L√≥gica** | En l√≠nea | Centralizada |
| **Mejor para** | Estado simple | M√∫ltiples estados relacionados |
| **Probabilidad** | Dif√≠cil | F√°cil (funci√≥n pura) |

**Usa useReducer cuando:**
- ‚úÖ M√∫ltiples variables de estado
- ‚úÖ Transiciones de estado complejas
- ‚úÖ El estado depende del estado anterior
- ‚úÖ Quieres optimizar el rendimiento

**Usa useState cuando:**
- ‚úÖ Valor √∫nico
- ‚úÖ Actualizaciones simples
- ‚úÖ Sin dependencias entre estados

### Ejemplo Completo con Filtrado

```tsx
function CategoriesPage() {
  const [categories] = useState<Category[]>([
    { id: '1', name: 'General', threadCount: 45 },
    { id: '2', name: 'T√©cnico', threadCount: 0 },
    { id: '3', name: 'Anuncios', threadCount: 12 },
  ])

  const [filters, dispatch] = useReducer(filterReducer, initialFilters)

  /**
   * Aplicar filtros a categor√≠as
   */
  const filteredCategories = categories.filter(cat => {
    // Filtro de b√∫squeda
    if (filters.searchQuery && !cat.name.toLowerCase().includes(filters.searchQuery.toLowerCase())) {
      return false
    }

    // Ocultar categor√≠as vac√≠as
    if (!filters.showEmpty && cat.threadCount === 0) {
      return false
    }

    return true
  })

  /**
   * Ordenar categor√≠as
   */
  const sortedCategories = [...filteredCategories].sort((a, b) => {
    switch (filters.sortBy) {
      case 'threads':
        return b.threadCount - a.threadCount
      case 'recent':
        return new Date(b.updatedAt).getTime() - new Date(a.updatedAt).getTime()
      case 'name':
      default:
        return a.name.localeCompare(b.name)
    }
  })

  return (
    <div className="space-y-4">
      {/* Controles de filtro */}
      <div className="flex gap-4">
        <input
          value={filters.searchQuery}
          onChange={(e) => dispatch({
            type: 'SET_SEARCH',
            payload: e.target.value
          })}
          placeholder="Buscar..."
          className="px-3 py-2 bg-slate-900 border border-slate-700 rounded"
        />

        <select
          value={filters.sortBy}
          onChange={(e) => dispatch({
            type: 'SET_SORT',
            payload: e.target.value
          })}
          className="px-3 py-2 bg-slate-900 border border-slate-700 rounded"
        >
          <option value="name">Ordenar por Nombre</option>
          <option value="threads">Ordenar por Threads</option>
        </select>

        <button
          onClick={() => dispatch({ type: 'RESET' })}
          className="px-4 py-2 bg-slate-700 rounded hover:bg-slate-600"
        >
          Resetear
        </button>
      </div>

      {/* Resultados */}
      <div className="grid gap-4">
        {sortedCategories.map(cat => (
          <CategoryCard key={cat.id} category={cat} />
        ))}
      </div>

      {sortedCategories.length === 0 && (
        <p className="text-slate-400">No hay categor√≠as que coincidan con tus filtros</p>
      )}
    </div>
  )
}
```

### Beneficios Clave

‚úÖ **L√≥gica centralizada** - Toda la l√≥gica de filtros en un solo lugar
‚úÖ **Probable** - El reductor es una funci√≥n pura
‚úÖ **Escalable** - F√°cil agregar nuevos filtros
‚úÖ **Depurable** - Puede registrar todas las acciones
‚úÖ **Reutilizable** - Mismo reductor en m√∫ltiples componentes

---

## Probando Tu Componente

```tsx
// src/components/categories/__tests__/CategoryCard.test.tsx

import { render, screen } from '@testing-library/react'
import { BrowserRouter } from 'react-router-dom'
import { CategoryCard } from '../CategoryCard'
import type { Category } from '@/types'

const mockCategory: Category = {
  id: '01HXQK9Z3XAMPLE000001',
  name: 'Discusi√≥n General',
  slug: 'discusion-general',
  description: 'Temas generales',
  parentId: null,
  order: 1,
  threadCount: 42,
  createdAt: '2024-01-15T10:00:00Z',
  updatedAt: '2024-01-15T10:00:00Z',
}

describe('CategoryCard', () => {
  it('renderiza el nombre de la categor√≠a', () => {
    render(
      <BrowserRouter>
        <CategoryCard category={mockCategory} />
      </BrowserRouter>
    )

    expect(screen.getByText('Discusi√≥n General')).toBeInTheDocument()
  })

  it('renderiza el conteo de threads', () => {
    render(
      <BrowserRouter>
        <CategoryCard category={mockCategory} />
      </BrowserRouter>
    )

    expect(screen.getByText('42 threads')).toBeInTheDocument()
  })
})
```

---

## Resumen

### Conceptos Clave Aprendidos

1. **useState**: A√±adir memoria a componentes de funci√≥n
   - Devuelve `[valor, setter]`
   - El setter activa re-renderizado
   - El estado persiste entre renderizados

2. **Componentes Controlados**: React controla el valor del input
   ```tsx
   <input value={state} onChange={(e) => setState(e.target.value)} />
   ```

3. **Pir√°mide de Validaci√≥n**: M√∫ltiples niveles de validaci√≥n
   - HTML5 nativo
   - Tiempo real
   - Manejador de env√≠o
   - Respuesta de API
   - Lado del servidor

4. **Esquemas Zod**: Fuente √∫nica de verdad
   ```tsx
   const schema = z.object({ /* ... */ })
   type Data = z.infer<typeof schema>
   ```

5. **React Hook Form**: Gesti√≥n de formularios de producci√≥n
   - Gesti√≥n de estado eficiente
   - Validaci√≥n incorporada
   - Manejo de errores
   - Optimizado para rendimiento

### Mejores Pr√°cticas

- ‚úÖ Usa componentes controlados para formularios
- ‚úÖ Valida en m√∫ltiples niveles
- ‚úÖ Muestra mensajes de error claros
- ‚úÖ Proporciona estados de carga
- ‚úÖ Usa React Hook Form para formularios complejos
- ‚úÖ Usa Zod para validaci√≥n de esquemas
- ‚úÖ Prueba validaci√≥n y env√≠o de formularios
- ‚úÖ Proporciona retroalimentaci√≥n de √©xito/error

### Victorias de TypeScript

```tsx
// Fuente √∫nica de verdad
const schema = z.object({ name: z.string() })
type FormData = z.infer<typeof schema>

// TypeScript sabe la forma de FormData
const onSubmit = (data: FormData) => {
  // data.name es definitivamente un string!
}
```

---

Siguiente: [Crear Categor√≠a ‚Üí](/es/react/4.categories-module/2.create-category)
