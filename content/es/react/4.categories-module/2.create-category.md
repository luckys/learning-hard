---
title: Crear CategorÃ­a - Formularios y GestiÃ³n de Estado
description: Domina el hook mÃ¡s importante de React (useState), patrones de manejo de formularios, validaciÃ³n e integraciÃ³n de API. Construye formularios listos para producciÃ³n con React Hook Form y Zod.
---

# Disclaimer

:::u-alert
---
title: Los comentarios en el cÃ³digo son solo educativos.
description: En proyectos reales, evita comentarios irrelevantes o redundantes.
color: warning
variant: subtle
icon: i-lucide-triangle-alert
---
:::

Ahora agregamos **interactividad** a nuestro foro. Crear categorÃ­as requiere formularios - una de las partes mÃ¡s complejas de React. Aprenderemos gestiÃ³n de estado, validaciÃ³n e integraciÃ³n de API a travÃ©s de un ejemplo del mundo real.

---

## Lo Que Estamos Construyendo

Un formulario de creaciÃ³n de categorÃ­as listo para producciÃ³n con:
- Campo de nombre (3-50 caracteres, alfanumÃ©rico + espacios/guiones)
- Campo de descripciÃ³n (opcional, mÃ¡ximo 200 caracteres)
- Selector de categorÃ­a padre (para categorÃ­as anidadas)
- ValidaciÃ³n en tiempo real con mensajes de error
- Estados de carga durante el envÃ­o
- Manejo de errores y recuperaciÃ³n
- RetroalimentaciÃ³n de Ã©xito
- Actualizaciones optimistas de UI

**Visual:**
```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚ Crear Nueva CategorÃ­a                â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚ Nombre de CategorÃ­a *                â”‚
â”‚ [Ingresar nombre de categorÃ­a...] âœ“  â”‚
â”‚ 3-50 caracteres, alfanumÃ©rico        â”‚
â”‚                                     â”‚
â”‚ DescripciÃ³n                          â”‚
â”‚ [DescripciÃ³n opcional...] âœ“          â”‚
â”‚ 0/200 caracteres                     â”‚
â”‚                                     â”‚
â”‚ CategorÃ­a Padre                      â”‚
â”‚ [Seleccionar padre...] â–¼             â”‚
â”‚                                     â”‚
â”‚ [Cancelar] [Crear CategorÃ­a]         â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

---

## Estado de React: Memoria del Componente

**El problema principal:** Los componentes de React son funciones. Las funciones no tienen estado - se ejecutan, devuelven JSX, luego desaparecen. Â¿CÃ³mo recordamos la entrada del usuario entre renderizados?

**La soluciÃ³n:** Hook `useState` - la forma de React de aÃ±adir memoria a las funciones.

### Sin Estado: El Problema

```tsx
// âŒ Â¡Esto no funciona!
function CreateCategoryForm() {
  let name = ''  // Variable regular - perdida despuÃ©s del renderizado
  
  return (
    <input
      value={name}
      onChange={(e) => {
        name = e.target.value  // Actualiza variable
        // Â¡Pero React no lo sabe!
        // No hay re-renderizado
        // Â¡El input se mantiene vacÃ­o!
      }}
    />
  )
}
```

**Â¿Por quÃ© no funciona?**
1. El componente renderiza: `name = ''`
2. El usuario escribe en el input: `name = 'General'` (en memoria)
3. El componente vuelve a renderizar: `name = ''` (Â¡reiniciado al valor inicial!)
4. El input muestra cadena vacÃ­a de nuevo

**El ciclo se repite infinitamente** - React no sabe que debe volver a renderizar cuando `name` cambia.

### Con Estado: La SoluciÃ³n

```tsx
import { useState } from 'react'

function CreateCategoryForm() {
  /**
   * useState: AÃ±adir memoria al componente de funciÃ³n
   * 
   * Devuelve: [valorActual, funciÃ³nParaActualizar]
   * 
   * Â¡React recuerda el valor entre renderizados!
   */
  const [name, setName] = useState('')

  return (
    <input
      value={name}
      onChange={(e) => {
        setName(e.target.value)  // Decirle a React que actualice
      }}
    />
  )
}
```

**Ahora funciona:**
1. El componente renderiza: `name = ''`
2. El usuario escribe: `setName('General')` llamado
3. React programa re-renderizado con `name = 'General'`
4. El componente vuelve a renderizar: `name = 'General'`
5. Â¡El input muestra 'General'!

### useState: ProfundizaciÃ³n

**Firma:**
```tsx
const [estado, setEstado] = useState(valorInicial)
```

**ParÃ¡metros:**
- `valorInicial`: El valor inicial (cualquier tipo)

**Devuelve:**
- `estado`: Valor actual
- `setEstado`: FunciÃ³n para actualizarlo

**Flujo de ejecuciÃ³n:**
```tsx
const [count, setCount] = useState(0)

// Renderizado 1: count = 0
console.log(count)  // 0

// El usuario hace clic en el botÃ³n
setCount(1)

// React programa re-renderizado

// Renderizado 2: count = 1
console.log(count)  // 1

// El usuario hace clic de nuevo
setCount(2)

// Renderizado 3: count = 2
console.log(count)  // 2
```

### Insight Clave: Closure

React usa **closures** para recordar el estado entre renderizados.

```tsx
function Component() {
  const [count, setCount] = useState(0)
  
  // Esta funciÃ³n "cierra sobre" la variable count
  // Recuerda count incluso despuÃ©s de que Component devuelve
  const handleClick = () => {
    console.log(count)  // Â¡Puede acceder a count!
  }
  
  return <button onClick={handleClick}>Clic</button>
}
```

**CÃ³mo lo hace React:**
```
Renderizado 1:
  count = 0
  handleClick = () => console.log(0)  // Cierra sobre count=0
  
Renderizado 2:
  count = 1
  handleClick = () => console.log(1)  // Cierra sobre count=1
```

---

## Reglas de Hooks: El Contrato

Antes de usar mÃºltiples hooks, necesitamos entender las reglas de React. Rompe estas reglas y tu aplicaciÃ³n FALLARÃ.

### Regla #1: Solo Llama a Hooks en el Nivel Superior

**âŒ EQUIVOCADO: Hook dentro de condiciÃ³n**
```tsx
function CreateCategoryForm() {
  if (someCondition) {
    const [name, setName] = useState('')  // Â¡ERROR!
  }
  
  return <div>{/* ... */}</div>
}
```

**âŒ EQUIVOCADO: Hook dentro de bucle**
```tsx
function CreateCategoryForm() {
  for (let i = 0; i < 3; i++) {
    const [value, setValue] = useState('')  // Â¡ERROR!
  }
  
  return <div>{/* ... */}</div>
}
```

**âŒ EQUIVOCADO: Hook dentro de callback**
```tsx
function CreateCategoryForm() {
  const handleSubmit = () => {
    const [submitted, setSubmitted] = useState(false)  // Â¡ERROR!
  }
  
  return <div>{/* ... */}</div>
}
```

**âœ… CORRECTO: Hook en el nivel superior**
```tsx
function CreateCategoryForm() {
  const [name, setName] = useState('')
  const [description, setDescription] = useState('')
  
  if (someCondition) {
    // Usa el estado aquÃ­ âœ…
    return <div>{name}</div>
  }
  
  return <form>{/* ... */}</form>
}
```

**Por quÃ© existe esta regla:**

React confÃ­a en el **orden** en que se llaman los hooks para rastrear el estado entre renderizados.

```tsx
// Array de estado interno de React
[
  '', // name (useState #1)
  '', // description (useState #2)
  false, // isSubmitting (useState #3)
]
```

React coincide los hooks por **posiciÃ³n**:
```tsx
const [name, setName] = useState('')  // Ranura 0
const [description, setDescription] = useState('')  // Ranura 1
const [isSubmitting, setIsSubmitting] = useState(false)  // Ranura 2
```

**QuÃ© se rompe si usas hooks condicionalmente:**

```tsx
// Renderizado 1:
const [name, setName] = useState('')  // Ranura 0 âœ…
if (true) {
  const [temp, setTemp] = useState('x')  // Ranura 1 âœ…
}
const [description, setDescription] = useState('')  // Ranura 2 âœ…

// Renderizado 2:
const [name, setName] = useState('')  // Ranura 0 âœ…
if (false) {  // Â¡La condiciÃ³n cambiÃ³!
  const [temp, setTemp] = useState('x')  // Ranura 1 Â¡SALTADA! âš ï¸
}
const [description, setDescription] = useState('')  // Ranura 1 âŒ (Â¡era 2!)

// React piensa que description estÃ¡ en la ranura 1 ahora
// Pero la ranura 1 tenÃ­a el valor antiguo de temp
// Â¡El estado estÃ¡ CORRUPTO! ğŸ’¥
```

**Ejemplo visual:**
```
Renderizado 1:     Renderizado 2 (si es falso):
â”Œâ”€â”€â”€â”€â”€â”       â”Œâ”€â”€â”€â”€â”€â”
â”‚ nameâ”‚       â”‚ nameâ”‚ â† Sigue en ranura 0 âœ…
â”œâ”€â”€â”€â”€â”€â”¤       â”œâ”€â”€â”€â”€â”€â”¤
â”‚ tempâ”‚       â”‚ descâ”‚ â† Ahora en ranura 1 (era 2) âŒ
â”œâ”€â”€â”€â”€â”€â”¤       â””â”€â”€â”€â”€â”€â”˜
â”‚ descâ”‚ â† Estaba en ranura 2
â””â”€â”€â”€â”€â”€â”˜

ğŸ”¥ Â¡description obtiene el valor antiguo de temp!
```

### Regla #2: Solo Llama a Hooks desde Funciones de React

**âŒ EQUIVOCADO: Hook en funciÃ³n regular**
```tsx
function validateForm() {
  const [isValid, setIsValid] = useState(true)  // Â¡ERROR!
  return isValid
}

function CreateCategoryForm() {
  const valid = validateForm()  // No funcionarÃ¡
  return <div>{/* ... */}</div>
}
```

**âœ… CORRECTO: Hook en componente de React**
```tsx
function CreateCategoryForm() {
  const [isValid, setIsValid] = useState(true)  // âœ…
  return <div>{/* ... */}</div>
}
```

**âœ… CORRECTO: Hook en hook personalizado**
```tsx
function useFormValidation() {
  const [isValid, setIsValid] = useState(true)  // âœ…
  return { isValid, setIsValid }
}

function CreateCategoryForm() {
  const { isValid } = useFormValidation()  // âœ…
  return <div>{/* ... */}</div>
}
```

**Por quÃ© existe esta regla:**

React rastrea hooks por **instancia de componente**. Las funciones regulares no tienen instancias de componente, asÃ­ que React no puede rastrear sus hooks.

**Solo estos pueden usar hooks:**
- âœ… Componentes de funciÃ³n (`function MyComponent() {}`)
- âœ… Hooks personalizados (`function useMyHook() {}`)

**Estos NO pueden usar hooks:**
- âŒ Funciones regulares de JavaScript
- âŒ MÃ©todos de clase
- âŒ Manejadores de eventos (a menos que estÃ©n dentro de un componente)
- âŒ Callbacks de useEffect (no se pueden anidar hooks)

### CÃ³mo Recordar las Reglas

**Piensa en los hooks como una lista de verificaciÃ³n:**

Cada renderizado, React revisa tu componente lÃ­nea por lÃ­nea:
```
âœ“ Primera llamada useState  â†’ Ranura 0
âœ“ Segunda llamada useState â†’ Ranura 1
âœ“ Primera llamada useEffect â†’ Ranura 2
âœ“ Tercera llamada useState  â†’ Ranura 3
```

Si el orden cambia entre renderizados, React se confunde:
```
âœ“ Primera llamada useState  â†’ Ranura 0 âœ…
âœ— SALTADA (estaba en bloque if)
âœ“ Segunda llamada useState â†’ Ranura 1 âŒ (Â¡era Ranura 2!)
```

**Modelo mental:**
> "Los hooks son como una lista numerada. Cada renderizado debe marcar las mismas casillas en el mismo orden."

### Plugin ESLint: Cumplimiento AutomÃ¡tico

En lugar de recordar reglas, deja que ESLint las haga cumplir:

```bash
npm install eslint-plugin-react-hooks --save-dev
```

```json
// .eslintrc.json
{
  "plugins": ["react-hooks"],
  "rules": {
    "react-hooks/rules-of-hooks": "error",
    "react-hooks/exhaustive-deps": "warn"
  }
}
```

Â¡Ahora ESLint detectarÃ¡ todas las violaciones de hooks en tiempo de compilaciÃ³n!

---

## MÃºltiples Variables de Estado

Los formularios suelen tener mÃºltiples campos. Podemos usar mÃºltiples llamadas `useState`:

```tsx
function CreateCategoryForm() {
  const [name, setName] = useState('')
  const [description, setDescription] = useState('')
  const [parentId, setParentId] = useState<string | null>(null)
  const [isSubmitting, setIsSubmitting] = useState(false)
  const [error, setError] = useState<string | null>(null)
  
  // Ahora tenemos 5 variables de estado separadas
  // Cada una gestiona una pieza de datos
}
```

**O agrupar estado relacionado:**

```tsx
function CreateCategoryForm() {
  const [formData, setFormData] = useState({
    name: '',
    description: '',
    parentId: null as string | null,
  })
  
  const [isSubmitting, setIsSubmitting] = useState(false)
  const [error, setError] = useState<string | null>(null)
  
  // Menos variables de estado, pero necesitas extender al actualizar
  const updateField = (field: string, value: any) => {
    setFormData(prev => ({
      ...prev,
      [field]: value
    }))
  }
}
```

**CuÃ¡ndo usar cuÃ¡l:**
- **MÃºltiples `useState`**: Formularios simples, campos independientes
- **Objeto Ãºnico**: Formularios complejos, campos relacionados, mÃ¡s fÃ¡cil de pasar

---

## Componentes Controlados

Un **componente controlado** es aquel donde React controla el valor del input.

```tsx
// âœ… Controlado: React controla el valor
function Input() {
  const [value, setValue] = useState('')
  
  return (
    <input
      value={value}  // React controla esto
      onChange={(e) => setValue(e.target.value)}
    />
  )
}

// âŒ No controlado: El DOM controla el valor
function Input() {
  const inputRef = useRef<HTMLInputElement>(null)
  
  return (
    <input ref={inputRef} />  // El DOM controla esto
  )
}
```

**Componentes controlados:**
- âœ… FÃ¡cil de validar en tiempo real
- âœ… FÃ¡cil de deshabilitar botÃ³n de envÃ­o
- âœ… FÃ¡cil de resetear formulario
- âœ… FÃ¡cil de probar
- âŒ MÃ¡s verboso (necesita estado + onChange)

**Componentes no controlados:**
- âœ… Menos cÃ³digo
- âœ… Mejor rendimiento (sin re-renderizados en cada pulsaciÃ³n de tecla)
- âŒ MÃ¡s difÃ­cil de validar
- âŒ MÃ¡s difÃ­cil de probar
- âŒ MÃ¡s difÃ­cil de resetear

**Mejor prÃ¡ctica:** Usa componentes controlados para formularios (React Hook Form maneja esto por nosotros).

---

## ValidaciÃ³n de Formularios: La PirÃ¡mide

La validaciÃ³n ocurre en mÃºltiples niveles:

```
        â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
        â”‚  Lado servidor  â”‚ (VerificaciÃ³n final, no se puede confiar en el cliente)
        â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
        â”‚  Respuesta API  â”‚ (Capturar errores del servidor)
        â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
        â”‚  Manejador EnvÃ­oâ”‚ (Antes de enviar a la API)
        â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
        â”‚  Tiempo real    â”‚ (Mientras el usuario escribe)
        â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
        â”‚  HTML5 Nativo   â”‚ (type="email", required, etc.)
        â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

**Cada nivel captura errores diferentes:**
- **HTML5**: Captura errores obvios (vacÃ­o requerido, email invÃ¡lido)
- **Tiempo real**: Captura errores de validaciÃ³n mientras el usuario escribe
- **EnvÃ­o**: VerificaciÃ³n final antes de llamada a API
- **Respuesta API**: Captura errores del lado del servidor (nombre duplicado, permiso denegado)
- **Servidor**: VerificaciÃ³n de seguridad final (no se puede confiar en el cliente)

---

## Zod: ValidaciÃ³n de Esquemas

**Zod** es una librerÃ­a de validaciÃ³n de esquemas primero TypeScript. Valida datos Y genera tipos.

```typescript
// src/features/categories/schemas.ts

import { z } from 'zod'

/**
 * Esquema: Blueprint para datos vÃ¡lidos
 * 
 * Define:
 * - QuÃ© campos existen
 * - QuÃ© tipo es cada campo
 * - Reglas de validaciÃ³n para cada campo
 * - Mensajes de error
 */
export const createCategorySchema = z.object({
  name: z
    .string('El nombre debe ser un string')
    .min(3, 'El nombre debe tener al menos 3 caracteres')
    .max(50, 'El nombre debe tener como mÃ¡ximo 50 caracteres')
    .regex(
      /^[a-zA-Z0-9\s\-]+$/,
      'El nombre solo puede contener letras, nÃºmeros, espacios y guiones'
    ),
  
  description: z
    .string()
    .max(200, 'La descripciÃ³n debe tener como mÃ¡ximo 200 caracteres')
    .optional()
    .or(z.literal('')),  // Permitir cadena vacÃ­a como "no proporcionado"
  
  parentId: z
    .string('El ID del padre debe ser un string')
    .uuid('El ID del padre debe ser un UUID vÃ¡lido')
    .nullable()
    .optional(),
})

/**
 * Generar tipo TypeScript desde esquema
 * 
 * Esto crea un tipo que coincide con el esquema.
 * Si el esquema cambia, el tipo se actualiza automÃ¡ticamente.
 */
export type CreateCategoryInput = z.infer<typeof createCategorySchema>

// TypeScript ahora sabe:
// type CreateCategoryInput = {
//   name: string
//   description?: string
//   parentId?: string | null
// }
```

**Â¿Por quÃ© Zod?**
- âœ… Fuente Ãºnica de verdad (esquema + tipos)
- âœ… ValidaciÃ³n en tiempo de ejecuciÃ³n (detecta datos malos de la API)
- âœ… IntegraciÃ³n TypeScript (autocompletar, seguridad de tipos)
- âœ… Reutilizable en cliente Y servidor
- âœ… Mensajes de error claros

---

## React Hook Form: Formularios de ProducciÃ³n

**React Hook Form** gestiona el estado del formulario eficientemente. Es el estÃ¡ndar de la industria.

```tsx
// src/features/categories/components/CreateCategoryForm.tsx

import { useForm } from 'react-hook-form'
import { zodResolver } from '@hookform/resolvers/zod'
import { createCategorySchema, type CreateCategoryInput } from '../schemas'
import { apiClient } from '@/lib/api-client'
import { toast } from '@/lib/toast'
import type { Category } from '@/types'

interface CreateCategoryFormProps {
  onSuccess: (category: Category) => void
  existingCategories: Category[]
}

/**
 * CreateCategoryForm - Formulario listo para producciÃ³n
 * 
 * Usa React Hook Form para:
 * - GestiÃ³n de estado
 * - ValidaciÃ³n
 * - Manejo de errores
 * - OptimizaciÃ³n de rendimiento
 * 
 * Usa Zod para:
 * - ValidaciÃ³n de esquemas
 * - GeneraciÃ³n de tipos
 * - Mensajes de error
 */
export function CreateCategoryForm({
  onSuccess,
  existingCategories,
}: CreateCategoryFormProps) {
  /**
   * useForm: Inicializar formulario
   * 
   * Devuelve:
   * - register: FunciÃ³n para registrar inputs
   * - handleSubmit: Wrapper para manejador de envÃ­o
   * - formState: Contiene errores, isSubmitting, etc.
   * - reset: Resetear formulario al estado inicial
   * - watch: Observar valores de campos
   * - setValue: Establecer valor de campo programÃ¡ticamente
   */
  const {
    register,
    handleSubmit,
    formState: { errors, isSubmitting },
    reset,
    watch,
  } = useForm<CreateCategoryInput>({
    /**
     * zodResolver: Conectar esquema Zod a React Hook Form
     * 
     * Valida automÃ¡ticamente el formulario contra el esquema.
     * Solo llama a onSubmit si la validaciÃ³n pasa.
     */
    resolver: zodResolver(createCategorySchema),
    
    /**
     * defaultValues: Estado inicial del formulario
     */
    defaultValues: {
      name: '',
      description: '',
      parentId: null,
    },
    
    /**
     * mode: CuÃ¡ndo validar
     * - 'onBlur': Validar cuando el campo pierde foco
     * - 'onChange': Validar en cada pulsaciÃ³n de tecla
     * - 'onSubmit': Solo validar al enviar formulario
     * - 'onTouched': Validar despuÃ©s del primer blur
     */
    mode: 'onBlur',
  })

  /**
   * watch: Obtener valores actuales de campos
   * 
   * Ãštil para:
   * - Mostrar conteo de caracteres
   * - Renderizado condicional
   * - ValidaciÃ³n de campos dependientes
   */
  const nameValue = watch('name')
  const descriptionValue = watch('description')

  /**
   * onSubmit: Manejar envÃ­o de formulario
   * 
   * Â¡Solo llamado si la validaciÃ³n pasa!
   * data ya estÃ¡ validada y tipada.
   */
  const onSubmit = async (data: CreateCategoryInput) => {
    try {
      /**
       * Llamar a API para crear categorÃ­a
       */
      const response = await apiClient.post<Category>('/categories', data)
      
      /**
       * Mostrar mensaje de Ã©xito
       */
      toast.success('Â¡CategorÃ­a creada exitosamente!')
      
      /**
       * Resetear formulario
       */
      reset()
      
      /**
       * Notificar componente padre
       */
      onSuccess(response.data)
    } catch (error) {
      /**
       * Manejar errores de API
       */
      if (error instanceof Error) {
        toast.error(error.message)
      } else {
        toast.error('FallÃ³ crear categorÃ­a')
      }
    }
  }

  return (
    <form onSubmit={handleSubmit(onSubmit)} className="space-y-6">
      {/* Campo Nombre */}
      <div>
        <label
          htmlFor="name"
          className="block text-sm font-medium text-slate-200 mb-2"
        >
          Nombre de CategorÃ­a *
        </label>
        
        <input
          id="name"
          type="text"
          placeholder="ej., DiscusiÃ³n General"
          {...register('name')}
          className={`
            w-full px-4 py-3 bg-slate-900 border rounded-lg text-slate-100
            placeholder-slate-500 focus:outline-none focus:ring-2
            transition-colors
            ${
              errors.name
                ? 'border-red-500 focus:ring-red-500'
                : 'border-slate-700 focus:border-blue-500 focus:ring-blue-500'
            }
          `}
        />
        
        {/* Mensaje de error */}
        {errors.name && (
          <p className="mt-2 text-sm text-red-400">{errors.name.message}</p>
        )}
        
        {/* Conteo de caracteres */}
        <p className="mt-2 text-xs text-slate-500">
          {nameValue?.length || 0} / 50 caracteres
        </p>
      </div>

      {/* Campo DescripciÃ³n */}
      <div>
        <label
          htmlFor="description"
          className="block text-sm font-medium text-slate-200 mb-2"
        >
          DescripciÃ³n (opcional)
        </label>
        
        <textarea
          id="description"
          placeholder="Una breve descripciÃ³n del propÃ³sito de esta categorÃ­a..."
          rows={3}
          {...register('description')}
          className={`
            w-full px-4 py-3 bg-slate-900 border rounded-lg text-slate-100
            placeholder-slate-500 focus:outline-none focus:ring-2
            resize-none transition-colors
            ${
              errors.description
                ? 'border-red-500 focus:ring-red-500'
                : 'border-slate-700 focus:border-blue-500 focus:ring-blue-500'
            }
          `}
        />
        
        {errors.description && (
          <p className="mt-2 text-sm text-red-400">
            {errors.description.message}
          </p>
        )}
        
        <p className="mt-2 text-xs text-slate-500">
          {descriptionValue?.length || 0} / 200 caracteres
        </p>
      </div>

      {/* Selector de CategorÃ­a Padre */}
      <div>
        <label
          htmlFor="parentId"
          className="block text-sm font-medium text-slate-200 mb-2"
        >
          CategorÃ­a Padre (opcional)
        </label>
        
        <select
          id="parentId"
          {...register('parentId')}
          className={`
            w-full px-4 py-3 bg-slate-900 border rounded-lg text-slate-100
            focus:outline-none focus:ring-2 transition-colors
            ${
              errors.parentId
                ? 'border-red-500 focus:ring-red-500'
                : 'border-slate-700 focus:border-blue-500 focus:ring-blue-500'
            }
          `}
        >
          <option value="">Ninguno (CategorÃ­a RaÃ­z)</option>
          
          {/* Solo mostrar categorÃ­as raÃ­z como padres */}
          {existingCategories
            .filter((cat) => cat.parentId === null)
            .map((category) => (
              <option key={category.id} value={category.id}>
                {category.name}
              </option>
            ))}
        </select>
        
        {errors.parentId && (
          <p className="mt-2 text-sm text-red-400">
            {errors.parentId.message}
          </p>
        )}
      </div>

      {/* Acciones del Formulario */}
      <div className="flex gap-3 pt-4">
        <button
          type="button"
          onClick={() => reset()}
          className="px-6 py-3 bg-slate-800 text-slate-200 rounded-lg hover:bg-slate-700 transition-colors font-medium"
        >
          Resetear
        </button>
        
        <button
          type="submit"
          disabled={isSubmitting}
          className={`
            flex-1 px-6 py-3 rounded-lg font-medium transition-colors
            ${
              isSubmitting
                ? 'bg-blue-600/50 text-white cursor-not-allowed'
                : 'bg-blue-600 text-white hover:bg-blue-700'
            }
          `}
        >
          {isSubmitting ? 'Creando...' : 'Crear CategorÃ­a'}
        </button>
      </div>
    </form>
  )
}
```

---

## IntegraciÃ³n de API

```typescript
// src/lib/api-client.ts

import axios from 'axios'

/**
 * Cliente API: Solicitudes HTTP centralizadas
 * 
 * Beneficios:
 * - Lugar Ãºnico para configurar solicitudes
 * - AÃ±adir tokens de auth automÃ¡ticamente
 * - Manejar errores globalmente
 * - LÃ³gica de reintentos
 * - Interceptors de solicitud/respuesta
 */
export const apiClient = axios.create({
  baseURL: import.meta.env.VITE_API_URL || 'http://localhost:3001/api',
  headers: {
    'Content-Type': 'application/json',
  },
})

/**
 * Interceptor de solicitud: AÃ±adir token de auth
 */
apiClient.interceptors.request.use((config) => {
  const token = localStorage.getItem('auth_token')
  if (token) {
    config.headers.Authorization = `Bearer ${token}`
  }
  return config
})

/**
 * Interceptor de respuesta: Manejar errores
 */
apiClient.interceptors.response.use(
  (response) => response,
  (error) => {
    // Manejar 401 No Autorizado
    if (error.response?.status === 401) {
      localStorage.removeItem('auth_token')
      window.location.href = '/sign-in'
    }
    
    // Manejar 403 Prohibido
    if (error.response?.status === 403) {
      error.message = 'No tienes permiso para realizar esta acciÃ³n'
    }
    
    // Manejar 500 Error del Servidor
    if (error.response?.status >= 500) {
      error.message = 'Error del servidor. Por favor intenta mÃ¡s tarde.'
    }
    
    return Promise.reject(error)
  }
)
```

---

## Notificaciones Toast

```typescript
// src/lib/toast.ts

import { toast as hotToast } from 'react-hot-toast'

/**
 * Toast: Notificaciones no bloqueantes
 * 
 * Muestra mensajes temporales al usuario sin bloquear la interacciÃ³n.
 * Perfecto para retroalimentaciÃ³n de Ã©xito/error.
 */
export const toast = {
  success: (message: string) => {
    hotToast.success(message, {
      duration: 3000,
      position: 'top-right',
    })
  },
  
  error: (message: string) => {
    hotToast.error(message, {
      duration: 4000,
      position: 'top-right',
    })
  },
  
  loading: (message: string) => {
    return hotToast.loading(message, {
      position: 'top-right',
    })
  },
}
```

---

## Probando el Formulario

```tsx
// src/features/categories/components/__tests__/CreateCategoryForm.test.tsx

import { render, screen, waitFor } from '@testing-library/react'
import userEvent from '@testing-library/user-event'
import { CreateCategoryForm } from '../CreateCategoryForm'
import { apiClient } from '@/lib/api-client'
import { vi } from 'vitest'

vi.mock('@/lib/api-client')

describe('CreateCategoryForm', () => {
  const mockOnSuccess = vi.fn()
  const mockCategories: Category[] = []

  beforeEach(() => {
    vi.clearAllMocks()
  })

  it('valida campo de nombre requerido', async () => {
    const user = userEvent.setup()
    
    render(
      <CreateCategoryForm
        onSuccess={mockOnSuccess}
        existingCategories={mockCategories}
      />
    )

    // Intentar enviar sin llenar nombre
    const submitButton = screen.getByRole('button', { name: /crear categorÃ­a/i })
    await user.click(submitButton)

    // DeberÃ­a mostrar error de validaciÃ³n
    await waitFor(() => {
      expect(screen.getByText(/el nombre debe tener al menos 3 caracteres/i)).toBeInTheDocument()
    })

    // NO deberÃ­a llamar a la API
    expect(apiClient.post).not.toHaveBeenCalled()
  })

  it('envÃ­a datos de formulario vÃ¡lidos', async () => {
    const user = userEvent.setup()
    const mockResponse = {
      data: {
        id: '01HXQK9Z3XAMPLE000001',
        name: 'CategorÃ­a de Prueba',
        slug: 'categoria-de-prueba',
        description: 'DescripciÃ³n de prueba',
        parentId: null,
        order: 1,
        threadCount: 0,
        createdAt: '2024-01-15T10:00:00Z',
        updatedAt: '2024-01-15T10:00:00Z',
      },
    }
    
    vi.mocked(apiClient.post).mockResolvedValueOnce(mockResponse)

    render(
      <CreateCategoryForm
        onSuccess={mockOnSuccess}
        existingCategories={mockCategories}
      />
    )

    // Llenar formulario
    await user.type(screen.getByLabelText(/nombre de categorÃ­a/i), 'CategorÃ­a de Prueba')
    await user.type(screen.getByLabelText(/descripciÃ³n/i), 'DescripciÃ³n de prueba')

    // Enviar
    await user.click(screen.getByRole('button', { name: /crear categorÃ­a/i }))

    // Verificar llamada a API
    await waitFor(() => {
      expect(apiClient.post).toHaveBeenCalledWith('/categories', {
        name: 'CategorÃ­a de Prueba',
        description: 'DescripciÃ³n de prueba',
        parentId: null,
      })
    })

    // Verificar callback de Ã©xito
    expect(mockOnSuccess).toHaveBeenCalledWith(mockResponse.data)
  })
})
```

---

## Resumen

### Conceptos Clave Aprendidos

1. **useState**: AÃ±adir memoria a componentes de funciÃ³n
   - Devuelve `[valor, setter]`
   - El setter activa re-renderizado
   - El estado persiste entre renderizados

2. **Componentes Controlados**: React controla el valor del input
   ```tsx
   <input value={state} onChange={(e) => setState(e.target.value)} />
   ```

3. **PirÃ¡mide de ValidaciÃ³n**: MÃºltiples niveles de validaciÃ³n
   - HTML5 nativo
   - Tiempo real
   - Manejador de envÃ­o
   - Respuesta de API
   - Lado del servidor

4. **Esquemas Zod**: Fuente Ãºnica de verdad
   ```tsx
   const schema = z.object({ /* ... */ })
   type Data = z.infer<typeof schema>
   ```

5. **React Hook Form**: GestiÃ³n de formularios de producciÃ³n
   - GestiÃ³n de estado eficiente
   - ValidaciÃ³n incorporada
   - Manejo de errores
   - Optimizado para rendimiento

### Mejores PrÃ¡cticas

- âœ… Usa componentes controlados para formularios
- âœ… Valida en mÃºltiples niveles
- âœ… Muestra mensajes de error claros
- âœ… Proporciona estados de carga
- âœ… Usa React Hook Form para formularios complejos
- âœ… Usa Zod para validaciÃ³n de esquemas
- âœ… Prueba validaciÃ³n y envÃ­o de formularios
- âœ… Proporciona retroalimentaciÃ³n de Ã©xito/error

### Victorias de TypeScript

```tsx
// Fuente Ãºnica de verdad
const schema = z.object({ name: z.string() })
type FormData = z.infer<typeof schema>

// TypeScript sabe la forma de FormData
const onSubmit = (data: FormData) => {
  // data.name es definitivamente un string!
}
```

---

Siguiente: [Editar CategorÃ­a â†’](/es/react/4.categories-module/3.edit-category)
