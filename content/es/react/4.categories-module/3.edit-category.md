---
title: Editar Categoría - Efectos Secundarios y Obtención de Datos
description: Domina useEffect para obtención de datos, estados de carga y actualizaciones optimistas de UI. Aprende el array de dependencias, funciones de limpieza y patrones asíncronos.
---

# Disclaimer

:::u-alert
---
title: Los comentarios en el código son solo educativos.
description: En proyectos reales, evita comentarios irrelevantes o redundantes.
color: warning
variant: subtle
icon: i-lucide-triangle-alert
---
:::

Editar requiere obtener datos existentes, completar formularios y manejar actualizaciones. Esto introduce **useEffect** - el hook de React para efectos secundarios - uno de los conceptos más importantes para dominar.

---

## ¿Qué es Diferente de Crear?

| Aspecto | Crear | Editar |
|---------|-------|--------|
| Método HTTP | POST | PUT |
| Valores Iniciales | Vacíos | Obtener de API |
| Ruta | `/categories/new` | `/categories/:id/edit` |
| Flujo de Datos | Entrada de usuario → API | API → Formulario → API |
| Después del Éxito | Navegar a lista | Navegar a detalle |

---

## useEffect: Efectos Secundarios en React

### El Problema: Funciones Puras

Los componentes de React son **funciones puras**:
```
Entrada (props) → Componente → Salida (JSX)
```

**Regla de función pura:** La misma entrada siempre produce la misma salida.

```tsx
// ✅ Pura: Mismas props = mismo JSX
function CategoryCard({ category }) {
  return <div>{category.name}</div>
}

// ❌ Impura: Efectos secundarios (llamadas a API, mutaciones)
function CategoryCard({ category }) {
  fetch('/api/categories/' + category.id)  // ¡Efecto secundario!
  return <div>{category.name}</div>
}
```

**Problemas con efectos secundarios en renderizado:**
- Se ejecuta en CADA renderizado (desperdiciado)
- No se puede usar async/await (el renderizado debe ser síncrono)
- Causa bucles infinitos
- Difícil de depurar

### La Solución: useEffect

`useEffect` nos permite ejecutar efectos secundarios **DESPUÉS** del renderizado, no durante.

```tsx
import { useEffect } from 'react'

function CategoryDetail() {
  const [category, setCategory] = useState(null)

  /**
   * useEffect: Ejecutar efectos secundarios después del renderizado
   * 
   * Firma: useEffect(configuración, dependencias?)
   * 
   * - configuración: Función que se ejecuta después del renderizado
   * - dependencias: Array de valores a observar
   */
  useEffect(() => {
    // Esto se ejecuta DESPUÉS de que el componente renderiza
    // Es seguro usar async/await aquí
    fetch('/api/categories/1')
      .then(res => res.json())
      .then(data => setCategory(data))
  }, [])  // Array de dependencias vacío = ejecutar una vez en montaje

  return <div>{category?.name}</div>
}
```

### Línea de Tiempo de Ejecución

```
El componente renderiza
  ↓
El navegador pinta en pantalla
  ↓
useEffect se ejecuta (efectos secundarios)
  ↓
setState llamado
  ↓
El componente vuelve a renderizar
  ↓
El navegador pinta de nuevo
  ↓
useEffect se ejecuta de nuevo (si las dependencias cambiaron)
```

### El Array de Dependencias

El array de dependencias controla **CUÁNDO** se ejecuta el efecto:

```tsx
// ❌ Sin array de dependencias: Se ejecuta después de CADA renderizado
useEffect(() => {
  fetch('/api/categories')  // ¡Llamadas infinitas a la API!
})

// ✅ Array vacío: Se ejecuta una vez en montaje
useEffect(() => {
  fetch('/api/categories')  // Se ejecuta una vez
}, [])

// ✅ Con dependencias: Se ejecuta cuando las dependencias cambian
useEffect(() => {
  fetch(`/api/categories/${id}`)  // Se ejecuta cuando id cambia
}, [id])

// ✅ Múltiples dependencias
useEffect(() => {
  fetch(`/api/categories/${id}?sort=${sort}`)
}, [id, sort])  // Se ejecuta cuando id O sort cambia
```

**Regla:** Incluye TODAS las variables del ámbito externo que el efecto usa:

```tsx
// ❌ Dependencia faltante
function CategoryDetail({ categoryId }) {
  useEffect(() => {
    fetch(`/api/categories/${categoryId}`)  // Usa categoryId
  }, [])  // ¡Pero categoryId no está en las dependencias!
  // Si categoryId cambia, el efecto no se vuelve a ejecutar
  // ¡Datos obsoletos!
}

// ✅ Correcto
function CategoryDetail({ categoryId }) {
  useEffect(() => {
    fetch(`/api/categories/${categoryId}`)
  }, [categoryId])  // Incluir categoryId
  // Si categoryId cambia, el efecto se vuelve a ejecutar
}
```

### Función de Limpieza

Los efectos pueden devolver una función de limpieza que se ejecuta:
- Antes de que el efecto se ejecute de nuevo
- Cuando el componente se desmonta

```tsx
useEffect(() => {
  // Configuración
  const timer = setTimeout(() => {
    console.log('Hola')
  }, 1000)

  // Limpieza: Devolver una función
  return () => {
    clearTimeout(timer)  // Cancelar timer si el componente se desmonta
  }
}, [])
```

**Por qué importa la limpieza:**

```tsx
// ❌ Sin limpieza: Fuga de memoria
function SearchResults({ query }) {
  useEffect(() => {
    const controller = new AbortController()
    
    fetch(`/api/search?q=${query}`, {
      signal: controller.signal
    })
    .then(res => res.json())
    .then(data => setResults(data))
    
    // Si el componente se desmonta, la solicitud aún se completa
    // setState llamado en componente desmontado = advertencia
  }, [query])
}

// ✅ Con limpieza: Cancelar solicitud
function SearchResults({ query }) {
  useEffect(() => {
    const controller = new AbortController()
    
    fetch(`/api/search?q=${query}`, {
      signal: controller.signal
    })
    .then(res => res.json())
    .then(data => setResults(data))
    
    // Limpieza: Abortar solicitud si el componente se desmonta
    return () => controller.abort()
  }, [query])
}
```

---

## Página de Editar Categoría

```tsx
// src/pages/EditCategoryPage.tsx

import { useState, useEffect } from 'react'
import { useParams, useNavigate } from 'react-router-dom'
import { EditCategoryForm } from '@/features/categories/components/EditCategoryForm'
import { apiClient } from '@/lib/api-client'
import type { Category } from '@/types'

export function EditCategoryPage() {
  const { id } = useParams<{ id: string }>()
  const navigate = useNavigate()
  
  const [category, setCategory] = useState<Category | null>(null)
  const [isLoading, setIsLoading] = useState(true)
  const [error, setError] = useState<string | null>(null)

  /**
   * Obtener datos de categoría cuando el componente se monta o el id cambia
   */
  useEffect(() => {
    async function fetchCategory() {
      try {
        setIsLoading(true)
        setError(null)
        
        const response = await apiClient.get<Category>(`/categories/${id}`)
        setCategory(response.data)
      } catch (err) {
        setError(err instanceof Error ? err.message : 'Falló cargar categoría')
      } finally {
        setIsLoading(false)
      }
    }

    fetchCategory()
  }, [id])

  const handleSuccess = (updatedCategory: Category) => {
    navigate(`/categories/${updatedCategory.slug}`)
  }

  if (isLoading) {
    return <div className="p-8 text-center">Cargando...</div>
  }

  if (error || !category) {
    return (
      <div className="p-8 text-center text-red-400">
        {error || 'Categoría no encontrada'}
      </div>
    )
  }

  return (
    <div className="container mx-auto px-4 py-8 max-w-2xl">
      <h1 className="text-3xl font-bold mb-2">Editar Categoría</h1>
      <p className="text-slate-400 mb-6">Actualizar detalles de "{category.name}"</p>
      
      <div className="bg-slate-900 rounded-lg border border-slate-800 p-6">
        <EditCategoryForm
          category={category}
          onSuccess={handleSuccess}
        />
      </div>
    </div>
  )
}
```

---

## Componente de Formulario de Edición

```tsx
// src/features/categories/components/EditCategoryForm.tsx

import { useForm } from 'react-hook-form'
import { zodResolver } from '@hookform/resolvers/zod'
import { createCategorySchema, type CreateCategoryInput } from '../schemas'
import { apiClient } from '@/lib/api-client'
import { toast } from '@/lib/toast'
import type { Category } from '@/types'

interface EditCategoryFormProps {
  category: Category
  onSuccess: (category: Category) => void
}

export function EditCategoryForm({ category, onSuccess }: EditCategoryFormProps) {
  const {
    register,
    handleSubmit,
    formState: { errors, isSubmitting },
  } = useForm<CreateCategoryInput>({
    resolver: zodResolver(createCategorySchema),
    
    /**
     * defaultValues: Completar formulario con datos existentes
     * 
     * Esta es la diferencia clave del formulario de creación.
     * El formulario comienza con valores existentes en lugar de vacíos.
     */
    defaultValues: {
      name: category.name,
      description: category.description || '',
      parentId: category.parentId,
    },
  })

  const onSubmit = async (data: CreateCategoryInput) => {
    try {
      /**
       * Solicitud PUT para actualizar recurso existente
       * 
       * La URL incluye el ID de la categoría
       */
      const response = await apiClient.put<Category>(
        `/categories/${category.id}`,
        data
      )

      toast.success('¡Categoría actualizada exitosamente!')
      onSuccess(response.data)
    } catch (error) {
      toast.error(error instanceof Error ? error.message : 'Falló actualizar categoría')
    }
  }

  return (
    <form onSubmit={handleSubmit(onSubmit)} className="space-y-6">
      <div>
        <label htmlFor="name" className="block text-sm font-medium text-slate-200 mb-2">
          Nombre de Categoría *
        </label>
        <input
          id="name"
          type="text"
          {...register('name')}
          className="w-full px-4 py-3 bg-slate-900 border border-slate-700 rounded-lg text-slate-100 focus:border-blue-500 focus:ring-1 focus:ring-blue-500"
        />
        {errors.name && (
          <p className="mt-2 text-sm text-red-400">{errors.name.message}</p>
        )}
      </div>

      <div>
        <label htmlFor="description" className="block text-sm font-medium text-slate-200 mb-2">
          Descripción
        </label>
        <textarea
          id="description"
          rows={3}
          {...register('description')}
          className="w-full px-4 py-3 bg-slate-900 border border-slate-700 rounded-lg text-slate-100 focus:border-blue-500 focus:ring-1 focus:ring-blue-500"
        />
        {errors.description && (
          <p className="mt-2 text-sm text-red-400">{errors.description.message}</p>
        )}
      </div>

      <div className="flex gap-3">
        <button
          type="submit"
          disabled={isSubmitting}
          className="flex-1 px-6 py-3 bg-blue-600 text-white rounded-lg hover:bg-blue-700 disabled:opacity-50"
        >
          {isSubmitting ? 'Actualizando...' : 'Actualizar Categoría'}
        </button>
      </div>
    </form>
  )
}
```

---

## Actualizaciones Optimistas

Para mejor UX, actualiza la UI inmediatamente antes de que la API responda:

```tsx
export function useCategoryUpdate() {
  const queryClient = useQueryClient()

  return useMutation({
    mutationFn: async ({ id, data }: { id: string; data: CreateCategoryInput }) => {
      return apiClient.put<Category>(`/categories/${id}`, data)
    },
    
    /**
     * onMutate: Se ejecuta ANTES de la solicitud
     * 
     * 1. Guardar estado actual (para rollback)
     * 2. Actualizar UI optimistamente
     */
    onMutate: async ({ id, data }) => {
      await queryClient.cancelQueries({ queryKey: ['categories', id] })

      const previous = queryClient.getQueryData<Category>(['categories', id])

      if (previous) {
        queryClient.setQueryData<Category>(['categories', id], {
          ...previous,
          ...data,
        })
      }

      return { previous }
    },

    /**
     * onError: Rollback en caso de fallo
     */
    onError: (err, variables, context) => {
      if (context?.previous) {
        queryClient.setQueryData(['categories', variables.id], context.previous)
      }
      toast.error('Falló actualizar categoría')
    },

    onSuccess: (response) => {
      queryClient.setQueryData(['categories', response.data.id], response.data)
      toast.success('¡Categoría actualizada!')
    },
  })
}
```

---

## Resumen

### Conceptos Clave

1. **useEffect**: Ejecutar efectos secundarios después del renderizado
   - `[]` = ejecutar una vez en montaje
   - `[dep]` = ejecutar cuando dep cambia
   - Devolver función de limpieza

2. **Array de Dependencias**: Controla cuándo se ejecuta el efecto
   - Incluir TODAS las variables del ámbito externo
   - Dependencias faltantes = datos obsoletos

3. **Limpieza**: Cancelar solicitudes en desmontaje
   - Prevenir fugas de memoria
   - Prevenir advertencias de setState

4. **Actualizaciones Optimistas**: Actualizar UI antes de que la API responda
   - Mejor rendimiento percibido
   - Rollback en caso de error

### Mejores Prácticas

- ✅ Siempre incluir dependencias
- ✅ Usar funciones de limpieza para operaciones asíncronas
- ✅ Usar AbortController para solicitudes fetch
- ✅ Mostrar estados de carga
- ✅ Manejar errores elegantemente
- ✅ Implementar actualizaciones optimistas para mutaciones

---

Siguiente: [Eliminar Categoría →](/es/react/4.categories-module/4.delete-category)
