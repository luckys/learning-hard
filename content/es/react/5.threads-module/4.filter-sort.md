---
title: Filtrar y Ordenar Hilos
description: Domina el estado derivado, persistencia en URL y patrones de minimizaci√≥n de estado para filtrar y ordenar.
---

# Disclaimer

:::u-alert
---
title: Los comentarios en el c√≥digo son solo educativos.
description: En proyectos reales, evita comentarios irrelevantes o redundantes.
color: warning
variant: subtle
icon: i-lucide-triangle-alert
---
:::

Los usuarios necesitan filtrar hilos (por categor√≠a, autor) y ordenarlos (recientes, populares). Implementaremos esto usando **estado derivado** - calcular valores del estado existente en lugar de almacenar duplicados.

---

## El Problema: Estado Redundante

**‚ùå Error com√∫n: Almacenar resultados filtrados en estado**

```tsx
function ThreadsPage() {
  const [threads, setThreads] = useState<Thread[]>([])
  const [filteredThreads, setFilteredThreads] = useState<Thread[]>([])  // ‚ùå ¬°Redundante!
  const [filter, setFilter] = useState('all')

  useEffect(() => {
    // Tengo que mantener filteredThreads sincronizado manualmente
    const filtered = threads.filter(/* ... */)
    setFilteredThreads(filtered)
  }, [threads, filter])

  // ¬øQu√© pasa si los hilos se actualizan desde otro lugar?
  // ¬°filteredThreads podr√≠a estar desactualizado!
}
```

**Problemas:**
- Dos fuentes de verdad (`threads` y `filteredThreads`)
- F√°cil de desincronizar
- Re-renders extra
- M√°s uso de memoria

---

## La Soluci√≥n: Estado Derivado

**‚úÖ Calcular en cada render**

```tsx
function ThreadsPage() {
  const [threads, setThreads] = useState<Thread[]>([])
  const [filter, setFilter] = useState('all')

  // Derivado: siempre sincronizado con threads y filter
  const filteredThreads = threads.filter(/* ... */)
  
  // ¬°No se necesita useEffect!
  // ¬°Sin riesgo de datos desactualizados!
}
```

**¬øPor qu√© funciona esto:**
- √önica fuente de verdad (`threads`)
- Siempre actualizado (recalcula en cada render)
- Menos c√≥digo
- Menos errores

**"¬øPero no es caro recalcular?"**

Para la mayor√≠a de los casos, ¬°no! Filtrar/ordenar arrays con cientos de elementos es r√°pido (<1ms). Si se vuelve lento, usa `useMemo` (lo cubriremos m√°s tarde).

---

## Tipos de Filtros

```typescript
// src/types/filters.ts

export type ThreadFilter = 
  | 'all'           // Todos los hilos
  | 'my'            // Hilos que cre√©
  | 'following'     // Hilos que sigo
  | 'unanswered'    // Hilos sin respuestas
  | 'solved'        // Hilos marcados como resueltos

export type ThreadSort = 
  | 'recent'        // M√°s nuevos primero
  | 'popular'       // M√°s vistas
  | 'trending'      // M√°s respuestas en √∫ltimas 24h
  | 'unanswered'    // M√°s antiguos sin responder primero
```

---

## P√°gina de Hilos con Filtros

```tsx
// src/pages/ThreadsPage.tsx

import { useState, useEffect } from 'react'
import { useAuth } from '@/features/auth/hooks/useAuth'
import { ThreadFilters } from '@/components/threads/ThreadFilters'
import { ThreadSortDropdown } from '@/components/threads/ThreadSortDropdown'
import { ThreadList } from '@/components/threads/ThreadList'
import { apiClient } from '@/lib/api-client'
import type { Thread, ThreadFilter, ThreadSort } from '@/types'

export function ThreadsPage() {
  const { user } = useAuth()
  
  /**
   * Estado fuente: hilos de la API
   */
  const [threads, setThreads] = useState<Thread[]>([])
  const [isLoading, setIsLoading] = useState(true)
  
  /**
   * Estado UI: filtro y orden actual
   * 
   * Estas son las √öNICAS cosas que almacenamos en estado
   * Todo lo dem√°s es derivado
   */
  const [activeFilter, setActiveFilter] = useState<ThreadFilter>('all')
  const [activeSort, setActiveSort] = useState<ThreadSort>('recent')

  /**
   * Obtener hilos al montar
   */
  useEffect(() => {
    async function fetchThreads() {
      try {
        const response = await apiClient.get<{ data: Thread[] }>('/threads')
        setThreads(response.data.data)
      } catch (error) {
        console.error('Fall√≥ obtener hilos:', error)
      } finally {
        setIsLoading(false)
      }
    }

    fetchThreads()
  }, [])

  /**
   * ESTADO DERIVADO: Filtrar hilos
   * 
   * ¬øPor qu√© derivado?
   * - Siempre sincronizado con los datos fuente
   * - No se necesita useEffect
   * - √önica fuente de verdad
   * 
   * Esto recalcula en cada render, pero es r√°pido
   */
  const filteredThreads = threads.filter((thread) => {
    switch (activeFilter) {
      case 'all':
        return true
      
      case 'my':
        // Solo hilos que cre√©
        return user && thread.authorId === user.id
      
      case 'following':
        // Solo hilos que sigo (necesitar√≠a datos de following)
        return thread.isFollowing === true
      
      case 'unanswered':
        // Hilos sin respuestas
        return thread.replyCount === 0
      
      case 'solved':
        // Hilos marcados como resueltos
        return thread.isSolved === true
      
      default:
        return true
    }
  })

  /**
   * ESTADO DERIVADO: Ordenar hilos filtrados
   * 
   * ¬øPor qu√© crear una copia con [...filteredThreads]?
   * - .sort() muta el array
   * - No queremos mutar filteredThreads
   * - Spread crea una copia superficial
   */
  const sortedThreads = [...filteredThreads].sort((a, b) => {
    switch (activeSort) {
      case 'recent':
        // M√°s nuevos primero
        return new Date(b.createdAt).getTime() - new Date(a.createdAt).getTime()
      
      case 'popular':
        // M√°s vistas primero
        return b.viewCount - a.viewCount
      
      case 'trending':
        // M√°s respuestas en √∫ltimas 24h
        // (En app real, filtrar√≠a por fecha)
        return b.replyCount - a.replyCount
      
      case 'unanswered':
        // M√°s antiguos sin responder primero
        if (a.replyCount === 0 && b.replyCount > 0) return -1
        if (b.replyCount === 0 && a.replyCount > 0) return 1
        return new Date(a.createdAt).getTime() - new Date(b.createdAt).getTime()
      
      default:
        return 0
    }
  })

  if (isLoading) {
    return <ThreadListSkeleton />
  }

  return (
    <div className="container mx-auto px-4 py-8">
      {/* Encabezado */}
      <div className="flex items-center justify-between mb-6">
        <h1 className="text-3xl font-bold text-slate-100">
          Hilos del Foro
        </h1>
        
        <Link
          to="/threads/new"
          className="px-4 py-2 bg-blue-600 text-white rounded-md hover:bg-blue-700"
        >
          Nuevo Hilo
        </Link>
      </div>

      {/* Filtros y Orden */}
      <div className="flex items-center justify-between mb-6 gap-4">
        <ThreadFilters
          active={activeFilter}
          onChange={setActiveFilter}
        />
        
        <ThreadSortDropdown
          active={activeSort}
          onChange={setActiveSort}
        />
      </div>

      {/* Conteo de resultados */}
      <p className="text-sm text-slate-400 mb-4">
        Mostrando {sortedThreads.length} de {threads.length} hilos
      </p>

      {/* Lista de hilos */}
      <ThreadList threads={sortedThreads} />

      {/* Estado vac√≠o */}
      {sortedThreads.length === 0 && (
        <div className="text-center py-12 bg-slate-900 rounded-lg border border-slate-800">
          <p className="text-slate-400">
            No hay hilos que coincidan con tus filtros
          </p>
          <button
            onClick={() => {
              setActiveFilter('all')
              setActiveSort('recent')
            }}
            className="mt-4 px-4 py-2 bg-slate-800 text-slate-200 rounded-md hover:bg-slate-700"
          >
            Limpiar Filtros
          </button>
        </div>
      )}
    </div>
  )
}
```

---

## Componente de Filtros de Hilos

```tsx
// src/components/threads/ThreadFilters.tsx

import type { ThreadFilter } from '@/types'

interface ThreadFiltersProps {
  active: ThreadFilter
  onChange: (filter: ThreadFilter) => void
}

/**
 * Botones de filtro para hilos
 * 
 * Este es un "componente controlado":
 * - El padre posee el estado (activeFilter)
 * - El padre pasa el valor actual y el manejador de cambios
 * - Este componente solo renderiza y llama a onChange
 * 
 * Beneficios:
 * - El estado puede sincronizarse con URL
 * - F√°cil de probar (sin estado interno)
 * - M√∫ltiples componentes pueden compartir el mismo estado
 */
export function ThreadFilters({ active, onChange }: ThreadFiltersProps) {
  /**
   * Definiciones de filtros
   * 
   * Renderizado impulsado por datos: mapear sobre array en lugar de codificar botones
   */
  const filters: { value: ThreadFilter; label: string; icon: string }[] = [
    { value: 'all', label: 'Todos los Hilos', icon: 'üìö' },
    { value: 'my', label: 'Mis Hilos', icon: '‚úèÔ∏è' },
    { value: 'following', label: 'Siguiendo', icon: '‚≠ê' },
    { value: 'unanswered', label: 'Sin Responder', icon: '‚ùì' },
    { value: 'solved', label: 'Resueltos', icon: '‚úÖ' },
  ]

  return (
    <div className="flex gap-2 flex-wrap">
      {filters.map((filter) => (
        <button
          key={filter.value}
          onClick={() => onChange(filter.value)}
          className={`
            px-4 py-2 rounded-lg font-medium transition-colors
            flex items-center gap-2
            ${
              active === filter.value
                ? 'bg-blue-600 text-white'
                : 'bg-slate-800 text-slate-300 hover:bg-slate-700'
            }
          `}
        >
          <span>{filter.icon}</span>
          <span>{filter.label}</span>
        </button>
      ))}
    </div>
  )
}
```

---

## Dropdown de Orden de Hilos

```tsx
// src/components/threads/ThreadSortDropdown.tsx

import type { ThreadSort } from '@/types'

interface ThreadSortDropdownProps {
  active: ThreadSort
  onChange: (sort: ThreadSort) => void
}

export function ThreadSortDropdown({ active, onChange }: ThreadSortDropdownProps) {
  const sortOptions: { value: ThreadSort; label: string }[] = [
    { value: 'recent', label: 'M√°s Recientes' },
    { value: 'popular', label: 'M√°s Populares' },
    { value: 'trending', label: 'Tendencias' },
    { value: 'unanswered', label: 'M√°s Antiguos sin Responder' },
  ]

  return (
    <div className="flex items-center gap-2">
      <span className="text-sm text-slate-400">Ordenar por:</span>
      <select
        value={active}
        onChange={(e) => onChange(e.target.value as ThreadSort)}
        className="px-3 py-2 bg-slate-800 border border-slate-700 rounded-md text-slate-200 focus:border-blue-500"
      >
        {sortOptions.map((option) => (
          <option key={option.value} value={option.value}>
            {option.label}
          </option>
        ))}
      </select>
    </div>
  )
}
```

---

## Persistencia de Estado en URL

Los usuarios esperan que los filtros persistan al compartir enlaces o actualizar. Almacenar filtro/orden en URL.

```tsx
import { useSearchParams } from 'react-router-dom'

export function ThreadsPage() {
  const [searchParams, setSearchParams] = useSearchParams()
  const { user } = useAuth()
  
  /**
   * Obtener filtro/orden de URL, con fallbacks
   * 
   * URL: /threads?filter=my&sort=popular
   * searchParams.get('filter') devuelve 'my'
   */
  const activeFilter = (searchParams.get('filter') as ThreadFilter) || 'all'
  const activeSort = (searchParams.get('sort') as ThreadSort) || 'recent'

  /**
   * Actualizar URL cuando cambia filtro/orden
   */
  const handleFilterChange = (filter: ThreadFilter) => {
    setSearchParams({
      filter,
      sort: activeSort,
    })
  }

  const handleSortChange = (sort: ThreadSort) => {
    setSearchParams({
      filter: activeFilter,
      sort,
    })
  }

  // El resto del componente usa activeFilter y activeSort de URL
  // ...
}
```

**Beneficios:**
- Se puede marcar como favorito: `/threads?filter=my&sort=popular`
- Compartible: Enviar enlace a amigo con tus filtros
- El bot√≥n atr√°s funciona: El historial del navegador rastrea cambios de filtro
- La actualizaci√≥n preserva el estado

---

## Rendimiento: Cu√°ndo Usar useMemo

**Regla: ¬°No optimices prematuramente!**

Filtrar/ordenar usualmente es lo suficientemente r√°pido sin memoizaci√≥n. Pero si tienes miles de hilos:

```tsx
import { useMemo } from 'react'

export function ThreadsPage() {
  const [threads, setThreads] = useState<Thread[]>([])
  const [activeFilter, setActiveFilter] = useState('all')
  const [activeSort, setActiveSort] = useState('recent')

  /**
   * useMemo: Cachear c√°lculo costoso
   * 
   * Solo recalcular cuando cambian las dependencias
   */
  const sortedThreads = useMemo(() => {
    // Filtrar
    const filtered = threads.filter((thread) => {
      // ... l√≥gica de filtrado
    })

    // Ordenar
    return [...filtered].sort((a, b) => {
      // ... l√≥gica de ordenamiento
    })
  }, [threads, activeFilter, activeSort])  // Dependencias

  // sortedThreads est√° cacheado entre renders
  // Solo recalcula cuando threads, activeFilter, o activeSort cambian
}
```

### Deep Dive de useMemo

**Sin useMemo:**
```tsx
// Recalcula EN CADA render
const sortedThreads = threads.filter(...).sort(...)

// Incluso si solo pasas el cursor sobre un bot√≥n ‚Üí re-render ‚Üí recalcular
```

**Con useMemo:**
```tsx
// Recalcula SOLO cuando cambian las dependencias
const sortedThreads = useMemo(() => {
  return threads.filter(...).sort(...)
}, [threads, activeFilter, activeSort])
```

**Cu√°ndo usar useMemo:**
- ‚úÖ C√°lculos costosos (ordenar 10,000 elementos)
- ‚úÖ Crear objetos/arrays pasados a hijos (previene re-renders)
- ‚úÖ Has medido y realmente es lento

**Cu√°ndo NO usar:**
- ‚ùå C√°lculos baratos (sumar n√∫meros, acceder propiedades)
- ‚ùå Optimizaci√≥n prematura (¬°mide primero!)
- ‚ùå Cada c√°lculo "por si acaso"

---

## Filtro de Categor√≠a

A√±adir filtrado espec√≠fico de categor√≠a.

```tsx
export function ThreadsPage() {
  const { categorySlug } = useParams<{ categorySlug?: string }>()
  const [threads, setThreads] = useState<Thread[]>([])
  const [activeFilter, setActiveFilter] = useState<ThreadFilter>('all')
  const [activeSort, setActiveSort] = useState<ThreadSort>('recent')

  /**
   * Filtrar por categor√≠a si categorySlug existe
   * 
   * URL: /categories/soporte-tecnico/threads
   */
  const filteredThreads = threads
    .filter((thread) => {
      // Primero: filtrar por categor√≠a si categorySlug existe
      if (categorySlug && thread.category.slug !== categorySlug) {
        return false
      }

      // Luego: aplicar filtro seleccionado por usuario
      switch (activeFilter) {
        case 'all':
          return true
        case 'my':
          return user && thread.authorId === user.id
        // ... otros filtros
        default:
          return true
      }
    })
    .sort((a, b) => {
      // ... l√≥gica de ordenamiento
    })

  return (
    <div>
      {categorySlug && (
        <div className="mb-4">
          <Link to="/threads" className="text-blue-400 hover:text-blue-300">
            ‚Üê Todas las Categor√≠as
          </Link>
        </div>
      )}
      
      <ThreadList threads={filteredThreads} />
    </div>
  )
}
```

---

## Resumen

### Conceptos Clave

1. **Estado Derivado**: Calcular del estado existente, no almacenar duplicados
   ```tsx
   const filtered = threads.filter(...)  // ‚úÖ Derivado
   const [filtered, setFiltered] = useState([])  // ‚ùå Redundante
   ```

2. **Componentes Controlados**: El padre posee el estado, el hijo solo renderiza
   ```tsx
   <ThreadFilters active={filter} onChange={setFilter} />
   ```

3. **Estado URL**: Persistir filtros en URL para marcadores/compartir
   ```tsx
   const [searchParams, setSearchParams] = useSearchParams()
   ```

4. **useMemo**: Cachear c√°lculos costosos
   ```tsx
   const sorted = useMemo(() => expensive(), [deps])
   ```

5. **Inmutabilidad de Arrays**: Copiar antes de ordenar
   ```tsx
   [...array].sort()  // ‚úÖ Crea copia
   array.sort()  // ‚ùå Muta original
   ```

### Mejores Pr√°cticas

- ‚úÖ Mantener el estado m√≠nimo (almacenar filtro/orden, derivar resultados)
- ‚úÖ Persistir estado UI en URL cuando sea apropiado
- ‚úÖ Usar componentes controlados para estado compartido
- ‚úÖ No optimizar prematuramente (¬°mide primero!)
- ‚úÖ Copiar arrays antes de ordenar/mutar

---

Siguiente: [Buscar Hilos ‚Üí](/es/react/5.threads-module/5.search)
