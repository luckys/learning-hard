---
title: Buscar Hilos
description: Domina useDebounce, AbortController y manejo de condiciones de carrera para b√∫squeda en tiempo real con alto rendimiento.
---

# Disclaimer

:::u-alert
---
title: Los comentarios en el c√≥digo son solo educativos.
description: En proyectos reales, evita comentarios irrelevantes o redundantes.
color: warning
variant: subtle
icon: i-lucide-triangle-alert
---
:::

La b√∫squeda es complicada: necesitamos equilibrar capacidad de respuesta (retroalimentaci√≥n instant√°nea) con rendimiento (no spamear la API). Usaremos **debouncing** y **cancelaci√≥n de solicitudes** para resolver esto.

---

## El Problema: Demasiadas Solicitudes

**‚ùå Enfoque ingenuo:**

```tsx
function SearchThreads() {
  const [query, setQuery] = useState('')
  const [results, setResults] = useState<Thread[]>([])

  useEffect(() => {
    if (query) {
      // ¬°Se dispara en CADA pulsaci√≥n de tecla!
      apiClient.get(`/search?q=${query}`)
        .then(res => setResults(res.data))
    }
  }, [query])

  return (
    <input
      value={query}
      onChange={(e) => setQuery(e.target.value)}
    />
  )
}
```

**¬øQu√© pasa cuando el usuario escribe "react":**
- Escribe "r" ‚Üí Llamada API 1
- Escribe "re" ‚Üí Llamada API 2
- Escribe "rea" ‚Üí Llamada API 3
- Escribe "reac" ‚Üí Llamada API 4
- Escribe "react" ‚Üí Llamada API 5

**¬°5 llamadas API para 5 caracteres!** Esto es derrochador y puede sobrecargar el servidor.

---

## Soluci√≥n 1: Debouncing

**Debouncing** = Esperar a que el usuario deje de escribir antes de disparar la solicitud.

**Concepto:**
- Usuario escribe "r" ‚Üí Iniciar temporizador de 300ms
- Usuario escribe "e" (antes de que termine el temporizador) ‚Üí Cancelar temporizador, iniciar nuevo temporizador de 300ms
- Usuario escribe "a" (antes de que termine el temporizador) ‚Üí Cancelar temporizador, iniciar nuevo temporizador de 300ms
- Usuario escribe "c" (antes de que termine el temporizador) ‚Üí Cancelar temporizador, iniciar nuevo temporizador de 300ms
- Usuario escribe "t" (antes de que termine el temporizador) ‚Üí Cancelar temporizador, iniciar nuevo temporizador de 300ms
- Usuario pausa... pasan 300ms ‚Üí Disparar solicitud para "react"

**Resultado: ¬°1 llamada API en lugar de 5!**

---

## Hook useDebounce

```tsx
// src/hooks/useDebounce.ts

import { useState, useEffect } from 'react'

/**
 * useDebounce: Retardar actualizaciones de valor
 * 
 * Devuelve una versi√≥n debounced del valor que solo se actualiza
 * despu√©s de que ha pasado el retraso especificado sin cambios.
 * 
 * Ejemplo:
 *   const query = 'react'  // Cambia instant√°neamente en cada pulsaci√≥n
 *   const debouncedQuery = useDebounce(query, 300)  // Cambia 300ms despu√©s de la √∫ltima pulsaci√≥n
 */
export function useDebounce<T>(value: T, delay: number): T {
  /**
   * Estado para almacenar valor debounced
   * 
   * Comienza con valor inicial
   */
  const [debouncedValue, setDebouncedValue] = useState<T>(value)

  useEffect(() => {
    /**
     * Configurar un temporizador para actualizar valor debounced
     * 
     * setTimeout se ejecuta despu√©s de 'delay' milisegundos
     */
    const timer = setTimeout(() => {
      setDebouncedValue(value)
    }, delay)

    /**
     * Funci√≥n de limpieza
     * 
     * Se ejecuta cuando:
     * 1. El valor cambia (antes del siguiente efecto)
     * 2. El componente se desmonta
     * 
     * Esto cancela el temporizador pendiente
     */
    return () => {
      clearTimeout(timer)
    }
  }, [value, delay])  // Volver a ejecutar cuando cambia el valor o el retraso

  return debouncedValue
}
```

### C√≥mo Funciona

**L√≠nea de tiempo cuando el usuario escribe "react":**

```
t=0ms:    Usuario escribe 'r'
          ‚Üí value = 'r'
          ‚Üí setTimeout 300ms
          
t=50ms:   Usuario escribe 'e' 
          ‚Üí value = 're'
          ‚Üí clearTimeout (cancelar temporizador anterior)
          ‚Üí setTimeout 300ms (nuevo temporizador)
          
t=100ms:  Usuario escribe 'a'
          ‚Üí value = 'rea'
          ‚Üí clearTimeout
          ‚Üí setTimeout 300ms
          
t=150ms:  Usuario escribe 'c'
          ‚Üí value = 'reac'
          ‚Üí clearTimeout
          ‚Üí setTimeout 300ms
          
t=200ms:  Usuario escribe 't'
          ‚Üí value = 'react'
          ‚Üí clearTimeout
          ‚Üí setTimeout 300ms
          
t=500ms:  ¬°Se dispara el temporizador!
          ‚Üí debouncedValue = 'react'
          ‚Üí Activar b√∫squeda
```

---

## Soluci√≥n 2: Cancelando Solicitudes Antiguas

**Problema:** El usuario escribe "react", luego r√°pidamente cambia a "vue". Ambas solicitudes est√°n en vuelo. ¬øQu√© pasa si la respuesta de "react" llega despu√©s de la respuesta de "vue"? ¬°Resultados incorrectos!

**Esto es una condici√≥n de carrera.**

**Soluci√≥n:** Cancelar solicitudes antiguas cuando comienzan nuevas.

### AbortController

```tsx
// Crear controlador
const controller = new AbortController()

// Pasar se√±al a fetch/axios
fetch('/api/search', {
  signal: controller.signal
})

// Cancelar solicitud
controller.abort()
```

**Qu√© pasa cuando se aborta:**
- La solicitud se cancela (el navegador la detiene)
- La promesa se rechaza con `AbortError`
- Podemos verificar `signal.aborted` para ignorar el error

---

## Soluci√≥n 3: useTransition - Actualizaciones UI No Bloqueantes

**Problema:** Mientras se busca, la entrada se vuelve irresponsiva. El usuario no puede escribir suavemente porque React est√° ocupado actualizando los resultados.

**Soluci√≥n:** `useTransition` marca las actualizaciones como no bloqueantes, manteniendo la entrada responsiva.

### ¬øQu√© es useTransition?

`useTransition` te permite marcar actualizaciones de estado como **no urgentes**. React har√°:
1. Mantener las actualizaciones urgentes (entrada) responsivas
2. Procesar actualizaciones no urgentes (resultados de b√∫squeda) en segundo plano
3. Mostrar un indicador de carga mientras procesa

### C√≥mo Funciona

```tsx
import { useTransition } from 'react'

function SearchThreads() {
  const [query, setQuery] = useState('')
  const [results, setResults] = useState<Thread[]>([])
  
  // useTransition devuelve [isPending, startTransition]
  const [isPending, startTransition] = useTransition()
  
  const handleSearch = (newQuery: string) => {
    // Urgente: Actualizar entrada inmediatamente
    setQuery(newQuery)
    
    // No urgente: Actualizar resultados en segundo plano
    startTransition(() => {
      // Esta actualizaci√≥n se marca como no bloqueante
      const filtered = threads.filter(t => 
        t.title.includes(newQuery)
      )
      setResults(filtered)
    })
  }
  
  return (
    <div>
      <input 
        value={query}
        onChange={(e) => handleSearch(e.target.value)}
        placeholder="Buscar hilos..."
      />
      
      {isPending && <p>Buscando...</p>}
      
      <div>
        {results.map(thread => (
          <ThreadCard key={thread.id} thread={thread} />
        ))}
      </div>
    </div>
  )
}
```

### L√≠nea de Tiempo Visual

```
Usuario escribe "react":

SIN useTransition:
t=0ms:    Usuario escribe 'r'
          ‚Üí La entrada se actualiza (r√°pido)
          ‚Üí Los resultados se actualizan (lento, bloquea entrada)
          ‚Üí El usuario no puede escribir suavemente ‚ùå

CON useTransition:
t=0ms:    Usuario escribe 'r'
          ‚Üí La entrada se actualiza inmediatamente (r√°pido) ‚úÖ
          ‚Üí Los resultados se actualizan en segundo plano
          ‚Üí El usuario puede seguir escribiendo suavemente ‚úÖ
```

### useTransition vs Debouncing

| Aspecto | Debouncing | useTransition |
|---------|------------|---------------|
| **Prop√≥sito** | Reducir llamadas API | Mantener UI responsiva |
| **Cu√°ndo usar** | Llamadas API, operaciones costosas | Listas grandes, renders complejos |
| **Responsividad de entrada** | ‚ö†Ô∏è Retrasada | ‚úÖ Inmediata |
| **Actualizaci√≥n de resultados** | Despu√©s del retraso | En segundo plano |
| **Mejor para** | B√∫squeda, filtrado | Ordenamiento, filtrado de datos grandes |

**Usa ambos juntos:**
- Debouncing: Reducir llamadas API
- useTransition: Mantener UI responsiva mientras procesa

---

## Componente de B√∫squeda Completo con useTransition

```tsx
// src/components/search/SearchThreads.tsx

import { useState, useEffect, useTransition } from 'react'
import { useDebounce } from '@/hooks/useDebounce'
import { ThreadCard } from '@/components/threads/ThreadCard'
import { apiClient } from '@/lib/api-client'
import type { Thread } from '@/types'

export function SearchThreads() {
  /**
   * Valor inmediato: se actualiza en cada pulsaci√≥n de tecla
   * 
   * Esto mantiene la entrada responsiva
   */
  const [query, setQuery] = useState('')
  
  /**
   * Valor debounced: se actualiza 300ms despu√©s de la √∫ltima pulsaci√≥n
   * 
   * Esto es lo que usamos para la llamada API
   */
  const debouncedQuery = useDebounce(query, 300)
  
  const [results, setResults] = useState<Thread[]>([])
  const [error, setError] = useState<string | null>(null)
  
  /**
   * useTransition: Marcar actualizaciones de resultados como no bloqueantes
   * 
   * Devuelve [isPending, startTransition]
   * - isPending: true mientras la transici√≥n est√° ocurriendo
   * - startTransition: Envolver actualizaciones de estado para marcarlas como no urgentes
   * 
   * Esto mantiene la entrada responsiva mientras los resultados se actualizan en segundo plano
   */
  const [isPending, startTransition] = useTransition()

  /**
   * Efecto de b√∫squeda
   * 
   * Se ejecuta cuando cambia debouncedQuery (¬°no query!)
   * Esto significa que espera 300ms despu√©s de que el usuario deje de escribir
   */
  useEffect(() => {
    /**
     * Retorno temprano si la consulta est√° vac√≠a
     * 
     * No hay necesidad de buscar cadena vac√≠a
     */
    if (!debouncedQuery.trim()) {
      setResults([])
      setIsSearching(false)
      setError(null)
      return
    }

    /**
     * Crear AbortController para esta solicitud
     * 
     * Cada ejecuci√≥n del efecto obtiene su propio controlador
     */
    const controller = new AbortController()

    /**
     * Funci√≥n de b√∫squeda as√≠ncrona
     */
    async function search() {
      try {
        setError(null)

        /**
         * Hacer llamada API con se√±al de aborto
         * 
         * Si se llama a controller.abort(), esta solicitud se cancelar√°
         */
        const response = await apiClient.get<Thread[]>('/threads/search', {
          params: { q: debouncedQuery },
          signal: controller.signal,
        })

        /**
         * Solo actualizar resultados si no se ha abortado
         * 
         * Envolver en startTransition para mantener la entrada responsiva
         * mientras los resultados se actualizan en segundo plano
         */
        if (!controller.signal.aborted) {
          startTransition(() => {
            setResults(response.data)
          })
        }
      } catch (err) {
        /**
         * Ignorar AbortError (esperado al cancelar)
         * 
         * Manejar otros errores normalmente
         */
        if (!controller.signal.aborted) {
          startTransition(() => {
            setError(err instanceof Error ? err.message : 'B√∫squeda fallida')
            setResults([])
          })
        }
      }
    }

    search()

    /**
     * Limpieza: abortar solicitud cuando el efecto se vuelve a ejecutar o se desmonta
     * 
     * Esto cancela la solicitud si:
     * 1. El usuario escribe de nuevo (cambia debouncedQuery)
     * 2. El componente se desmonta
     * 
     * ¬°Previene condiciones de carrera!
     */
    return () => {
      controller.abort()
    }
  }, [debouncedQuery])

  return (
    <div className="space-y-6">
      {/* Entrada de b√∫squeda */}
      <div className="relative">
        <input
          type="text"
          value={query}
          onChange={(e) => setQuery(e.target.value)}
          placeholder="Buscar hilos por t√≠tulo, contenido o autor..."
          className="w-full px-4 py-3 pl-12 bg-slate-900 border border-slate-700 rounded-lg text-slate-100 placeholder-slate-500 focus:border-blue-500 focus:ring-1 focus:ring-blue-500"
        />
        
        {/* Icono de b√∫squeda */}
        <div className="absolute left-4 top-1/2 -translate-y-1/2 text-slate-500">
          üîç
        </div>

        {/* Spinner de carga - se muestra mientras la transici√≥n est√° pendiente */}
        {isPending && (
          <div className="absolute right-4 top-1/2 -translate-y-1/2">
            <div className="animate-spin h-5 w-5 border-2 border-blue-500 border-t-transparent rounded-full" />
          </div>
        )}
      </div>

      {/* Texto de ayuda */}
      {!query && (
        <div className="text-center py-12 text-slate-500">
          <p>Comienza a escribir para buscar hilos...</p>
        </div>
      )}

      {/* Estado de error */}
      {error && (
        <div className="bg-red-900/20 border border-red-700 rounded-lg p-4">
          <p className="text-red-400">{error}</p>
        </div>
      )}

      {/* Resultados */}
      {query && !isSearching && results.length === 0 && !error && (
        <div className="text-center py-12 text-slate-400">
          <p>No se encontraron hilos para "{query}"</p>
        </div>
      )}

      {results.length > 0 && (
        <div>
          <p className="text-sm text-slate-400 mb-4">
            Se encontr√≥{results.length === 1 ? '' : 'n'} {results.length} hilo{results.length === 1 ? '' : 's'}
          </p>
          
          <div className="space-y-4">
            {results.map((thread) => (
              <ThreadCard key={thread.id} thread={thread} />
            ))}
          </div>
        </div>
      )}
    </div>
  )
}
```

---

## P√°gina de B√∫squeda

```tsx
// src/pages/SearchPage.tsx

import { SearchThreads } from '@/components/search/SearchThreads'

export function SearchPage() {
  return (
    <div className="container mx-auto px-4 py-8 max-w-4xl">
      <div className="mb-8">
        <h1 className="text-3xl font-bold text-slate-100 mb-2">
          Buscar Hilos
        </h1>
        <p className="text-slate-400">
          Busca en todos los hilos del foro por t√≠tulo, contenido o autor
        </p>
      </div>

      <SearchThreads />
    </div>
  )
}
```

---

## Resumen: Patrones de Rendimiento de B√∫squeda

### El Enfoque de Tres Capas

**1. Debouncing (useDebounce)**
- Reduce llamadas API
- Espera a que el usuario deje de escribir
- Ejemplo: 5 pulsaciones ‚Üí 1 llamada API

**2. Cancelaci√≥n de Solicitudes (AbortController)**
- Previene condiciones de carrera
- Cancela solicitudes antiguas cuando comienzan nuevas
- Asegura que se muestren los resultados m√°s recientes

**3. UI No Bloqueante (useTransition)**
- Mantiene la entrada responsiva
- Actualiza resultados en segundo plano
- Muestra indicador de carga

### Cu√°ndo Usar Cada Uno

| Escenario | Soluci√≥n |
|-----------|----------|
| Usuario escribe r√°pidamente | Debouncing |
| Usuario cambia consulta antes de que lleguen resultados | AbortController |
| Los resultados tardan en renderizarse | useTransition |
| Lista grande de resultados | useDeferredValue (siguiente lecci√≥n) |

### Puntos Clave

‚úÖ **Debouncing** = Reducir llamadas API
‚úÖ **AbortController** = Prevenir condiciones de carrera
‚úÖ **useTransition** = Mantener UI responsiva
‚úÖ **Usar los tres juntos** = Experiencia de b√∫squeda perfecta

### M√©tricas de Rendimiento

Con los tres patrones:
- Llamadas API: 80% de reducci√≥n (debouncing)
- Condiciones de carrera: 0% (AbortController)
- Lag de entrada: 0ms (useTransition)
- Experiencia de usuario: ‚≠ê‚≠ê‚≠ê‚≠ê‚≠ê

---

## Avanzado: B√∫squeda con Filtros

Combinar b√∫squeda con filtros (categor√≠a, rango de fechas, etc.)

```tsx
export function SearchThreads() {
  const [query, setQuery] = useState('')
  const debouncedQuery = useDebounce(query, 300)
  const [selectedCategory, setSelectedCategory] = useState<string | null>(null)
  const [results, setResults] = useState<Thread[]>([])
  const [isSearching, setIsSearching] = useState(false)

  useEffect(() => {
    if (!debouncedQuery.trim()) {
      setResults([])
      return
    }

    const controller = new AbortController()

    async function search() {
      setIsSearching(true)

      try {
        const response = await apiClient.get<Thread[]>('/threads/search', {
          params: {
            q: debouncedQuery,
            categoryId: selectedCategory,  // A√±adir filtro
          },
          signal: controller.signal,
        })

        if (!controller.signal.aborted) {
          setResults(response.data)
        }
      } catch (err) {
        if (!controller.signal.aborted) {
          console.error(err)
        }
      } finally {
        if (!controller.signal.aborted) {
          setIsSearching(false)
        }
      }
    }

    search()

    return () => controller.abort()
  }, [debouncedQuery, selectedCategory])  // Volver a buscar cuando cambia el filtro

  return (
    <div>
      <input
        value={query}
        onChange={(e) => setQuery(e.target.value)}
        placeholder="Buscar..."
      />
      
      <select
        value={selectedCategory || ''}
        onChange={(e) => setSelectedCategory(e.target.value || null)}
      >
        <option value="">Todas las Categor√≠as</option>
        {/* Opciones de categor√≠a */}
      </select>

      <ThreadList threads={results} />
    </div>
  )
}
```

---

## Integraci√≥n con URL

Almacenar consulta de b√∫squeda en URL para marcadores/compartir.

```tsx
import { useSearchParams } from 'react-router-dom'

export function SearchThreads() {
  const [searchParams, setSearchParams] = useSearchParams()
  
  /**
   * Obtener consulta de URL
   * 
   * URL: /search?q=react
   * query ser√° 'react'
   */
  const query = searchParams.get('q') || ''
  const debouncedQuery = useDebounce(query, 300)
  
  const [results, setResults] = useState<Thread[]>([])
  const [isSearching, setIsSearching] = useState(false)

  /**
   * Actualizar URL cuando cambia la consulta
   */
  const handleQueryChange = (newQuery: string) => {
    if (newQuery) {
      setSearchParams({ q: newQuery })
    } else {
      setSearchParams({})  // Eliminar par√°metro de consulta si est√° vac√≠o
    }
  }

  /**
   * Efecto de b√∫squeda (igual que antes)
   */
  useEffect(() => {
    // ... l√≥gica de b√∫squeda
  }, [debouncedQuery])

  return (
    <input
      value={query}
      onChange={(e) => handleQueryChange(e.target.value)}
      placeholder="Buscar..."
    />
  )
}
```

**Beneficios:**
- URL es compartible: `/search?q=react hooks`
- Se puede marcar como favorito: Guardar b√∫squeda para despu√©s
- El bot√≥n atr√°s funciona: Volver a b√∫squeda anterior
- Deep linking: Enlazar directamente a resultados de b√∫squeda

---

## Resaltado de Resultados de B√∫squeda

Resaltar t√©rminos coincidentes en resultados.

```tsx
function highlightText(text: string, query: string): string {
  if (!query) return text

  const regex = new RegExp(`(${query})`, 'gi')
  return text.replace(regex, '<mark>$1</mark>')
}

function SearchResultCard({ thread, query }: { thread: Thread; query: string }) {
  return (
    <div>
      <h3 dangerouslySetInnerHTML={{ __html: highlightText(thread.title, query) }} />
      <p dangerouslySetInnerHTML={{ __html: highlightText(thread.excerpt, query) }} />
    </div>
  )
}
```

---

## Resumen

### Conceptos Clave

1. **Debouncing**: Esperar a que el usuario deje de escribir
   ```tsx
   const debouncedValue = useDebounce(value, 300)
   ```

2. **AbortController**: Cancelar solicitudes antiguas
   ```tsx
   const controller = new AbortController()
   fetch(url, { signal: controller.signal })
   controller.abort()
   ```

3. **Condiciones de Carrera**: Manejar respuestas fuera de orden
   ```tsx
   if (!controller.signal.aborted) {
     setResults(data)  // Solo actualizar si no se ha abortado
   }
   ```

4. **Estado URL**: Persistir b√∫squeda en URL
   ```tsx
   const query = searchParams.get('q')
   setSearchParams({ q: newQuery })
   ```

### Mejores Pr√°cticas

- ‚úÖ Debounce entrada de b√∫squeda (300-500ms es bueno)
- ‚úÖ Cancelar solicitudes antiguas cuando comienzan nuevas
- ‚úÖ Mostrar estado de carga durante b√∫squeda
- ‚úÖ Manejar resultados vac√≠os elegantemente
- ‚úÖ Almacenar consulta de b√∫squeda en URL
- ‚úÖ Resaltar t√©rminos coincidentes en resultados
- ‚úÖ Proporcionar mensajes de error claros

### Errores Comunes

- ‚ùå Buscar en cada pulsaci√≥n de tecla (demasiadas solicitudes)
- ‚ùå No cancelar solicitudes antiguas (condiciones de carrera)
- ‚ùå No manejar AbortError (logs de error innecesarios)
- ‚ùå Olvidar limpiar resultados cuando la consulta est√° vac√≠a
- ‚ùå No verificar `signal.aborted` antes de actualizar estado

---

## ¬°M√≥dulo de Hilos Completo! üéâ

Has dominado:
- ‚úÖ Listar hilos con paginaci√≥n
- ‚úÖ Detalle de hilo con obtenci√≥n paralela
- ‚úÖ Crear hilos con editor markdown
- ‚úÖ Filtrar y ordenar con estado derivado
- ‚úÖ B√∫squeda en tiempo real con debouncing

**Siguiente:** M√≥dulo de Posts (respuestas anidadas, votaci√≥n, interacciones ricas)

Contin√∫a a [M√≥dulo de Posts ‚Üí](/es/react/6.posts-module/1.display-posts)
