---
title: Crear Hilo
description: Construye un editor de markdown rico para creaci√≥n de hilos con vista previa en vivo y validaci√≥n.
---

# Disclaimer

:::u-alert
---
title: Los comentarios en el c√≥digo son solo educativos.
description: En proyectos reales, evita comentarios irrelevantes o redundantes.
color: warning
variant: subtle
icon: i-lucide-triangle-alert
---
:::

Crear hilos es m√°s complejo que las categor√≠as: necesitamos un editor de texto rico con soporte markdown, vista previa en vivo y selecci√≥n de categor√≠a.

---

## Lo Que Estamos Construyendo

Un formulario de creaci√≥n de hilos con:
- Campo de t√≠tulo (10-200 caracteres)
- Editor de markdown con barra de herramientas
- Vista previa en vivo del contenido renderizado
- Selector de categor√≠a
- Validaci√≥n en tiempo real
- Contadores de caracteres
- Funcionalidad de guardar borrador

---

## Esquema de Hilo

```typescript
// src/features/threads/schemas.ts

import { z } from 'zod'

/**
 * Esquema de creaci√≥n de hilo
 * 
 * M√°s complejo que el esquema de categor√≠a:
 * - Rango de t√≠tulo m√°s largo (10-200 vs 3-50)
 * - El contenido debe ser sustancial (m√≠nimo 50 caracteres)
 * - Debe pertenecer a una categor√≠a
 */
export const createThreadSchema = z.object({
  title: z
    .string()
    .min(10, 'El t√≠tulo debe tener al menos 10 caracteres')
    .max(200, 'El t√≠tulo debe tener como m√°ximo 200 caracteres')
    .regex(/^[^\n]+$/, 'El t√≠tulo no puede contener saltos de l√≠nea'),
  
  content: z
    .string()
    .min(50, 'El contenido debe tener al menos 50 caracteres')
    .max(10000, 'El contenido debe tener como m√°ximo 10,000 caracteres'),
  
  categoryId: z
    .string()
    .uuid('Categor√≠a seleccionada inv√°lida'),
})

export type CreateThreadInput = z.infer<typeof createThreadSchema>
```

**¬øPor qu√© estas restricciones?**
- **T√≠tulo 10-200**: Lo suficientemente corto para vista de lista, lo suficientemente largo para ser descriptivo
- **Contenido m√≠nimo 50**: Prevenir posts de baja calidad ("hola", "prueba", etc.)
- **Contenido m√°ximo 10k**: Prevenir abuso, fomentar discusiones enfocadas
- **Sin saltos de l√≠nea en t√≠tulo**: Mantiene la UI limpia

---

## Componente de Editor Markdown

Construiremos un editor de markdown personalizado con vista previa.

```tsx
// src/components/editor/MarkdownEditor.tsx

import { useState } from 'react'
import { marked } from 'marked'
import DOMPurify from 'dompurify'

interface MarkdownEditorProps {
  value: string
  onChange: (value: string) => void
  placeholder?: string
  minHeight?: number
}

/**
 * Editor de markdown con vista previa en vivo
 * 
 * Caracter√≠sticas:
 * - Vista dividida (editar | vista previa)
 * - Barra de herramientas con botones de formato
 * - Contador de caracteres
 * - Atajos de teclado
 */
export function MarkdownEditor({
  value,
  onChange,
  placeholder = 'Escribe tu post...',
  minHeight = 300,
}: MarkdownEditorProps) {
  const [activeTab, setActiveTab] = useState<'edit' | 'preview'>('edit')

  /**
   * Renderizar markdown a HTML de forma segura
   * 
   * Pasos:
   * 1. Parsear markdown con marked
   * 2. Sanitizar HTML con DOMPurify (prevenir XSS)
   * 3. Renderizar en vista previa
   */
  const renderMarkdown = (markdown: string): string => {
    const html = marked.parse(markdown, {
      gfm: true,  // GitHub Flavored Markdown
      breaks: true,  // Convertir \n a <br>
    })
    
    return DOMPurify.sanitize(html)
  }

  /**
   * Insertar sintaxis markdown en la posici√≥n del cursor
   * 
   * Usado por los botones de la barra de herramientas
   */
  const insertMarkdown = (
    prefix: string,
    suffix: string = '',
    placeholder: string = 'text'
  ) => {
    const textarea = document.querySelector('textarea') as HTMLTextAreaElement
    if (!textarea) return

    const start = textarea.selectionStart
    const end = textarea.selectionEnd
    const selectedText = value.substring(start, end) || placeholder

    const newText =
      value.substring(0, start) +
      prefix +
      selectedText +
      suffix +
      value.substring(end)

    onChange(newText)

    // Restaurar enfoque y selecci√≥n
    setTimeout(() => {
      textarea.focus()
      textarea.setSelectionRange(
        start + prefix.length,
        start + prefix.length + selectedText.length
      )
    }, 0)
  }

  return (
    <div className="border border-slate-700 rounded-lg overflow-hidden">
      {/* Barra de herramientas */}
      <div className="flex items-center gap-2 px-4 py-2 bg-slate-900 border-b border-slate-700">
        {/* Interruptor de pesta√±as */}
        <div className="flex gap-1 mr-auto">
          <button
            type="button"
            onClick={() => setActiveTab('edit')}
            className={`px-3 py-1 text-sm rounded ${
              activeTab === 'edit'
                ? 'bg-slate-800 text-slate-100'
                : 'text-slate-400 hover:text-slate-200'
            }`}
          >
            Editar
          </button>
          <button
            type="button"
            onClick={() => setActiveTab('preview')}
            className={`px-3 py-1 text-sm rounded ${
              activeTab === 'preview'
                ? 'bg-slate-800 text-slate-100'
                : 'text-slate-400 hover:text-slate-200'
            }`}
          >
            Vista Previa
          </button>
        </div>

        {/* Botones de formato */}
        {activeTab === 'edit' && (
          <div className="flex items-center gap-1">
            <button
              type="button"
              onClick={() => insertMarkdown('**', '**', 'texto en negrita')}
              title="Negrita (Ctrl+B)"
              className="p-2 text-slate-400 hover:text-slate-200 hover:bg-slate-800 rounded"
            >
              <strong>B</strong>
            </button>

            <button
              type="button"
              onClick={() => insertMarkdown('*', '*', 'texto en cursiva')}
              title="Cursiva (Ctrl+I)"
              className="p-2 text-slate-400 hover:text-slate-200 hover:bg-slate-800 rounded italic"
            >
              I
            </button>

            <button
              type="button"
              onClick={() => insertMarkdown('[', '](url)', 'texto del enlace')}
              title="Enlace"
              className="p-2 text-slate-400 hover:text-slate-200 hover:bg-slate-800 rounded"
            >
              üîó
            </button>

            <button
              type="button"
              onClick={() => insertMarkdown('`', '`', 'c√≥digo')}
              title="C√≥digo en l√≠nea"
              className="p-2 text-slate-400 hover:text-slate-200 hover:bg-slate-800 rounded font-mono"
            >
              {'</>'}
            </button>

            <button
              type="button"
              onClick={() => insertMarkdown('```\n', '\n```', 'bloque de c√≥digo')}
              title="Bloque de c√≥digo"
              className="p-2 text-slate-400 hover:text-slate-200 hover:bg-slate-800 rounded"
            >
              C√≥digo
            </button>

            <button
              type="button"
              onClick={() => insertMarkdown('\n- ', '', 'elemento de lista')}
              title="Lista de vi√±etas"
              className="p-2 text-slate-400 hover:text-slate-200 hover:bg-slate-800 rounded"
            >
              ‚Ä¢
            </button>
          </div>
        )}

        {/* Contador de caracteres */}
        <span className="text-xs text-slate-500">
          {value.length.toLocaleString()} caracteres
        </span>
      </div>

      {/* Editor / Vista Previa */}
      <div style={{ minHeight: `${minHeight}px` }}>
        {activeTab === 'edit' ? (
          <textarea
            value={value}
            onChange={(e) => onChange(e.target.value)}
            placeholder={placeholder}
            className="w-full h-full p-4 bg-slate-950 text-slate-100 resize-none focus:outline-none font-mono"
            style={{ minHeight: `${minHeight}px` }}
          />
        ) : (
          <div
            className="p-4 prose prose-invert max-w-none"
            dangerouslySetInnerHTML={{ __html: renderMarkdown(value) }}
          />
        )}
      </div>

      {/* Texto de ayuda */}
      <div className="px-4 py-2 bg-slate-900 border-t border-slate-700 text-xs text-slate-500">
        Markdown soportado: **negrita**, *cursiva*, `c√≥digo`, [enlace](url), listas, etc.
      </div>
    </div>
  )
}
```

### Explicaci√≥n del Editor Markdown

**Caracter√≠sticas clave:**

1. **Interruptor de pesta√±as**: El modo Editar muestra textarea, Vista Previa muestra markdown renderizado
2. **Botones de la barra de herramientas**: Insertan sintaxis markdown en la posici√≥n del cursor
3. **Contador de caracteres**: Ayuda a los usuarios a mantenerse dentro de los l√≠mites
4. **Renderizado seguro**: DOMPurify previene ataques XSS

**¬øPor qu√© `dangerouslySetInnerHTML`?**

React escapa HTML por defecto (bueno para seguridad). Pero QUEREMOS renderizar HTML (de markdown). As√≠ que usamos `dangerouslySetInnerHTML` con sanitizaci√≥n:

```tsx
// ‚ùå Sin sanitizaci√≥n: Vulnerabilidad XSS
<div dangerouslySetInnerHTML={{ __html: marked.parse(userInput) }} />

// ‚úÖ Con sanitizaci√≥n: Seguro
<div dangerouslySetInnerHTML={{ __html: DOMPurify.sanitize(marked.parse(userInput)) }} />
```

---

## Formulario de Crear Hilo

```tsx
// src/features/threads/components/CreateThreadForm.tsx

import { useForm } from 'react-hook-form'
import { zodResolver } from '@hookform/resolvers/zod'
import { useState } from 'react'
import { useNavigate } from 'react-router-dom'
import { createThreadSchema, type CreateThreadInput } from '../schemas'
import { MarkdownEditor } from '@/components/editor/MarkdownEditor'
import { apiClient } from '@/lib/api-client'
import { toast } from '@/lib/toast'
import type { Category, Thread } from '@/types'

interface CreateThreadFormProps {
  categories: Category[]
}

export function CreateThreadForm({ categories }: CreateThreadFormProps) {
  const navigate = useNavigate()
  
  /**
   * Configuraci√≥n de React Hook Form
   */
  const {
    register,
    handleSubmit,
    watch,
    setValue,
    formState: { errors, isSubmitting },
  } = useForm<CreateThreadInput>({
    resolver: zodResolver(createThreadSchema),
    defaultValues: {
      title: '',
      content: '',
      categoryId: '',
    },
  })

  /**
   * Watch content para MarkdownEditor
   * 
   * MarkdownEditor es un componente controlado que necesita valor + onChange
   * React Hook Form almacena el valor internamente, as√≠ que lo watch()eamos
   */
  const content = watch('content')

  /**
   * Manejador de env√≠o
   */
  const onSubmit = async (data: CreateThreadInput) => {
    try {
      const response = await apiClient.post<Thread>('/threads', data)
      
      toast.success('¬°Hilo creado exitosamente!')
      
      // Navegar al nuevo hilo
      navigate(`/threads/${response.data.slug}`)
    } catch (error) {
      toast.error(error instanceof Error ? error.message : 'Fall√≥ crear hilo')
    }
  }

  /**
   * Guardar borrador en localStorage
   * 
   * Auto-guardar cada 30 segundos
   */
  const saveDraft = () => {
    const draft = watch()
    localStorage.setItem('threadDraft', JSON.stringify(draft))
    toast.success('Borrador guardado')
  }

  return (
    <form onSubmit={handleSubmit(onSubmit)} className="space-y-6">
      {/* Campo de t√≠tulo */}
      <div>
        <label htmlFor="title" className="block text-sm font-medium text-slate-200 mb-2">
          T√≠tulo del Hilo *
        </label>
        <input
          id="title"
          type="text"
          {...register('title')}
          placeholder="¬øCu√°l es tu pregunta o tema?"
          className="w-full px-4 py-3 bg-slate-900 border border-slate-700 rounded-lg text-slate-100 placeholder-slate-500 focus:border-blue-500 focus:ring-1 focus:ring-blue-500"
        />
        {errors.title && (
          <p className="mt-2 text-sm text-red-400">{errors.title.message}</p>
        )}
        <p className="mt-2 text-xs text-slate-500">
          {watch('title')?.length || 0} / 200 caracteres
        </p>
      </div>

      {/* Selector de categor√≠a */}
      <div>
        <label htmlFor="categoryId" className="block text-sm font-medium text-slate-200 mb-2">
          Categor√≠a *
        </label>
        <select
          id="categoryId"
          {...register('categoryId')}
          className="w-full px-4 py-3 bg-slate-900 border border-slate-700 rounded-lg text-slate-100 focus:border-blue-500 focus:ring-1 focus:ring-blue-500"
        >
          <option value="">Selecciona una categor√≠a</option>
          {categories
            .filter((cat) => cat.parentId === null)  // Solo categor√≠as ra√≠z
            .map((category) => (
              <option key={category.id} value={category.id}>
                {category.name}
              </option>
            ))}
        </select>
        {errors.categoryId && (
          <p className="mt-2 text-sm text-red-400">{errors.categoryId.message}</p>
        )}
      </div>

      {/* Editor de contenido */}
      <div>
        <label className="block text-sm font-medium text-slate-200 mb-2">
          Contenido *
        </label>
        <MarkdownEditor
          value={content}
          onChange={(value) => setValue('content', value, { shouldValidate: true })}
          placeholder="Describe tu pregunta o tema en detalle..."
          minHeight={400}
        />
        {errors.content && (
          <p className="mt-2 text-sm text-red-400">{errors.content.message}</p>
        )}
        <p className="mt-2 text-xs text-slate-500">
          {content.length} / 10,000 caracteres (m√≠nimo 50)
        </p>
      </div>

      {/* Acciones */}
      <div className="flex items-center justify-between">
        <button
          type="button"
          onClick={saveDraft}
          className="px-4 py-2 text-slate-400 hover:text-slate-200"
        >
          Guardar Borrador
        </button>

        <div className="flex gap-3">
          <button
            type="button"
            onClick={() => navigate(-1)}
            className="px-6 py-3 bg-slate-800 text-slate-200 rounded-lg hover:bg-slate-700"
          >
            Cancelar
          </button>

          <button
            type="submit"
            disabled={isSubmitting}
            className="px-6 py-3 bg-blue-600 text-white rounded-lg hover:bg-blue-700 disabled:opacity-50 disabled:cursor-not-allowed"
          >
            {isSubmitting ? 'Creando...' : 'Crear Hilo'}
          </button>
        </div>
      </div>
    </form>
  )
}
```

---

## React Hook Form: watch() y setValue()

**Problema**: MarkdownEditor necesita `value` y `onChange`, pero React Hook Form maneja el estado internamente.

**Soluci√≥n**: Usa `watch()` y `setValue()`.

```tsx
// Watch el valor de un campo
const content = watch('content')

// Actualizar el valor de un campo
setValue('content', newValue, { shouldValidate: true })
```

**¬øPor qu√© `shouldValidate: true`?**

Le dice a React Hook Form que valide el campo inmediatamente despu√©s de actualizar. Sin esto, la validaci√≥n solo ocurre en blur/submit.

---

## P√°gina de Crear Hilo

```tsx
// src/pages/CreateThreadPage.tsx

import { useState, useEffect } from 'react'
import { useAuth } from '@/features/auth/hooks/useAuth'
import { Navigate } from 'react-router-dom'
import { CreateThreadForm } from '@/features/threads/components/CreateThreadForm'
import { apiClient } from '@/lib/api-client'
import type { Category } from '@/types'

export function CreateThreadPage() {
  const { user, isLoading: authLoading } = useAuth()
  const [categories, setCategories] = useState<Category[]>([])
  const [isLoadingCategories, setIsLoadingCategories] = useState(true)

  /**
   * Obtener categor√≠as para el selector
   */
  useEffect(() => {
    async function fetchCategories() {
      try {
        const response = await apiClient.get<{ data: Category[] }>('/categories')
        setCategories(response.data.data)
      } catch (error) {
        console.error('Fall√≥ cargar categor√≠as:', error)
      } finally {
        setIsLoadingCategories(false)
      }
    }

    fetchCategories()
  }, [])

  /**
   * Requerir autenticaci√≥n
   */
  if (authLoading) {
    return <div>Cargando...</div>
  }

  if (!user) {
    return <Navigate to="/sign-in" state={{ from: '/threads/new' }} />
  }

  /**
   * Cargando categor√≠as
   */
  if (isLoadingCategories) {
    return <div>Cargando categor√≠as...</div>
  }

  return (
    <div className="container mx-auto px-4 py-8 max-w-4xl">
      <div className="mb-8">
        <h1 className="text-3xl font-bold text-slate-100 mb-2">
          Crear Nuevo Hilo
        </h1>
        <p className="text-slate-400">
          Inicia una discusi√≥n, haz una pregunta o comparte tu conocimiento
        </p>
      </div>

      <div className="bg-slate-900 rounded-lg border border-slate-800 p-6">
        <CreateThreadForm categories={categories} />
      </div>
    </div>
  )
}
```

---

## Auto-Guardado de Borrador

Guarda borradores peri√≥dicamente para prevenir p√©rdida de datos.

```tsx
import { useEffect } from 'react'

export function CreateThreadForm({ categories }: CreateThreadFormProps) {
  const { watch } = useForm()

  /**
   * Auto-guardar borrador cada 30 segundos
   */
  useEffect(() => {
    const interval = setInterval(() => {
      const draft = watch()
      if (draft.title || draft.content) {
        localStorage.setItem('threadDraft', JSON.stringify(draft))
      }
    }, 30000)  // 30 segundos

    return () => clearInterval(interval)
  }, [watch])

  /**
   * Cargar borrador al montar
   */
  useEffect(() => {
    const savedDraft = localStorage.getItem('threadDraft')
    if (savedDraft) {
      const draft = JSON.parse(savedDraft)
      if (confirm('¬øCargar borrador guardado?')) {
        setValue('title', draft.title || '')
        setValue('content', draft.content || '')
        setValue('categoryId', draft.categoryId || '')
      }
    }
  }, [])

  // ...
}
```

---

## Resumen

### Nuevos Conceptos

1. **Editor Markdown**: Componente controlado personalizado con vista previa
2. **watch() y setValue()**: Puente entre React Hook Form y componentes personalizados
3. **DOMPurify**: Sanitizar HTML para prevenir XSS
4. **marked**: Parsear markdown a HTML
5. **Auto-guardado de borrador**: Usar localStorage + setInterval
6. **Rutas protegidas**: Requerir autenticaci√≥n

### Mejores Pr√°cticas

- ‚úÖ Sanitizar HTML generado por usuarios (DOMPurify)
- ‚úÖ Proporcionar vista previa en vivo para contenido rico
- ‚úÖ Mostrar conteos de caracteres para l√≠mites de longitud
- ‚úÖ Auto-guardar borradores para prevenir p√©rdida de datos
- ‚úÖ Validar en entrada para retroalimentaci√≥n instant√°nea
- ‚úÖ Redirigir al hilo creado despu√©s del √©xito

---

Siguiente: [Filtrar y Ordenar ‚Üí](/es/react/5.threads-module/4.filter-sort)
