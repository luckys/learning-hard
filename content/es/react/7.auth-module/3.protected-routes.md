---
title: Protected Routes - RBAC, Guards y Seguridad
description: Domina la protección de rutas con control de acceso basado en roles, sistemas de permisos, refresh de tokens y patrones de seguridad listos para producción. Construye autorización segura y escalable.
---

# Advertencia

:::u-alert
---
title: Los comentarios en el código son solo para fines educativos.
description: En proyectos reales, evita agregar comentarios irrelevantes o redundantes.
color: warning
variant: subtle
icon: i-lucide-triangle-alert
---
:::

No todas las rutas son públicas. Algunas requieren autenticación, otras requieren roles o permisos específicos. Las rutas protegidas son los guardianes de tu aplicación, asegurando que los usuarios solo accedan a lo que están autorizados a ver.

---

## Autenticación vs Autorización

### Diferencias Clave

**Autenticación (AuthN)**: *¿Quién eres?*
- Verifica identidad
- Login con credenciales
- Tokens JWT
- Gestión de sesiones

**Autorización (AuthZ)**: *¿Qué puedes hacer?*
- Verifica permisos
- Acceso basado en roles
- Verificaciones de permisos
- Propiedad de recursos

### Comparación Visual

```
Authentication Flow:
Usuario → Credenciales → Verificar → Token → Autenticado ✅

Authorization Flow:
Usuario Autenticado → Verificar Rol → Verificar Permiso → Acceder Recurso ✅
                                                   → Denegar Acceso ❌
```

### Ejemplo

```tsx
// Autenticación: ¿Está el usuario logged in?
if (!isAuthenticated) {
  return <Navigate to="/sign-in" />
}

// Autorización: ¿Tiene el usuario permiso?
if (user.role !== 'admin') {
  return <Navigate to="/forbidden" />
}
```

---

## Ruta Protegida Básica

### Implementación Simple

```tsx
// src/components/auth/ProtectedRoute.tsx

import { Navigate, useLocation } from 'react-router-dom'
import { useAuth } from '@/contexts/AuthContext'

interface ProtectedRouteProps {
  children: React.ReactNode
}

export function ProtectedRoute({ children }: ProtectedRouteProps) {
  const { user, isLoading, isAuthenticated } = useAuth()
  const location = useLocation()

  /**
   * Mostrar estado de carga mientras se verifica auth
   */
  if (isLoading) {
    return (
      <div className="min-h-screen flex items-center justify-center">
        <div className="animate-spin rounded-full h-12 w-12 border-b-2 border-blue-500" />
      </div>
    )
  }

  /**
   * Redirigir a sign-in si no está autenticado
   * Guardar ubicación actual para redirigir después del login
   */
  if (!isAuthenticated) {
    return <Navigate to="/sign-in" state={{ from: location }} replace />
  }

  /**
   * El usuario está autenticado, renderizar children
   */
  return <>{children}</>
}
```

### Uso

```tsx
// src/App.tsx

<Routes>
  {/* Rutas públicas */}
  <Route path="/" element={<HomePage />} />
  <Route path="/sign-in" element={<SignInPage />} />

  {/* Rutas protegidas */}
  <Route
    path="/threads/new"
    element={
      <ProtectedRoute>
        <CreateThreadPage />
      </ProtectedRoute>
    }
  />

  <Route
    path="/profile"
    element={
      <ProtectedRoute>
        <ProfilePage />
      </ProtectedRoute>
    }
  />
</Routes>
```

---

## Control de Acceso Basado en Roles (RBAC)

### Jerarquía de Roles

```
Admin (más alto)
├─ Puede hacer todo
├─ Gestionar usuarios
├─ Moderar contenido
└─ Acceder al panel de admin

Moderador
├─ Moderar contenido
├─ Banear usuarios
└─ Eliminar posts

Usuario (más bajo)
├─ Crear threads
├─ Crear posts
└─ Editar contenido propio
```

### Ruta Protegida Basada en Roles

```tsx
// src/components/auth/ProtectedRoute.tsx

import { Navigate, useLocation } from 'react-router-dom'
import { useAuth } from '@/contexts/AuthContext'

type UserRole = 'user' | 'moderator' | 'admin'

interface ProtectedRouteProps {
  children: React.ReactNode
  requiredRole?: UserRole
  requiredPermissions?: string[]
}

export function ProtectedRoute({
  children,
  requiredRole,
  requiredPermissions = [],
}: ProtectedRouteProps) {
  const { user, isLoading, isAuthenticated } = useAuth()
  const location = useLocation()

  if (isLoading) {
    return <LoadingScreen />
  }

  if (!isAuthenticated) {
    return <Navigate to="/sign-in" state={{ from: location }} replace />
  }

  /**
   * Verificar requisito de rol
   * Admin tiene acceso a todo
   */
  if (requiredRole && !hasRole(user, requiredRole)) {
    return (
      <div className="min-h-screen flex items-center justify-center">
        <div className="text-center">
          <h1 className="text-4xl font-bold text-slate-100 mb-4">403</h1>
          <p className="text-slate-400 mb-6">
            No tienes permiso para acceder a esta página
          </p>
          <Link
            to="/"
            className="px-4 py-2 bg-blue-600 text-white rounded-lg hover:bg-blue-700"
          >
            Ir al Inicio
          </Link>
        </div>
      </div>
    )
  }

  /**
   * Verificar permisos
   */
  if (requiredPermissions.length > 0 && !hasPermissions(user, requiredPermissions)) {
    return <Navigate to="/forbidden" replace />
  }

  return <>{children}</>
}

/**
 * Verificar si el usuario tiene el rol requerido
 */
function hasRole(user: User | null, requiredRole: UserRole): boolean {
  if (!user) return false
  
  // Admin tiene acceso a todo
  if (user.role === 'admin') return true
  
  // Coincidencia exacta de rol
  if (user.role === requiredRole) return true
  
  // Moderador tiene acceso a rutas de usuario
  if (requiredRole === 'user' && user.role === 'moderator') return true
  
  return false
}

/**
 * Verificar si el usuario tiene todos los permisos requeridos
 */
function hasPermissions(user: User | null, requiredPermissions: string[]): boolean {
  if (!user || !user.permissions) return false
  
  return requiredPermissions.every(permission =>
    user.permissions.includes(permission)
  )
}
```

### Uso con Roles

```tsx
<Routes>
  {/* Rutas de usuario */}
  <Route
    path="/threads/new"
    element={
      <ProtectedRoute requiredRole="user">
        <CreateThreadPage />
      </ProtectedRoute>
    }
  />

  {/* Rutas de moderador */}
  <Route
    path="/moderation"
    element={
      <ProtectedRoute requiredRole="moderator">
        <ModerationQueue />
      </ProtectedRoute>
    }
  />

  {/* Rutas de admin */}
  <Route
    path="/admin"
    element={
      <ProtectedRoute requiredRole="admin">
        <AdminDashboard />
      </ProtectedRoute>
    }
  />
</Routes>
```

---

## Control de Acceso Basado en Permisos

### Sistema de Permisos

```typescript
// src/types/permissions.ts

export const PERMISSIONS = {
  // Permisos de threads
  THREAD_CREATE: 'thread:create',
  THREAD_EDIT_OWN: 'thread:edit:own',
  THREAD_EDIT_ANY: 'thread:edit:any',
  THREAD_DELETE_OWN: 'thread:delete:own',
  THREAD_DELETE_ANY: 'thread:delete:any',
  
  // Permisos de posts
  POST_CREATE: 'post:create',
  POST_EDIT_OWN: 'post:edit:own',
  POST_EDIT_ANY: 'post:edit:any',
  POST_DELETE_OWN: 'post:delete:own',
  POST_DELETE_ANY: 'post:delete:any',
  
  // Permisos de usuarios
  USER_BAN: 'user:ban',
  USER_EDIT: 'user:edit',
  USER_DELETE: 'user:delete',
  
  // Permisos de admin
  ADMIN_ACCESS: 'admin:access',
  ADMIN_SETTINGS: 'admin:settings',
} as const

export type Permission = typeof PERMISSIONS[keyof typeof PERMISSIONS]

/**
 * Rol → Mapeo de permisos
 */
export const ROLE_PERMISSIONS: Record<UserRole, Permission[]> = {
  user: [
    PERMISSIONS.THREAD_CREATE,
    PERMISSIONS.THREAD_EDIT_OWN,
    PERMISSIONS.THREAD_DELETE_OWN,
    PERMISSIONS.POST_CREATE,
    PERMISSIONS.POST_EDIT_OWN,
    PERMISSIONS.POST_DELETE_OWN,
  ],
  moderator: [
    // Todos los permisos de usuario
    ...ROLE_PERMISSIONS.user,
    // Plus permisos de moderador
    PERMISSIONS.THREAD_EDIT_ANY,
    PERMISSIONS.THREAD_DELETE_ANY,
    PERMISSIONS.POST_EDIT_ANY,
    PERMISSIONS.POST_DELETE_ANY,
    PERMISSIONS.USER_BAN,
  ],
  admin: [
    // Todos los permisos de moderador
    ...ROLE_PERMISSIONS.moderator,
    // Plus permisos de admin
    PERMISSIONS.USER_EDIT,
    PERMISSIONS.USER_DELETE,
    PERMISSIONS.ADMIN_ACCESS,
    PERMISSIONS.ADMIN_SETTINGS,
  ],
}
```

### Hook de Permisos

```tsx
// src/hooks/usePermissions.ts

import { useAuth } from '@/contexts/AuthContext'
import { ROLE_PERMISSIONS, Permission } from '@/types/permissions'

export function usePermissions() {
  const { user } = useAuth()

  /**
   * Verificar si el usuario tiene permiso específico
   */
  const hasPermission = (permission: Permission): boolean => {
    if (!user) return false
    
    const userPermissions = ROLE_PERMISSIONS[user.role] || []
    return userPermissions.includes(permission)
  }

  /**
   * Verificar si el usuario tiene todos los permisos
   */
  const hasAllPermissions = (permissions: Permission[]): boolean => {
    return permissions.every(permission => hasPermission(permission))
  }

  /**
   * Verificar si el usuario tiene algún permiso
   */
  const hasAnyPermission = (permissions: Permission[]): boolean => {
    return permissions.some(permission => hasPermission(permission))
  }

  /**
   * Verificar si el usuario puede editar recurso
   */
  const canEdit = (resource: { authorId: string }, editAnyPermission: Permission, editOwnPermission: Permission): boolean => {
    // Puede editar cualquiera
    if (hasPermission(editAnyPermission)) return true
    
    // Puede editar propio
    if (hasPermission(editOwnPermission) && resource.authorId === user?.id) return true
    
    return false
  }

  return {
    hasPermission,
    hasAllPermissions,
    hasAnyPermission,
    canEdit,
  }
}
```

### Uso con Permisos

```tsx
// src/pages/ThreadDetailPage.tsx

import { usePermissions } from '@/hooks/usePermissions'
import { PERMISSIONS } from '@/types/permissions'

export function ThreadDetailPage() {
  const { thread } = useThread()
  const { hasPermission, canEdit } = usePermissions()

  const canEditThread = canEdit(
    thread,
    PERMISSIONS.THREAD_EDIT_ANY,
    PERMISSIONS.THREAD_EDIT_OWN
  )

  const canDeleteThread = canEdit(
    thread,
    PERMISSIONS.THREAD_DELETE_ANY,
    PERMISSIONS.THREAD_DELETE_OWN
  )

  return (
    <div>
      <h1>{thread.title}</h1>
      
      {canEditThread && (
        <button onClick={handleEdit}>Editar</button>
      )}
      
      {canDeleteThread && (
        <button onClick={handleDelete}>Eliminar</button>
      )}
    </div>
  )
}
```

---

## Refresh de Token y Expiración

### Refresh Automático de Token

```tsx
// src/contexts/AuthContext.tsx

import { createContext, useContext, useEffect, useRef } from 'react'
import { jwtDecode } from 'jwt-decode'

export function AuthProvider({ children }: { children: React.ReactNode }) {
  const [user, setUser] = useState<User | null>(null)
  const [token, setToken] = useState<string | null>(null)
  const refreshTimeoutRef = useRef<NodeJS.Timeout>()

  /**
   * Programar refresh de token antes de la expiración
   */
  const scheduleTokenRefresh = useCallback((token: string) => {
    try {
      const decoded = jwtDecode<{ exp: number }>(token)
      const expiresAt = decoded.exp * 1000 // Convertir a milisegundos
      const now = Date.now()
      const timeUntilExpiry = expiresAt - now
      
      // Refresh 5 minutos antes de la expiración
      const refreshTime = timeUntilExpiry - 5 * 60 * 1000
      
      if (refreshTime > 0) {
        refreshTimeoutRef.current = setTimeout(async () => {
          await refreshToken()
        }, refreshTime)
      }
    } catch (error) {
      console.error('Error al programar refresh de token:', error)
    }
  }, [])

  /**
   * Refrescar token de acceso
   */
  const refreshToken = async () => {
    try {
      const response = await fetch('/api/auth/refresh', {
        method: 'POST',
        credentials: 'include', // Enviar cookie de refresh token
      })

      if (!response.ok) {
        throw new Error('Refresh de token falló')
      }

      const data = await response.json()
      
      setToken(data.accessToken)
      localStorage.setItem('token', data.accessToken)
      
      // Programar siguiente refresh
      scheduleTokenRefresh(data.accessToken)
    } catch (error) {
      console.error('Error de refresh de token:', error)
      // Logout del usuario si el refresh falla
      logout()
    }
  }

  /**
   * Inicializar refresh de token al montar
   */
  useEffect(() => {
    const storedToken = localStorage.getItem('token')
    if (storedToken) {
      setToken(storedToken)
      scheduleTokenRefresh(storedToken)
    }

    return () => {
      if (refreshTimeoutRef.current) {
        clearTimeout(refreshTimeoutRef.current)
      }
    }
  }, [scheduleTokenRefresh])

  return (
    <AuthContext.Provider value={{ user, token, refreshToken }}>
      {children}
    </AuthContext.Provider>
  )
}
```

### Interceptor de Axios para Refresh de Token

```typescript
// src/lib/api-client.ts

import axios from 'axios'

const apiClient = axios.create({
  baseURL: '/api',
})

// Interceptor de solicitud: Agregar token a headers
apiClient.interceptors.request.use(
  (config) => {
    const token = localStorage.getItem('token')
    if (token) {
      config.headers.Authorization = `Bearer ${token}`
    }
    return config
  },
  (error) => Promise.reject(error)
)

// Interceptor de respuesta: Manejar expiración de token
apiClient.interceptors.response.use(
  (response) => response,
  async (error) => {
    const originalRequest = error.config

    // Token expirado
    if (error.response?.status === 401 && !originalRequest._retry) {
      originalRequest._retry = true

      try {
        // Refrescar token
        const response = await axios.post('/api/auth/refresh', {}, {
          withCredentials: true,
        })

        const { accessToken } = response.data
        
        // Guardar nuevo token
        localStorage.setItem('token', accessToken)
        
        // Reintentar solicitud original con nuevo token
        originalRequest.headers.Authorization = `Bearer ${accessToken}`
        return apiClient(originalRequest)
      } catch (refreshError) {
        // Refresh falló, logout del usuario
        localStorage.removeItem('token')
        window.location.href = '/sign-in'
        return Promise.reject(refreshError)
      }
    }

    return Promise.reject(error)
  }
)

export default apiClient
```

---

## Flujos de Redirección

### Recordar Ubicación Intencionada

```tsx
// src/pages/SignInPage.tsx

import { useNavigate, useLocation } from 'react-router-dom'

export function SignInPage() {
  const navigate = useNavigate()
  const location = useLocation()
  
  // Obtener ubicación intencionada del estado
  const from = location.state?.from?.pathname || '/'

  const handleSignIn = async (credentials: Credentials) => {
    try {
      await signIn(credentials)
      
      // Redirigir a ubicación intencionada
      navigate(from, { replace: true })
    } catch (error) {
      // Manejar error
    }
  }

  return (
    <form onSubmit={handleSignIn}>
      {/* Campos del formulario */}
    </form>
  )
}
```

### Deep Linking

```tsx
// src/components/auth/ProtectedRoute.tsx

export function ProtectedRoute({ children }: ProtectedRouteProps) {
  const { isAuthenticated } = useAuth()
  const location = useLocation()

  if (!isAuthenticated) {
    // Guardar URL completa incluyendo params de búsqueda y hash
    const intendedUrl = `${location.pathname}${location.search}${location.hash}`
    
    return (
      <Navigate
        to="/sign-in"
        state={{ from: intendedUrl }}
        replace
      />
    )
  }

  return <>{children}</>
}
```

---

## Estados de Carga y UX

### Pantalla de Esqueleto

```tsx
// src/components/auth/ProtectedRoute.tsx

function LoadingScreen() {
  return (
    <div className="min-h-screen bg-slate-950 p-8">
      <div className="max-w-4xl mx-auto">
        {/* Esqueleto de navbar */}
        <div className="h-16 bg-slate-900 rounded-lg mb-8 animate-pulse" />
        
        {/* Esqueleto de contenido */}
        <div className="space-y-4">
          <div className="h-32 bg-slate-900 rounded-lg animate-pulse" />
          <div className="h-48 bg-slate-900 rounded-lg animate-pulse" />
          <div className="h-24 bg-slate-900 rounded-lg animate-pulse" />
        </div>
      </div>
    </div>
  )
}
```

### Carga Progresiva

```tsx
export function ProtectedRoute({ children }: ProtectedRouteProps) {
  const { user, isLoading, isAuthenticated } = useAuth()
  const [showContent, setShowContent] = useState(false)

  useEffect(() => {
    if (!isLoading && isAuthenticated) {
      // Retrasar revelación de contenido para transición suave
      const timer = setTimeout(() => setShowContent(true), 100)
      return () => clearTimeout(timer)
    }
  }, [isLoading, isAuthenticated])

  if (isLoading) {
    return <LoadingScreen />
  }

  if (!isAuthenticated) {
    return <Navigate to="/sign-in" replace />
  }

  return (
    <div className={`transition-opacity duration-300 ${showContent ? 'opacity-100' : 'opacity-0'}`}>
      {children}
    </div>
  )
}
```

---

## Probar Rutas Protegidas

### Pruebas Unitarias

```tsx
// src/components/auth/__tests__/ProtectedRoute.test.tsx

import { render, screen } from '@testing-library/react'
import { BrowserRouter } from 'react-router-dom'
import { ProtectedRoute } from '../ProtectedRoute'
import { AuthContext } from '@/contexts/AuthContext'

describe('ProtectedRoute', () => {
  it('muestra estado de carga mientras verifica auth', () => {
    const mockAuthValue = {
      user: null,
      isLoading: true,
      isAuthenticated: false,
    }

    render(
      <BrowserRouter>
        <AuthContext.Provider value={mockAuthValue}>
          <ProtectedRoute>
            <div>Contenido Protegido</div>
          </ProtectedRoute>
        </AuthContext.Provider>
      </BrowserRouter>
    )

    expect(screen.getByRole('status')).toBeInTheDocument()
  })

  it('redirige a sign-in cuando no está autenticado', () => {
    const mockAuthValue = {
      user: null,
      isLoading: false,
      isAuthenticated: false,
    }

    render(
      <BrowserRouter>
        <AuthContext.Provider value={mockAuthValue}>
          <ProtectedRoute>
            <div>Contenido Protegido</div>
          </ProtectedRoute>
        </AuthContext.Provider>
      </BrowserRouter>
    )

    expect(window.location.pathname).toBe('/sign-in')
  })

  it('renderiza children cuando está autenticado', () => {
    const mockAuthValue = {
      user: { id: '1', role: 'user' },
      isLoading: false,
      isAuthenticated: true,
    }

    render(
      <BrowserRouter>
        <AuthContext.Provider value={mockAuthValue}>
          <ProtectedRoute>
            <div>Contenido Protegido</div>
          </ProtectedRoute>
        </AuthContext.Provider>
      </BrowserRouter>
    )

    expect(screen.getByText('Contenido Protegido')).toBeInTheDocument()
  })

  it('bloquea acceso cuando el usuario carece del rol requerido', () => {
    const mockAuthValue = {
      user: { id: '1', role: 'user' },
      isLoading: false,
      isAuthenticated: true,
    }

    render(
      <BrowserRouter>
        <AuthContext.Provider value={mockAuthValue}>
          <ProtectedRoute requiredRole="admin">
            <div>Contenido de Admin</div>
          </ProtectedRoute>
        </AuthContext.Provider>
      </BrowserRouter>
    )

    expect(screen.queryByText('Contenido de Admin')).not.toBeInTheDocument()
    expect(screen.getByText(/no tienes permiso/i)).toBeInTheDocument()
  })
})
```

---

## Mejores Prácticas

### ✅ HAZ

- ✅ Siempre verifica la autenticación en el servidor
- ✅ Usa refresh de token para evitar re-login
- ✅ Muestra estados de carga durante verificaciones de auth
- ✅ Recuerda ubicación intencionada para redirección post-login
- ✅ Implementa RBAC apropiado con clara jerarquía de roles
- ✅ Usa permisos para control de acceso granular
- ✅ Prueba rutas protegidas exhaustivamente

### ❌ NO HAGAS

- ❌ Confíes solo en verificaciones del lado del cliente
- ❌ Almacenes datos sensibles en localStorage
- ❌ Olvides manejar expiración de tokens
- ❌ Muestres contenido protegido antes de completar verificación de auth
- ❌ Uses sistemas de permisos demasiado complejos
- ❌ Olvides limpiar timers y suscripciones

---

## Resumen

### Conceptos Clave

1. **Autenticación**: Verificar identidad (quién eres)
2. **Autorización**: Verificar permisos (qué puedes hacer)
3. **RBAC**: Control de acceso basado en roles (admin, moderador, usuario)
4. **Permisos**: Control de acceso granular
5. **Refresh de Token**: Renovación automática de tokens
6. **Flujos de Redirección**: Recordar ubicación intencionada

### Checklist de Seguridad

- ✅ Validación del lado del servidor
- ✅ Manejo de expiración de tokens
- ✅ Refresh automático de tokens
- ✅ Jerarquía de roles
- ✅ Sistema de permisos
- ✅ Estados de carga
- ✅ Manejo de errores
- ✅ Cobertura de pruebas

---

Siguiente: [User Profile →](/es/react/7.auth-module/4.user-profile)
