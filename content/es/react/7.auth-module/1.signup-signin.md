---
title: Sign Up & Sign In - Patrones de Validación y Seguridad
description: Domina la validación multicapa, seguridad de contraseñas, validación asíncrona, manejo de errores y gestión de tokens JWT. Construye formularios de autenticación listos para producción.
---

# Advertencia

:::u-alert
---
title: Los comentarios en el código son solo para fines educativos.
description: En proyectos reales, evita agregar comentarios irrelevantes o redundantes.
color: warning
variant: subtle
icon: i-lucide-triangle-alert
---
:::

La autenticación es la puerta de entrada a tu aplicación. Construir formularios de autenticación seguros requiere **validación multicapa**: HTML5 para UX, validación del lado del cliente para retroalimentación, validación asíncrona para verificaciones en tiempo real, y validación del lado del servidor para seguridad. Nunca confíes en el cliente.

---

## La Pirámide de Validación: Defensa en Profundidad

La validación **no es una sola capa**. Es una pirámide donde cada capa captura diferentes errores:

```
        ┌──────────────────────────────────────┐
        │   Validación del Lado del Servidor   │ (CRÍTICO - no se puede confiar en el cliente)
        │  • Email no ya registrado            │
        │  • Fortaleza de contraseña verificada│
        │  • Limitación de tasa aplicada       │
        │  • Tokens CSRF validados             │
        ├──────────────────────────────────────┤
        │   Validación de Respuesta API        │ (Capturar errores del servidor)
        │  • Analizar estructura de respuesta │
        │  • Validar formato de token         │
        ├──────────────────────────────────────┤
        │   Validación del Manejador de Envío │ (Antes de la llamada API)
        │  • Verificación final del esquema    │
        │  • Verificaciones asíncronas         │
        │    (¿email existe?)                 │
        ├──────────────────────────────────────┤
        │   Validación en Tiempo Real          │ (Mientras el usuario escribe)
        │  • Retroalimentación de fortaleza    │
        │    de contraseña                     │
        │  • Verificación de disponibilidad    │
        │    de username                       │
        │  • Validación de formato de email    │
        ├──────────────────────────────────────┤
        │   Validación Nativa HTML5            │ (Errores obvios)
        │  • type="email" formato              │
        │  • atributo required                 │
        │  • minlength/maxlength               │
        └──────────────────────────────────────┘
```

**¿Por qué múltiples capas?**
- **HTML5**: Captura errores obvios (vacío, formato inválido)
- **Tiempo real**: Da retroalimentación instantánea (contraseña muy débil)
- **Envío**: Verificación final antes de la API (¿todos los campos válidos?)
- **API**: Captura problemas del lado del servidor (email ya existe)
- **Servidor**: Verificación de seguridad final (no se puede confiar en el cliente)

**Principio clave**: Nunca confíes solo en la validación del lado del cliente. Siempre valida en el servidor.

---

## Esquemas de Validación con Zod

### Reglas de Seguridad de Contraseña

```typescript
// src/features/auth/schemas.ts

import { z } from 'zod'

/**
 * Reglas de validación de contraseña basadas en directrices NIST
 * 
 * ¿Por qué estas reglas?
 * - 8 caracteres: Entropía mínima (recomendación NIST)
 * - Mayúsculas: Aumenta el conjunto de caracteres (más difícil de fuerza bruta)
 * - Número: Previene patrones comunes (password123)
 * - Carácter especial: Aumenta aún más la entropía
 * 
 * ¿Por qué NO estas reglas?
 * - Cambios frecuentes: Los usuarios las anotan (NIST dice que no)
 * - Expiración: No mejora la seguridad
 * - Reglas de complejidad solo: Mejor forzar longitud
 */
const passwordSchema = z
  .string('Contraseña requerida')
  .min(8, 'La contraseña debe tener al menos 8 caracteres')
  .regex(/[A-Z]/, 'Debe contener al menos una letra mayúscula')
  .regex(/[0-9]/, 'Debe contener al menos un número')
  .regex(/[!@#$%^&*]/, 'Debe contener al menos un carácter especial (!@#$%^&*)')

/**
 * Validación de username
 * 
 * ¿Por qué solo minúsculas?
 * - Previene que alice vs Alice sean usuarios diferentes
 * - Consultas a base de datos más simples
 * - Mejor UX (sin confusión de mayúsculas/minúsculas)
 */
const usernameSchema = z
  .string('Username requerido')
  .min(3, 'El username debe tener al menos 3 caracteres')
  .max(20, 'El username debe tener como máximo 20 caracteres')
  .regex(/^[a-z0-9_]+$/, 'Solo letras minúsculas, números y guiones bajos')
  .transform((val) => val.toLowerCase())  // Normalizar a minúsculas

export const signUpSchema = z
  .object({
    username: usernameSchema,
    email: z
      .string('Email requerido')
      .email('Por favor ingresa un email válido')
      .toLowerCase()
      .transform((val) => val.trim()),  // Eliminar espacios en blanco
    
    password: passwordSchema,
    
    confirmPassword: z.string('Por favor confirma la contraseña'),
  })
  .refine((data) => data.password === data.confirmPassword, {
    message: "Las contraseñas no coinciden",
    path: ['confirmPassword'],
  })

export type SignUpInput = z.infer<typeof signUpSchema>

export const signInSchema = z.object({
  email: z
    .string('Email requerido')
    .email('Por favor ingresa un email válido')
    .toLowerCase()
    .transform((val) => val.trim()),
  
  password: z
    .string('Contraseña requerida')
    .min(1, 'Contraseña requerida'),
})

export type SignInInput = z.infer<typeof signInSchema>
```

### Validación Asíncrona: Verificar Disponibilidad de Email

```typescript
/**
 * Validación asíncrona: Verificar si el email ya está registrado
 * 
 * Esto se ejecuta DESPUÉS de que pasa la validación síncrona
 * Solo se llama al enviar el formulario (no en cada pulsación de tecla)
 * 
 * ¿Por qué asíncrono?
 * - No se puede validar sin llamada API
 * - Operación costosa (consulta a base de datos)
 * - Debería ejecutarse solo cuando sea necesario
 */
export const signUpSchemaWithAsync = signUpSchema.refine(
  async (data) => {
    try {
      const response = await fetch('/api/auth/check-email', {
        method: 'POST',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify({ email: data.email }),
      })
      
      const { exists } = await response.json()
      return !exists  // Devuelve true si el email está disponible
    } catch (error) {
      // Si la API falla, permitir envío (el servidor lo capturará)
      console.error('Verificación de email falló:', error)
      return true
    }
  },
  {
    message: 'Email ya registrado. Intenta iniciar sesión en su lugar.',
    path: ['email'],
  }
)
```

---

## Formulario de Sign Up

```tsx
// src/pages/SignUpPage.tsx

import { useForm } from 'react-hook-form'
import { zodResolver } from '@hookform/resolvers/zod'
import { z } from 'zod'
import { apiClient } from '@/lib/api-client'
import { useNavigate } from 'react-router-dom'

const signUpSchema = z.object({
  username: z.string().min(3).max(20).regex(/^[a-zA-Z0-9_]+$/),
  email: z.string().email(),
  password: z.string().min(8),
  confirmPassword: z.string(),
}).refine((data) => data.password === data.confirmPassword, {
  message: "Las contraseñas no coinciden",
  path: ['confirmPassword'],
})

type SignUpInput = z.infer<typeof signUpSchema>

export function SignUpPage() {
  const navigate = useNavigate()
  const { register, handleSubmit, formState: { errors, isSubmitting } } = useForm<SignUpInput>({
    resolver: zodResolver(signUpSchema),
  })

  const onSubmit = async (data: SignUpInput) => {
    try {
      const response = await apiClient.post('/auth/signup', {
        username: data.username,
        email: data.email,
        password: data.password,
      })

      // Almacenar token JWT
      localStorage.setItem('auth_token', response.data.token)

      // Redirigir al inicio
      navigate('/')
    } catch (error) {
      // Manejar errores (email ya existe, etc.)
    }
  }

  return (
    <div className="min-h-screen flex items-center justify-center bg-slate-950">
      <div className="w-full max-w-md p-8 bg-slate-900 rounded-lg border border-slate-800">
        <h1 className="text-2xl font-bold mb-6">Crear Cuenta</h1>

        <form onSubmit={handleSubmit(onSubmit)} className="space-y-4">
          <div>
            <label className="block text-sm font-medium mb-2">Username</label>
            <input {...register('username')} className="w-full px-4 py-2 bg-slate-800 border border-slate-700 rounded-lg" />
            {errors.username && <p className="text-red-400 text-sm mt-1">{errors.username.message}</p>}
          </div>

          <div>
            <label className="block text-sm font-medium mb-2">Email</label>
            <input type="email" {...register('email')} className="w-full px-4 py-2 bg-slate-800 border border-slate-700 rounded-lg" />
            {errors.email && <p className="text-red-400 text-sm mt-1">{errors.email.message}</p>}
          </div>

          <div>
            <label className="block text-sm font-medium mb-2">Contraseña</label>
            <input type="password" {...register('password')} className="w-full px-4 py-2 bg-slate-800 border border-slate-700 rounded-lg" />
            {errors.password && <p className="text-red-400 text-sm mt-1">{errors.password.message}</p>}
          </div>

          <div>
            <label className="block text-sm font-medium mb-2">Confirmar Contraseña</label>
            <input type="password" {...register('confirmPassword')} className="w-full px-4 py-2 bg-slate-800 border border-slate-700 rounded-lg" />
            {errors.confirmPassword && <p className="text-red-400 text-sm mt-1">{errors.confirmPassword.message}</p>}
          </div>

          <button
            type="submit"
            disabled={isSubmitting}
            className="w-full px-4 py-3 bg-blue-600 text-white rounded-lg hover:bg-blue-700 font-medium"
          >
            {isSubmitting ? 'Creando cuenta...' : 'Sign Up'}
          </button>
        </form>
      </div>
    </div>
  )
}
```

---

## Formulario de Sign In

```tsx
// src/pages/SignInPage.tsx

const signInSchema = z.object({
  email: z.string().email(),
  password: z.string().min(1, 'La contraseña es requerida'),
})

type SignInInput = z.infer<typeof signInSchema>

export function SignInPage() {
  const navigate = useNavigate()
  const { register, handleSubmit, formState: { errors, isSubmitting } } = useForm<SignInInput>({
    resolver: zodResolver(signInSchema),
  })

  const onSubmit = async (data: SignInInput) => {
    try {
      const response = await apiClient.post('/auth/signin', data)
      localStorage.setItem('auth_token', response.data.token)
      navigate('/')
    } catch (error) {
      // Manejar credenciales inválidas
    }
  }

  return (
    <div className="min-h-screen flex items-center justify-center bg-slate-950">
      <div className="w-full max-w-md p-8 bg-slate-900 rounded-lg border border-slate-800">
        <h1 className="text-2xl font-bold mb-6">Sign In</h1>

        <form onSubmit={handleSubmit(onSubmit)} className="space-y-4">
          <div>
            <label className="block text-sm font-medium mb-2">Email</label>
            <input type="email" {...register('email')} className="w-full px-4 py-2 bg-slate-800 border border-slate-700 rounded-lg" />
            {errors.email && <p className="text-red-400 text-sm mt-1">{errors.email.message}</p>}
          </div>

          <div>
            <label className="block text-sm font-medium mb-2">Contraseña</label>
            <input type="password" {...register('password')} className="w-full px-4 py-2 bg-slate-800 border border-slate-700 rounded-lg" />
            {errors.password && <p className="text-red-400 text-sm mt-1">{errors.password.message}</p>}
          </div>

          <button
            type="submit"
            disabled={isSubmitting}
            className="w-full px-4 py-3 bg-blue-600 text-white rounded-lg hover:bg-blue-700 font-medium"
          >
            {isSubmitting ? 'Iniciando sesión...' : 'Sign In'}
          </button>
        </form>
      </div>
    </div>
  )
}
```

---

## Mejores Prácticas de Validación

### 1. Normalizar Entrada de Usuario

```typescript
// Las transformaciones de Zod normalizan datos antes de la validación
const schema = z.object({
  email: z.string().email().toLowerCase().trim(),
  username: z.string().toLowerCase(),
})

// Usuario escribe: "  ALICE@EXAMPLE.COM  "
// Se almacena como: "alice@example.com"
// Beneficio: Sin cuentas duplicadas por mayúsculas/espacios
```

### 2. Seguridad de Contraseña

✅ **HAZ:**
- Requerir mínimo 8 caracteres (NIST SP 800-63B)
- Requerir mayúsculas + minúsculas + números + símbolos
- Hashear en servidor (bcrypt, argon2, scrypt)
- Usar solo HTTPS (nunca HTTP)
- Implementar limitación de tasa (5 intentos, bloqueo de 15 min)
- Usar tokens aleatorios seguros (crypto.getRandomValues)

❌ **NO HAGAS:**
- Enviar contraseñas en texto plano
- Almacenar contraseñas sin hashear
- Requerir cambios frecuentes (NIST dice que no)
- Restringir caracteres especiales
- Implementar pistas de contraseña
- Mostrar requisitos de contraseña DESPUÉS del envío

### 3. Mensajes de Error: Sé Útil, No Revelador

✅ **Buenos mensajes de error:**
```
✅ "Email ya registrado. Intenta iniciar sesión en su lugar."
✅ "La contraseña debe contener mayúsculas, números y caracteres especiales."
✅ "El username debe tener 3-20 caracteres, solo minúsculas."
```

❌ **Malos mensajes de error:**
```
❌ "Entrada inválida"
❌ "Error"
❌ "Email no encontrado" (revela si el email existe)
❌ "Username ocupado" (revela si el username existe)
```

**¿Por qué?** Los buenos mensajes ayudan a los usuarios a corregir errores. Los malos mensajes filtran información (ataques de enumeración de email).

### 4. Limitación de Tasa: Prevenir Fuerza Bruta

```typescript
// Lado del servidor (pseudo-código)
async function handleSignUp(email, password) {
  // Verificar límite de tasa: máximo 5 intentos por 15 minutos
  const attempts = await getRecentAttempts(email)
  
  if (attempts >= 5) {
    const oldestAttempt = attempts[0].timestamp
    const timeSinceOldest = Date.now() - oldestAttempt
    
    if (timeSinceOldest < 15 * 60 * 1000) {
      // Todavía dentro de la ventana de 15 minutos
      throw new Error('Demasiados intentos. Intenta más tarde.')
    }
  }
  
  // Validar y crear cuenta...
}
```

### 5. Protección CSRF

```typescript
// Incluir token CSRF en envío de formulario
<form>
  <input type="hidden" name="csrf_token" value={csrfToken} />
  {/* campos del formulario */}
</form>

// El servidor valida el token
if (request.body.csrf_token !== session.csrf_token) {
  throw new Error('Token CSRF inválido')
}
```

---

## Avanzado: useId para Formularios Accesibles

**Problema:** Las etiquetas de formulario necesitan IDs únicos para asociarse con inputs. Codificar IDs causa problemas:
- IDs duplicados en SSR (servidor + cliente)
- Colisiones de ID al reutilizar componentes
- La gestión manual de IDs es propensa a errores

**Solución:** `useId` genera IDs únicos y estables automáticamente.

### ¿Qué es useId?

`useId` genera un ID único que:
- ✅ Es estable a través de renders
- ✅ Funciona con renderizado del lado del servidor
- ✅ Previene colisiones de ID
- ✅ Es automáticamente único por instancia de componente

### Cómo Funciona

```tsx
import { useId } from 'react'

function SignUpForm() {
  // Generar IDs únicos para esta instancia de formulario
  const usernameId = useId()
  const emailId = useId()
  const passwordId = useId()
  
  return (
    <form>
      {/* Label htmlFor coincide con input id */}
      <label htmlFor={usernameId}>Username</label>
      <input id={usernameId} name="username" />
      
      <label htmlFor={emailId}>Email</label>
      <input id={emailId} name="email" type="email" />
      
      <label htmlFor={passwordId}>Contraseña</label>
      <input id={passwordId} name="password" type="password" />
    </form>
  )
}
```

### Por Qué Esto Importa para Accesibilidad

**Sin IDs apropiados:**
```html
<!-- ❌ MALO: Etiqueta no asociada con input -->
<label>Username</label>
<input name="username" />

<!-- El lector de pantalla no puede conectarlos -->
<!-- Hacer clic en la etiqueta no enfoca el input -->
```

**Con useId:**
```html
<!-- ✅ BUENO: Etiqueta apropiadamente asociada -->
<label for="username-abc123">Username</label>
<input id="username-abc123" name="username" />

<!-- El lector de pantalla anuncia: "Username input" -->
<!-- Hacer clic en la etiqueta enfoca el input -->
```

### Formulario Accesible Completo

```tsx
import { useId } from 'react'
import { useForm } from 'react-hook-form'
import { zodResolver } from '@hookform/resolvers/zod'
import { signUpSchema } from '@/features/auth/schemas'
import type { SignUpInput } from '@/features/auth/schemas'

export function AccessibleSignUpForm() {
  // Generar IDs únicos para esta instancia de formulario
  const usernameId = useId()
  const emailId = useId()
  const passwordId = useId()
  const confirmPasswordId = useId()
  
  const { register, handleSubmit, formState: { errors } } = useForm<SignUpInput>({
    resolver: zodResolver(signUpSchema),
  })

  return (
    <form onSubmit={handleSubmit(onSubmit)} className="space-y-4">
      {/* Campo Username */}
      <div>
        <label htmlFor={usernameId} className="block text-sm font-medium mb-2">
          Username
          <span className="text-red-500" aria-label="requerido">*</span>
        </label>
        <input
          id={usernameId}
          {...register('username')}
          placeholder="3-20 caracteres, solo minúsculas"
          className="w-full px-4 py-2 bg-slate-800 border border-slate-700 rounded-lg"
          aria-invalid={!!errors.username}
          aria-describedby={errors.username ? `${usernameId}-error` : undefined}
        />
        {errors.username && (
          <p id={`${usernameId}-error`} className="text-red-400 text-sm mt-1" role="alert">
            {errors.username.message}
          </p>
        )}
      </div>

      {/* Campo Email */}
      <div>
        <label htmlFor={emailId} className="block text-sm font-medium mb-2">
          Email
          <span className="text-red-500" aria-label="requerido">*</span>
        </label>
        <input
          id={emailId}
          type="email"
          {...register('email')}
          placeholder="tu@email.com"
          className="w-full px-4 py-2 bg-slate-800 border border-slate-700 rounded-lg"
          aria-invalid={!!errors.email}
          aria-describedby={errors.email ? `${emailId}-error` : undefined}
        />
        {errors.email && (
          <p id={`${emailId}-error`} className="text-red-400 text-sm mt-1" role="alert">
            {errors.email.message}
          </p>
        )}
      </div>

      {/* Campo Contraseña */}
      <div>
        <label htmlFor={passwordId} className="block text-sm font-medium mb-2">
          Contraseña
          <span className="text-red-500" aria-label="requerido">*</span>
        </label>
        <input
          id={passwordId}
          type="password"
          {...register('password')}
          placeholder="Mín 8 caracteres, mayúscula, número, carácter especial"
          className="w-full px-4 py-2 bg-slate-800 border border-slate-700 rounded-lg"
          aria-invalid={!!errors.password}
          aria-describedby={errors.password ? `${passwordId}-error` : undefined}
        />
        {errors.password && (
          <p id={`${passwordId}-error`} className="text-red-400 text-sm mt-1" role="alert">
            {errors.password.message}
          </p>
        )}
      </div>

      {/* Campo Confirmar Contraseña */}
      <div>
        <label htmlFor={confirmPasswordId} className="block text-sm font-medium mb-2">
          Confirmar Contraseña
          <span className="text-red-500" aria-label="requerido">*</span>
        </label>
        <input
          id={confirmPasswordId}
          type="password"
          {...register('confirmPassword')}
          placeholder="Re-ingresa tu contraseña"
          className="w-full px-4 py-2 bg-slate-800 border border-slate-700 rounded-lg"
          aria-invalid={!!errors.confirmPassword}
          aria-describedby={errors.confirmPassword ? `${confirmPasswordId}-error` : undefined}
        />
        {errors.confirmPassword && (
          <p id={`${confirmPasswordId}-error`} className="text-red-400 text-sm mt-1" role="alert">
            {errors.confirmPassword.message}
          </p>
        )}
      </div>

      <button
        type="submit"
        className="w-full px-4 py-3 bg-blue-600 text-white rounded-lg hover:bg-blue-700 font-medium"
      >
        Crear Cuenta
      </button>
    </form>
  )
}
```

### Atributos de Accesibilidad Explicados

| Atributo | Propósito | Ejemplo |
|-----------|-----------|---------|
| `htmlFor` | Enlaza etiqueta con input | `<label htmlFor={id}>` |
| `id` | Identificador único | `<input id={id}>` |
| `aria-invalid` | Marca campos inválidos | `aria-invalid={hasError}` |
| `aria-describedby` | Enlaza mensajes de error | `aria-describedby={errorId}` |
| `role="alert"` | Anuncia errores | `<p role="alert">` |

### Beneficios Clave

✅ **IDs únicos** - Sin colisiones, incluso con múltiples formularios
✅ **Compatible con SSR** - Funciona con renderizado del lado del servidor
✅ **Accesible** - Los lectores de pantalla entienden la estructura del formulario
✅ **Navegación por teclado** - Hacer clic en etiquetas enfoca inputs
✅ **Reutilizable** - El mismo componente funciona múltiples veces

### Cuándo Usar useId

- ✅ Etiquetas de formulario e inputs
- ✅ IDs de diálogo para aria-labelledby
- ✅ IDs de elementos de lista
- ✅ Cualquier elemento que necesite ID único
- ❌ NO para IDs de base de datos (usa UUIDs en su lugar)
- ❌ NO para claves en listas (usa IDs de datos únicos)

---

## Resumen: Patrones de Validación

### Conceptos Clave

1. **Pirámide de Validación**: Múltiples capas, cada una captura diferentes errores
   ```
   Servidor > Respuesta API > Envío > Tiempo Real > HTML5
   ```

2. **Nunca confíes en el cliente**: Siempre valida en el servidor
   ```tsx
   // Validación del cliente: Para UX
   // Validación del servidor: Para seguridad
   ```

3. **Validación asíncrona**: Verificar disponibilidad de email
   ```tsx
   const schema = signUpSchema.refine(async (data) => {
     const exists = await checkEmailExists(data.email)
     return !exists
   })
   ```

4. **Seguridad de contraseña**: Sigue directrices NIST
   - 8+ caracteres
   - Mayúsculas + minúsculas + números + símbolos
   - Hashear con bcrypt/argon2
   - Limitar tasa de intentos

5. **Mensajes de error**: Útiles pero no reveladores
   ```
   ✅ "Email ya registrado"
   ❌ "Email no encontrado"
   ```

### Mejores Prácticas

- ✅ Normalizar entrada (minúsculas, trim)
- ✅ Validar en cliente (UX) Y servidor (seguridad)
- ✅ Usar esquemas Zod para única fuente de verdad
- ✅ Implementar limitación de tasa
- ✅ Usar solo HTTPS
- ✅ Hashear contraseñas (nunca almacenar texto plano)
- ✅ Proporcionar mensajes de error útiles
- ✅ Probar casos extremos de validación
- ❌ No confiar en la validación del lado del cliente
- ❌ No filtrar información en mensajes de error
- ❌ No almacenar contraseñas en logs

---

Siguiente: [Auth Context →](/es/react/7.auth-module/2.auth-context)
