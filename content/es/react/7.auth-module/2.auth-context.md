---
title: Auth Context - Gesti√≥n de Estado Global
description: Domina la API de Context de React para estado de autenticaci√≥n, hook useContext y patrones de provider.
---

# Advertencia

:::u-alert
---
title: Los comentarios en el c√≥digo son solo para fines educativos.
description: En proyectos reales, evita agregar comentarios irrelevantes o redundantes.
color: warning
variant: subtle
icon: i-lucide-triangle-alert
---
:::

El estado de autenticaci√≥n necesita ser accesible **en todas partes**: navbar, rutas protegidas, perfil de usuario, formularios de posts. Pasarlo a trav√©s de props ser√≠a una pesadilla. La **API de Context** resuelve esto proporcionando estado global.

---

## El Problema: Infierno de Prop Drilling

Antes de Context, compartir estado a trav√©s de la aplicaci√≥n requer√≠a pasar props a trav√©s de CADA componente en el √°rbol, incluso si no lo usan.

**Escenario de ejemplo**: Autenticaci√≥n de usuario

```tsx
// ‚ùå PROP DRILLING: Pasando usuario a trav√©s de 5 niveles!

function App() {
  const [user, setUser] = useState<User | null>(null)
  
  return <Layout user={user} setUser={setUser} />
}

function Layout({ user, setUser }) {
  // Layout no usa user, solo lo pasa hacia abajo!
  return (
    <div>
      <Navbar user={user} setUser={setUser} />
      <Main user={user} />
    </div>
  )
}

function Navbar({ user, setUser }) {
  // Navbar no usa user, solo lo pasa hacia abajo!
  return (
    <nav>
      <Logo />
      <UserMenu user={user} setUser={setUser} />
    </nav>
  )
}

function UserMenu({ user, setUser }) {
  // ¬°FINALMENTE! Este componente realmente usa user
  return (
    <div>
      {user ? (
        <button onClick={() => setUser(null)}>Sign Out</button>
      ) : (
        <Link to="/sign-in">Sign In</Link>
      )}
    </div>
  )
}
```

**Diagrama visual:**
```
        App (tiene user)
         ‚Üì props
      Layout (no necesita user, solo lo pasa)
         ‚Üì props
       Navbar (no necesita user, solo lo pasa)
         ‚Üì props
      UserMenu (¬°FINALMENTE usa user!)
```

**Problemas con prop drilling:**
- ‚ùå **Tedioso**: Agregar props a cada componente intermedio
- ‚ùå **Fr√°gil**: Cambiar firma, actualizar TODO
- ‚ùå **Diff√≠cil de leer**: Es dif√≠cil ver de d√≥nde se originan los datos
- ‚ùå **Ineficiente**: Los componentes se re-renderizan incluso si no usan el prop

---

## La Soluci√≥n: API de Context de React

**Context** te permite "teletransportar" datos de un padre a CUALQUIER descendiente, saltando componentes intermedios.

**Con Context:**
```tsx
// ‚úÖ CONTEXT: Acceso directo desde cualquier componente!

function App() {
  return (
    <AuthProvider>  {/* Proporciona estado de usuario */}
      <Layout />
    </AuthProvider>
  )
}

function Layout() {
  // ¬°Sin props de usuario! ¬°Limpio!
  return (
    <div>
      <Navbar />
      <Main />
    </div>
  )
}

function Navbar() {
  // ¬°Sin props de usuario! ¬°Limpio!
  return (
    <nav>
      <Logo />
      <UserMenu />
    </nav>
  )
}

function UserMenu() {
  // Acceso directo a usuario v√≠a hook useAuth!
  const { user, signOut } = useAuth()
  
  return (
    <div>
      {user ? (
        <button onClick={signOut}>Sign Out</button>
      ) : (
        <Link to="/sign-in">Sign In</Link>
      )}
    </div>
  )
}
```

**Diagrama visual:**
```
        App
         |
    AuthProvider (proporciona estado de usuario)
         |
      Layout (¬°sin props!)
         |
       Navbar (¬°sin props!)
         |
      UserMenu ‚îÄ‚îÄ‚îÄ useAuth() ‚îÄ‚îÄ‚Üí ¬°Obtiene usuario directamente!
```

**Beneficios:**
- ‚úÖ **Sin prop drilling**: Salta componentes intermedios
- ‚úÖ **Componentes limpios**: Solo los componentes que necesitan datos acceden a ellos
- ‚úÖ **F√°cil refactorizaci√≥n**: Mueve componentes sin cambiar props
- ‚úÖ **Mejor rendimiento**: Los componentes intermedios no se re-renderizan

---

## API de Context: Las Tres Piezas

Context requiere tres piezas:

### 1. Crear Context

```tsx
import { createContext } from 'react'

/**
 * createContext: Crear un "canal" para datos
 * 
 * Pi√©nsalo como una frecuencia de radio:
 * - Provider transmite en esta frecuencia
 * - Consumers sintonizan a esta frecuencia
 * - Sin interferencia con otras frecuencias (contexts)
 */
const AuthContext = createContext<AuthContextType | undefined>(undefined)
```

**¬øPor qu√© `undefined` como valor por defecto?**
- Fuerza a envolver la aplicaci√≥n en Provider
- Si olvidas, obtienes un error claro
- Previene usar context accidentalmente fuera de Provider

### 2. Componente Provider

```tsx
export function AuthProvider({ children }: { children: ReactNode }) {
  // El estado vive aqu√≠
  const [user, setUser] = useState<User | null>(null)
  
  /**
   * Provider: Transmite datos a descendientes
   * 
   * value: Qu√© compartir (estado + funciones)
   * children: Componentes que pueden acceder a estos datos
   */
  return (
    <AuthContext.Provider value={{ user, setUser }}>
      {children}
    </AuthContext.Provider>
  )
}
```

**Patr√≥n Provider:**
- Envuelve tu aplicaci√≥n (o parte de ella)
- Contiene el estado real
- Pasa estado + setters v√≠a prop `value`
- Re-renderiza consumers cuando `value` cambia

### 3. Hook useContext

```tsx
import { useContext } from 'react'

/**
 * useContext: Acceder context desde cualquier descendiente
 * 
 * Como sintonizar una radio a una frecuencia:
 * - Escucha canal AuthContext
 * - Obtiene el valor actual
 * - Se re-renderiza cuando el valor cambia
 */
export function useAuth() {
  const context = useContext(AuthContext)
  
  // Verificaci√≥n de seguridad: Asegurar uso dentro de Provider
  if (!context) {
    throw new Error('useAuth debe usarse dentro de AuthProvider')
  }
  
  return context
}
```

**¬øPor qu√© hook personalizado (`useAuth`) en lugar de usar `useContext` directamente?**
- ‚úÖ **Seguridad de tipos**: Sin verificaciones de undefined en todas partes
- ‚úÖ **Mejores errores**: Mensaje claro si se usa incorrectamente
- ‚úÖ **Abstracci√≥n**: Oculta detalles de implementaci√≥n de Context
- ‚úÖ **Convenci√≥n**: M√°s f√°cil de entender (`useAuth` vs `useContext(AuthContext)`)

---

## Implementaci√≥n Completa de Auth Context

```tsx
// src/contexts/AuthContext.tsx

import { createContext, useContext, useState, useEffect, ReactNode } from 'react'
import { apiClient } from '@/lib/api-client'

interface User {
  id: string
  username: string
  email: string
  role: 'user' | 'moderator' | 'admin'
  avatarUrl: string | null
}

interface AuthContextType {
  user: User | null
  isLoading: boolean
  isAuthenticated: boolean
  signIn: (email: string, password: string) => Promise<void>
  signUp: (data: SignUpData) => Promise<void>
  signOut: () => void
}

const AuthContext = createContext<AuthContextType | undefined>(undefined)

export function AuthProvider({ children }: { children: ReactNode }) {
  const [user, setUser] = useState<User | null>(null)
  const [isLoading, setIsLoading] = useState(true)

  useEffect(() => {
    // Verificar token existente al montar
    const token = localStorage.getItem('auth_token')
    if (token) {
      fetchUser()
    } else {
      setIsLoading(false)
    }
  }, [])

  const fetchUser = async () => {
    try {
      const response = await apiClient.get<User>('/auth/me')
      setUser(response.data)
    } catch (error) {
      localStorage.removeItem('auth_token')
    } finally {
      setIsLoading(false)
    }
  }

  const signIn = async (email: string, password: string) => {
    const response = await apiClient.post('/auth/signin', { email, password })
    localStorage.setItem('auth_token', response.data.token)
    setUser(response.data.user)
  }

  const signUp = async (data: SignUpData) => {
    const response = await apiClient.post('/auth/signup', data)
    localStorage.setItem('auth_token', response.data.token)
    setUser(response.data.user)
  }

  const signOut = () => {
    localStorage.removeItem('auth_token')
    setUser(null)
  }

  return (
    <AuthContext.Provider value={{
      user,
      isLoading,
      isAuthenticated: !!user,
      signIn,
      signUp,
      signOut,
    }}>
      {children}
    </AuthContext.Provider>
  )
}

export function useAuth() {
  const context = useContext(AuthContext)
  if (!context) {
    throw new Error('useAuth debe usarse dentro de AuthProvider')
  }
  return context
}
```

---

## Uso

```tsx
// src/App.tsx

import { AuthProvider } from '@/contexts/AuthContext'

export function App() {
  return (
    <AuthProvider>
      <BrowserRouter>
        <Routes>
          {/* ... */}
        </Routes>
      </BrowserRouter>
    </AuthProvider>
  )
}

// En cualquier componente:
import { useAuth } from '@/contexts/AuthContext'

function Navbar() {
  const { user, isAuthenticated, signOut } = useAuth()

  if (!isAuthenticated) {
    return <Link to="/sign-in">Sign In</Link>
  }

  return (
    <div>
      <span>¬°Bienvenido, {user.username}!</span>
      <button onClick={signOut}>Sign Out</button>
    </div>
  )
}
```

---

## Optimizaci√≥n de Context: Prevenir Re-renders Innecesarios

**Problema**: Cada vez que el valor de Provider cambia, TODOS los consumidores se re-renderizan.

```tsx
// ‚ùå MALO: Crea nuevo objeto cada render!
function AuthProvider({ children }) {
  const [user, setUser] = useState(null)
  const [theme, setTheme] = useState('dark')
  
  return (
    <AuthContext.Provider value={{
      user,        // ¬°Objeto diferente cada vez!
      setUser,     // Misma funci√≥n, pero en nuevo objeto
      theme,       // ¬°Cambios de estado no relacionados causan re-renders!
      setTheme,
    }}>
      {children}
    </AuthContext.Provider>
  )
}

// Componente que solo se preocupa por user
function UserMenu() {
  const { user } = useAuth()
  // ¬°Se re-renderiza cuando theme cambia! üò±
  return <div>{user?.name}</div>
}
```

**Soluci√≥n 1: useMemo para memoizar valor**

```tsx
import { useMemo } from 'react'

function AuthProvider({ children }) {
  const [user, setUser] = useState(null)
  const [isLoading, setIsLoading] = useState(true)
  
  /**
   * useMemo: Solo crear nuevo objeto de valor cuando las dependencias cambian
   * 
   * Sin useMemo: Nuevo objeto cada render
   * Con useMemo: Mismo objeto hasta que user/isLoading cambie
   */
  const value = useMemo(
    () => ({
      user,
      isLoading,
      isAuthenticated: !!user,
      signIn,
      signUp,
      signOut,
    }),
    [user, isLoading]  // Solo recrear cuando estos cambien
  )
  
  return (
    <AuthContext.Provider value={value}>
      {children}
    </AuthContext.Provider>
  )
}
```

**Soluci√≥n 2: Dividir contexts por preocupaci√≥n**

```tsx
// ‚ùå Un context grande (theme y auth no relacionados)
const AppContext = createContext({ user, theme, ... })

// ‚úÖ Contextos separados
const AuthContext = createContext({ user, ... })
const ThemeContext = createContext({ theme, ... })

// Ahora los componentes solo se re-renderizan para cambios relevantes
function UserMenu() {
  const { user } = useAuth()  // Solo se re-renderiza cuando auth cambia
  return <div>{user?.name}</div>
}

function ThemeSwitcher() {
  const { theme, setTheme } = useTheme()  // Solo se re-renderiza cuando theme cambia
  return <button onClick={() => setTheme('light')}>Toggle</button>
}
```

---

## M√∫ltiples Contexts: Patr√≥n de Composici√≥n

**Problema**: La aplicaci√≥n necesita m√∫ltiples contexts (auth, theme, notifications, etc.)

**Soluci√≥n**: Componer Providers

```tsx
// src/App.tsx

import { AuthProvider } from '@/contexts/AuthContext'
import { ThemeProvider } from '@/contexts/ThemeContext'
import { NotificationProvider } from '@/contexts/NotificationContext'

function App() {
  return (
    <AuthProvider>
      <ThemeProvider>
        <NotificationProvider>
          <BrowserRouter>
            <Routes>{/* ... */}</Routes>
          </BrowserRouter>
        </NotificationProvider>
      </ThemeProvider>
    </AuthProvider>
  )
}
```

**Mejor: Componente AppProviders**

```tsx
// src/providers/AppProviders.tsx

export function AppProviders({ children }: { children: ReactNode }) {
  return (
    <AuthProvider>
      <ThemeProvider>
        <NotificationProvider>
          {children}
        </NotificationProvider>
      </ThemeProvider>
    </AuthProvider>
  )
}

// src/App.tsx
function App() {
  return (
    <AppProviders>
      <BrowserRouter>
        <Routes>{/* ... */}</Routes>
      </BrowserRouter>
    </AppProviders>
  )
}
```

---

## Cu√°ndo Usar Context

‚úÖ **Usa Context cuando:**
- Datos necesarios en muchos componentes a diferentes niveles de anidamiento
- Prop drilling se vuelve doloroso (>3 niveles)
- Datos cambian infrecuentemente (autenticaci√≥n, theme, locale)
- Quieres interfaces de componentes m√°s limpias

**Ejemplos en nuestro forum:**
- ‚úÖ Autenticaci√≥n (usada en todas partes)
- ‚úÖ Theme (modo oscuro/claro)
- ‚úÖ Locale (i18n)
- ‚úÖ Notificaciones (sistema toast)

‚ùå **No uses Context cuando:**
- Datos solo se usan en un lugar
- Datos cambian muy frecuentemente (causa muchos re-renders)
- Necesitas debugging de time-travel (usa Redux/Zustand)
- La gesti√≥n de estado es compleja (usa librer√≠a de gesti√≥n de estado)

**Ejemplos en nuestro forum:**
- ‚ùå Estado de formulario (usa React Hook Form)
- ‚ùå Filtros de lista (pasa como props o params de URL)
- ‚ùå Modal abierto/cerrado (estado a nivel de componente)
- ‚ùå Estado hover (estado a nivel de componente)

---

## Context vs Otras Soluciones

| Soluci√≥n | Cu√°ndo Usar | Pros | Contras |
|----------|-------------|------|---------|
| **Props** | 1-2 niveles abajo | Simple, expl√≠cito | Prop drilling |
| **Context** | Muchos niveles, cambios infrecuentes | Sin drilling, limpio | Puede causar re-renders |
| **Zustand/Redux** | Estado complejo, cambios frecuentes | Time-travel, middleware | M√°s boilerplate |
| **React Query** | Estado del servidor | Caching, auto-refetch | Solo para datos del servidor |
| **URL State** | Estado compartible | Bookmarkable, compatible con SSR | Solo para datos serializables |

**Nuestro forum usa:**
- Props: Padre ‚Üí hijo (categor√≠a ‚Üí tarjeta)
- Context: Auth, theme
- React Query: Datos de API (threads, posts)
- URL State: Filtros, b√∫squeda, paginaci√≥n

---

## Probar Context

```tsx
// src/contexts/__tests__/AuthContext.test.tsx

import { render, screen, waitFor } from '@testing-library/react'
import userEvent from '@testing-library/user-event'
import { AuthProvider, useAuth } from '../AuthContext'
import { apiClient } from '@/lib/api-client'

vi.mock('@/lib/api-client')

// Componente de prueba que usa context
function TestComponent() {
  const { user, signIn, signOut } = useAuth()
  
  return (
    <div>
      {user ? (
        <>
          <p>Logged in as: {user.username}</p>
          <button onClick={signOut}>Sign Out</button>
        </>
      ) : (
        <>
          <p>Not logged in</p>
          <button onClick={() => signIn('test@example.com', 'password')}>
            Sign In
          </button>
        </>
      )}
    </div>
  )
}

describe('AuthContext', () => {
  it('provides authentication state', async () => {
    const user = userEvent.setup()
    
    vi.mocked(apiClient.post).mockResolvedValueOnce({
      data: {
        token: 'fake-token',
        user: { id: '1', username: 'alice', email: 'alice@test.com' },
      },
    })
    
    render(
      <AuthProvider>
        <TestComponent />
      </AuthProvider>
    )
    
    // Inicialmente no est√° logged in
    expect(screen.getByText('Not logged in')).toBeInTheDocument()
    
    // Sign in
    await user.click(screen.getByText('Sign In'))
    
    // Deber√≠a estar logged in
    await waitFor(() => {
      expect(screen.getByText('Logged in as: alice')).toBeInTheDocument()
    })
    
    // Sign out
    await user.click(screen.getByText('Sign Out'))
    
    // Deber√≠a estar logged out
    expect(screen.getByText('Not logged in')).toBeInTheDocument()
  })
  
  it('throws error when useAuth used outside Provider', () => {
    // Suprimir console.error para esta prueba
    const spy = vi.spyOn(console, 'error').mockImplementation(() => {})
    
    expect(() => {
      render(<TestComponent />)  // ¬°Sin Provider!
    }).toThrow('useAuth debe usarse dentro de AuthProvider')
    
    spy.mockRestore()
  })
})
```

---

## Resumen: Patrones de API de Context

### Conceptos Clave

1. **Context resuelve prop drilling**
   ```tsx
   // Antes: <A user={u}> ‚Üí <B user={u}> ‚Üí <C user={u}>
   // Despu√©s: <C> usa useAuth() directamente
   ```

2. **Tres piezas requeridas**
   - `createContext`: Crear el canal
   - `Provider`: Transmitir datos
   - `useContext`: Recibir datos

3. **Patr√≥n de hook personalizado**
   ```tsx
   export function useAuth() {
     const context = useContext(AuthContext)
     if (!context) throw new Error('...')
     return context
   }
   ```

4. **Optimizar con useMemo**
   ```tsx
   const value = useMemo(() => ({ user, signIn, signOut }), [user])
   ```

5. **Dividir contexts por preocupaci√≥n**
   - AuthContext: Autenticaci√≥n
   - ThemeContext: UI theme
   - NotificationContext: Toasts

### Mejores Pr√°cticas

- ‚úÖ Usa Context para datos globales, que cambian infrecuentemente
- ‚úÖ Crea hooks personalizados para seguridad de tipos
- ‚úÖ Memoiza el valor de Provider para prevenir re-renders
- ‚úÖ Divide contexts por preocupaci√≥n
- ‚úÖ Prueba providers de context
- ‚ùå No uses Context para datos que cambian frecuentemente
- ‚ùå No pongas datos no relacionados en un context
- ‚ùå No olvides envolver la aplicaci√≥n en Provider

---

Siguiente: [Protected Routes ‚Üí](/es/react/7.auth-module/3.protected-routes)
