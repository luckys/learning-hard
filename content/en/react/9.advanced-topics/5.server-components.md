---
title: Server Components - Full-Stack React Architecture
description: Master React Server Components (React 19). Build full-stack applications with server-side data fetching, reduced bundle size, and seamless client interactivity. Real-world forum examples.
---

# Disclaimer

:::u-alert
---
title: Comments in the code are for educational purposes only.
description: In real projects, avoid adding irrelevant or redundant comments.
color: warning
variant: subtle
icon: i-lucide-triangle-alert
---
:::

React Server Components (RSC) represent a paradigm shift in React architecture. They enable **full-stack React** - writing components that run on the server, access databases directly, and send only the rendered output to the client.

---

## The Problem: Client-Side Data Fetching Waterfalls

### Traditional Client-Side Approach

```tsx
// bundle.js (sent to browser)
import { useState, useEffect } from 'react'

function ThreadDetail({ threadId }) {
  const [thread, setThread] = useState(null)
  const [author, setAuthor] = useState(null)
  const [loading, setLoading] = useState(true)

  useEffect(() => {
    // Fetch thread first
    fetch(`/api/threads/${threadId}`)
      .then(res => res.json())
      .then(data => {
        setThread(data)
        
        // THEN fetch author (waterfall!)
        return fetch(`/api/authors/${data.authorId}`)
      })
      .then(res => res.json())
      .then(data => {
        setAuthor(data)
        setLoading(false)
      })
  }, [threadId])

  if (loading) return <div>Loading...</div>
  
  return (
    <div>
      <h1>{thread.title}</h1>
      <p>By: {author.name}</p>
      <p>{thread.content}</p>
    </div>
  )
}
```

**Problems:**
- âŒ **Waterfall**: Fetch thread â†’ Fetch author (sequential, slow)
- âŒ **Large bundle**: All data-fetching code sent to browser
- âŒ **Slow first paint**: Data loads AFTER page renders
- âŒ **Exposed secrets**: API keys visible in client code
- âŒ **Network overhead**: Multiple round-trips

**Timeline:**
```
t=0ms:    Browser loads page
t=100ms:  JS downloaded and parsed
t=150ms:  First render (empty)
t=200ms:  Fetch thread (request 1)
t=400ms:  Thread response, fetch author (request 2)
t=600ms:  Author response, render complete
Total: 600ms to see content âŒ
```

---

## The Solution: React Server Components

### Server Components: Render on Server

```tsx
// app/thread-detail.tsx (Server Component)
// This code NEVER reaches the browser!

import db from '@/lib/database'

async function ThreadDetail({ threadId }: { threadId: string }) {
  // Fetch directly from database (no API call!)
  const thread = await db.threads.findById(threadId)
  
  // Fetch author in parallel (no waterfall!)
  const author = await db.authors.findById(thread.authorId)

  return (
    <div>
      <h1>{thread.title}</h1>
      <p>By: {author.name}</p>
      <p>{thread.content}</p>
    </div>
  )
}

export default ThreadDetail
```

**Benefits:**
- âœ… **Parallel fetching**: Both queries run simultaneously
- âœ… **Smaller bundle**: Database code never sent to browser
- âœ… **Fast first paint**: Content ready before page loads
- âœ… **Secure**: API keys stay on server
- âœ… **Single request**: All data fetched server-side

**Timeline:**
```
t=0ms:    Server receives request
t=50ms:   Fetch thread + author (parallel!)
t=100ms:  Render component to HTML
t=150ms:  Browser receives HTML
t=150ms:  Page visible with content âœ…
Total: 150ms to see content (4x faster!)
```

---

## Key Concepts: Server vs Client Components

### Server Components

```tsx
// âœ… Server Component (default in Next.js)
// Runs on server, never sent to browser

import db from '@/lib/database'

async function ThreadList() {
  // âœ… Can use async/await
  const threads = await db.threads.findAll()
  
  // âœ… Can access database directly
  // âœ… Can use secrets (API keys, DB passwords)
  // âœ… Can use large libraries (no bundle impact)
  
  return (
    <div>
      {threads.map(thread => (
        <ThreadCard key={thread.id} thread={thread} />
      ))}
    </div>
  )
}

export default ThreadList
```

### Client Components

```tsx
// âŒ Client Component (use "use client" directive)
// Runs in browser, sent to client

'use client'

import { useState } from 'react'

function ThreadCard({ thread }: { thread: Thread }) {
  // âœ… Can use useState, useEffect, etc.
  const [liked, setLiked] = useState(false)
  
  // âŒ Cannot use async/await in component body
  // âŒ Cannot access database directly
  // âŒ Cannot use secrets
  
  return (
    <div>
      <h2>{thread.title}</h2>
      <button onClick={() => setLiked(!liked)}>
        {liked ? 'â¤ï¸' : 'ğŸ¤'} Like
      </button>
    </div>
  )
}

export default ThreadCard
```

### Composition: Server + Client

```tsx
// Server Component (parent)
import db from '@/lib/database'
import ThreadCard from './thread-card' // Client Component

async function ThreadList() {
  // Fetch on server
  const threads = await db.threads.findAll()
  
  return (
    <div>
      {threads.map(thread => (
        // Pass data to Client Component
        <ThreadCard key={thread.id} thread={thread} />
      ))}
    </div>
  )
}

export default ThreadList
```

---

## Real-World Example: Forum Thread Detail Page

### Architecture

```
ThreadDetailPage (Server)
â”œâ”€ Fetch thread from DB
â”œâ”€ Fetch author from DB
â”œâ”€ Fetch posts from DB
â””â”€ Render to HTML
    â””â”€ ThreadHeader (Server)
    â””â”€ ThreadContent (Server)
    â””â”€ PostList (Server)
        â””â”€ PostCard (Client)
            â”œâ”€ Vote button (interactive)
            â””â”€ Reply button (interactive)
```

### Implementation

```tsx
// app/threads/[id]/page.tsx (Server Component)
import db from '@/lib/database'
import { Suspense } from 'react'
import ThreadHeader from './thread-header'
import ThreadContent from './thread-content'
import PostList from './post-list'

async function ThreadDetailPage({ params }: { params: { id: string } }) {
  // Fetch all data in parallel on server
  const [thread, author, posts] = await Promise.all([
    db.threads.findById(params.id),
    db.authors.findById(params.authorId),
    db.posts.findByThreadId(params.id),
  ])

  return (
    <div className="max-w-4xl mx-auto">
      {/* Server Components: rendered on server */}
      <ThreadHeader thread={thread} author={author} />
      <ThreadContent thread={thread} />
      
      {/* Suspense for streaming */}
      <Suspense fallback={<div>Loading posts...</div>}>
        <PostList posts={posts} threadId={params.id} />
      </Suspense>
    </div>
  )
}

export default ThreadDetailPage
```

```tsx
// app/threads/[id]/thread-header.tsx (Server Component)
import db from '@/lib/database'

async function ThreadHeader({ 
  thread, 
  author 
}: { 
  thread: Thread
  author: Author
}) {
  // Can fetch additional data if needed
  const viewCount = await db.threadStats.getViewCount(thread.id)

  return (
    <header className="border-b border-slate-700 pb-4">
      <h1 className="text-3xl font-bold">{thread.title}</h1>
      <div className="flex items-center gap-2 mt-2 text-slate-400">
        <img 
          src={author.avatarUrl} 
          alt={author.name}
          className="w-8 h-8 rounded-full"
        />
        <span>{author.name}</span>
        <span>â€¢</span>
        <span>{viewCount} views</span>
      </div>
    </header>
  )
}

export default ThreadHeader
```

```tsx
// app/threads/[id]/post-card.tsx (Client Component)
'use client'

import { useState } from 'react'
import { useTransition } from 'react'

function PostCard({ post }: { post: Post }) {
  const [liked, setLiked] = useState(false)
  const [isPending, startTransition] = useTransition()

  const handleLike = () => {
    startTransition(async () => {
      // Call Server Action to update like
      await updatePostLike(post.id, !liked)
      setLiked(!liked)
    })
  }

  return (
    <div className="border border-slate-700 rounded-lg p-4">
      <div className="flex items-center gap-2 mb-2">
        <img 
          src={post.author.avatarUrl}
          alt={post.author.name}
          className="w-8 h-8 rounded-full"
        />
        <span className="font-medium">{post.author.name}</span>
      </div>
      
      <p className="text-slate-300 mb-4">{post.content}</p>
      
      <button
        onClick={handleLike}
        disabled={isPending}
        className="flex items-center gap-1 text-slate-400 hover:text-red-400"
      >
        {liked ? 'â¤ï¸' : 'ğŸ¤'} {post.likeCount}
      </button>
    </div>
  )
}

export default PostCard
```

---

## Server Components vs Traditional Approaches

### Comparison Table

| Aspect | Traditional SPA | Server Components |
|--------|-----------------|-------------------|
| **Data fetching** | Client-side (useEffect) | Server-side (async) |
| **Bundle size** | Large (includes DB code) | Small (no DB code) |
| **First paint** | Slow (wait for JS + fetch) | Fast (HTML ready) |
| **Waterfall** | Yes (fetch â†’ render â†’ fetch) | No (parallel fetches) |
| **Security** | Exposed secrets | Secrets safe on server |
| **Interactivity** | Immediate | Streaming |
| **SEO** | Requires SSR | Built-in |

---

## Advanced: Streaming with Suspense

### Progressive Rendering

```tsx
// Server Component with streaming
import { Suspense } from 'react'
import db from '@/lib/database'

async function ThreadPage({ threadId }: { threadId: string }) {
  // Critical data: fetch immediately
  const thread = await db.threads.findById(threadId)

  return (
    <div>
      {/* Render critical content immediately */}
      <ThreadHeader thread={thread} />
      
      {/* Stream non-critical content */}
      <Suspense fallback={<PostsSkeleton />}>
        <PostList threadId={threadId} />
      </Suspense>
      
      <Suspense fallback={<CommentsSkeleton />}>
        <CommentSection threadId={threadId} />
      </Suspense>
    </div>
  )
}

async function PostList({ threadId }: { threadId: string }) {
  // This fetches after page starts streaming
  const posts = await db.posts.findByThreadId(threadId)
  
  return (
    <div>
      {posts.map(post => (
        <PostCard key={post.id} post={post} />
      ))}
    </div>
  )
}

async function CommentSection({ threadId }: { threadId: string }) {
  // This fetches in parallel with PostList
  const comments = await db.comments.findByThreadId(threadId)
  
  return (
    <div>
      {comments.map(comment => (
        <Comment key={comment.id} comment={comment} />
      ))}
    </div>
  )
}

export default ThreadPage
```

**Timeline with Streaming:**
```
t=0ms:    Server receives request
t=50ms:   Fetch thread
t=100ms:  Send HTML with thread (browser starts rendering)
t=150ms:  Fetch posts + comments (in parallel)
t=300ms:  Send posts HTML
t=400ms:  Send comments HTML
t=400ms:  Page fully interactive

User sees content progressively! âœ…
```

---

## Migration: Categories Module to Server Components

### Before: Client-Side Fetching

```tsx
// OLD: Client Component
'use client'

import { useState, useEffect } from 'react'

function CategoriesPage() {
  const [categories, setCategories] = useState([])
  const [loading, setLoading] = useState(true)

  useEffect(() => {
    fetch('/api/categories')
      .then(res => res.json())
      .then(data => {
        setCategories(data)
        setLoading(false)
      })
  }, [])

  if (loading) return <div>Loading...</div>

  return (
    <div className="grid gap-4">
      {categories.map(cat => (
        <CategoryCard key={cat.id} category={cat} />
      ))}
    </div>
  )
}
```

### After: Server Component

```tsx
// NEW: Server Component
import db from '@/lib/database'
import CategoryCard from './category-card'

async function CategoriesPage() {
  // Fetch directly from database
  const categories = await db.categories.findAll()

  return (
    <div className="grid gap-4">
      {categories.map(cat => (
        <CategoryCard key={cat.id} category={cat} />
      ))}
    </div>
  )
}

export default CategoriesPage
```

**Benefits:**
- âœ… No loading state needed (data ready before render)
- âœ… No useEffect (simpler code)
- âœ… No API endpoint needed
- âœ… Direct database access
- âœ… Smaller bundle (no fetch code)
- âœ… Faster first paint

---

## Best Practices

### âœ… DO

- âœ… Fetch data in Server Components
- âœ… Use async/await for data fetching
- âœ… Keep secrets on server
- âœ… Use Server Components by default
- âœ… Use Client Components only for interactivity
- âœ… Stream non-critical content with Suspense

### âŒ DON'T

- âŒ Use useState in Server Components
- âŒ Use browser APIs in Server Components
- âŒ Fetch data in Client Components (unless necessary)
- âŒ Send large libraries to client
- âŒ Expose secrets in Client Components
- âŒ Make Server Components interactive

---

## Performance Impact

### Bundle Size Reduction

```
Traditional SPA:
â”œâ”€ React library: 42KB
â”œâ”€ React Router: 15KB
â”œâ”€ Data fetching code: 20KB
â”œâ”€ Database drivers: 50KB
â””â”€ Total: 127KB

Server Components:
â”œâ”€ React library: 42KB
â”œâ”€ React Router: 15KB
â”œâ”€ Data fetching code: 0KB (server-side)
â”œâ”€ Database drivers: 0KB (server-side)
â””â”€ Total: 57KB

Reduction: 55% smaller bundle! ğŸš€
```

### Time to Interactive

```
Traditional SPA:
1. Download JS (100ms)
2. Parse JS (50ms)
3. Render (100ms)
4. Fetch data (200ms)
5. Render with data (100ms)
Total: 550ms

Server Components:
1. Fetch data (100ms)
2. Render to HTML (50ms)
3. Send HTML (50ms)
4. Browser renders (50ms)
Total: 250ms

4.4x faster! ğŸ¯
```

---

## Summary: Server Components

### Key Concepts

1. **Server Components**: Run on server, render to HTML
2. **Client Components**: Run in browser, handle interactivity
3. **Async Components**: Use async/await in Server Components
4. **Streaming**: Send HTML progressively with Suspense
5. **Composition**: Mix Server and Client Components

### When to Use

- âœ… **Server Components**: Data fetching, database access, secrets
- âœ… **Client Components**: Interactivity, state, browser APIs

### Benefits

- âœ… Smaller bundles
- âœ… Faster first paint
- âœ… No waterfalls
- âœ… Secure (secrets on server)
- âœ… Better SEO
- âœ… Simpler code

---

Next: [Deployment â†’](/en/react/9.advanced-topics/4.deployment)
