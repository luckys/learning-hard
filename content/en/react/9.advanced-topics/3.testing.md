---
title: Testing React Components - Unit, Integration & E2E Testing
description: Master testing strategies: unit tests, integration tests, mocking, testing best practices, and test coverage. Build confidence in your forum code.
---

# Disclaimer

:::u-alert
---
title: Comments in the code are for educational purposes only.
description: In real projects, avoid adding irrelevant or redundant comments.
color: warning
variant: subtle
icon: i-lucide-triangle-alert
---
:::

Testing ensures your forum works correctly. **Tests are documentation.** They show how code should behave. We use React Testing Library + Vitest.

---

## Testing Pyramid: The Right Balance

```
        /\
       /  \
      / E2E \        Few (expensive, slow)
     /______\
    /        \
   /Integration\    Some (moderate cost)
  /____________\
 /              \
/   Unit Tests   \  Many (cheap, fast)
/________________\
```

**Unit tests**: Test individual functions/components in isolation
**Integration tests**: Test multiple components working together
**E2E tests**: Test entire user flows (expensive, use sparingly)

---

## Testing Philosophy: Test Behavior, Not Implementation

```tsx
// ❌ BAD: Testing implementation details
it('sets state to true', () => {
  const { result } = renderHook(() => useState(false))
  act(() => {
    result.current[1](true)
  })
  expect(result.current[0]).toBe(true)
})

// ✅ GOOD: Testing user behavior
it('shows success message when form submitted', async () => {
  const user = userEvent.setup()
  render(<SignUpForm />)
  
  await user.type(screen.getByLabelText('Email'), 'alice@example.com')
  await user.type(screen.getByLabelText('Password'), 'SecurePass123!')
  await user.click(screen.getByRole('button', { name: /sign up/i }))
  
  await waitFor(() => {
    expect(screen.getByText('Account created!')).toBeInTheDocument()
  })
})
```

**Why?** Implementation changes shouldn't break tests. User behavior is stable.

---

## Unit Tests: Test Components in Isolation

```tsx
// src/components/threads/__tests__/ThreadCard.test.tsx

import { render, screen } from '@testing-library/react'
import userEvent from '@testing-library/user-event'
import { BrowserRouter } from 'react-router-dom'
import { ThreadCard } from '../ThreadCard'
import type { Thread } from '@/types'

/**
 * Mock data: Realistic thread for testing
 * 
 * Use factories for complex objects:
 * - Consistent mock data
 * - Easy to extend
 * - Self-documenting
 */
const createMockThread = (overrides?: Partial<Thread>): Thread => ({
  id: '01HXQK9Z3XAMPLE000001',
  title: 'How to learn React?',
  slug: 'how-to-learn-react',
  content: 'I want to learn React...',
  authorId: 'user-1',
  author: {
    id: 'user-1',
    username: 'alice',
    displayName: 'Alice Wonder',
    avatarUrl: null,
  },
  categoryId: 'cat-1',
  category: {
    id: 'cat-1',
    name: 'Learning',
    slug: 'learning',
  },
  isPinned: false,
  isLocked: false,
  viewCount: 42,
  replyCount: 5,
  createdAt: '2024-01-15T10:00:00Z',
  updatedAt: '2024-01-15T10:00:00Z',
  ...overrides,
})

describe('ThreadCard', () => {
  /**
   * Test: Renders thread title
   * 
   * What we're testing:
   * - Component renders without crashing
   * - Title is visible to users
   * 
   * Why this matters:
   * - Users need to see thread titles
   * - Broken rendering = broken UX
   */
  it('renders thread title', () => {
    const thread = createMockThread()
    
    render(
      <BrowserRouter>
        <ThreadCard thread={thread} />
      </BrowserRouter>
    )
    
    expect(screen.getByText('How to learn React?')).toBeInTheDocument()
  })

  /**
   * Test: Shows reply count
   * 
   * What we're testing:
   * - Reply count displays correctly
   * - Plural/singular handling
   */
  it('shows reply count', () => {
    const thread = createMockThread({ replyCount: 5 })
    
    render(
      <BrowserRouter>
        <ThreadCard thread={thread} />
      </BrowserRouter>
    )
    
    expect(screen.getByText(/5 replies/i)).toBeInTheDocument()
  })

  /**
   * Test: Shows singular "reply" for 1 reply
   */
  it('shows singular reply for one reply', () => {
    const thread = createMockThread({ replyCount: 1 })
    
    render(
      <BrowserRouter>
        <ThreadCard thread={thread} />
      </BrowserRouter>
    )
    
    expect(screen.getByText(/1 reply/i)).toBeInTheDocument()
  })

  /**
   * Test: Shows pinned indicator
   * 
   * What we're testing:
   * - Pinned threads show visual indicator
   * - Important threads stand out
   */
  it('shows pinned indicator when thread is pinned', () => {
    const thread = createMockThread({ isPinned: true })
    
    render(
      <BrowserRouter>
        <ThreadCard thread={thread} />
      </BrowserRouter>
    )
    
    expect(screen.getByTitle('Pinned')).toBeInTheDocument()
  })

  /**
   * Test: Navigates to thread on click
   * 
   * What we're testing:
   * - Clicking card navigates to thread
   * - User can open threads
   */
  it('navigates to thread on click', async () => {
    const user = userEvent.setup()
    const thread = createMockThread()
    
    render(
      <BrowserRouter>
        <ThreadCard thread={thread} />
      </BrowserRouter>
    )
    
    const link = screen.getByRole('link')
    expect(link).toHaveAttribute('href', '/threads/how-to-learn-react')
  })
})
```

---

## Integration Tests: Test User Flows

```tsx
// src/pages/__tests__/CreateThreadPage.test.tsx

import { render, screen, waitFor } from '@testing-library/react'
import userEvent from '@testing-library/user-event'
import { BrowserRouter } from 'react-router-dom'
import { QueryClientProvider, QueryClient } from '@tanstack/react-query'
import { CreateThreadPage } from '../CreateThreadPage'
import { apiClient } from '@/lib/api-client'

vi.mock('@/lib/api-client')

/**
 * Integration test: Create thread flow
 * 
 * Tests:
 * 1. User fills form
 * 2. Form validates
 * 3. API called
 * 4. Success message shown
 * 5. User redirected
 * 
 * This tests the ENTIRE flow, not just one component
 */
describe('Create Thread Flow', () => {
  const queryClient = new QueryClient()

  it('creates thread successfully', async () => {
    const user = userEvent.setup()
    
    // Mock API response
    vi.mocked(apiClient.post).mockResolvedValueOnce({
      data: {
        id: 'thread-1',
        title: 'New Thread',
        slug: 'new-thread',
        // ... other fields
      },
    })

    render(
      <QueryClientProvider client={queryClient}>
        <BrowserRouter>
          <CreateThreadPage />
        </BrowserRouter>
      </QueryClientProvider>
    )

    // User fills form
    await user.type(
      screen.getByLabelText(/title/i),
      'New Thread'
    )
    await user.type(
      screen.getByLabelText(/content/i),
      'This is my new thread'
    )

    // User submits
    await user.click(screen.getByRole('button', { name: /create/i }))

    // Success message appears
    await waitFor(() => {
      expect(screen.getByText(/thread created/i)).toBeInTheDocument()
    })

    // API was called with correct data
    expect(apiClient.post).toHaveBeenCalledWith('/threads', {
      title: 'New Thread',
      content: 'This is my new thread',
    })
  })

  /**
   * Test: Validation errors
   * 
   * What we're testing:
   * - Form validates before submission
   * - Errors shown to user
   * - API not called if invalid
   */
  it('shows validation errors', async () => {
    const user = userEvent.setup()

    render(
      <QueryClientProvider client={queryClient}>
        <BrowserRouter>
          <CreateThreadPage />
        </BrowserRouter>
      </QueryClientProvider>
    )

    // Submit empty form
    await user.click(screen.getByRole('button', { name: /create/i }))

    // Errors shown
    await waitFor(() => {
      expect(screen.getByText(/title required/i)).toBeInTheDocument()
      expect(screen.getByText(/content required/i)).toBeInTheDocument()
    })

    // API not called
    expect(apiClient.post).not.toHaveBeenCalled()
  })

  /**
   * Test: API error handling
   * 
   * What we're testing:
   * - Errors from API shown to user
   * - User can retry
   */
  it('handles API errors gracefully', async () => {
    const user = userEvent.setup()
    
    vi.mocked(apiClient.post).mockRejectedValueOnce(
      new Error('Server error')
    )

    render(
      <QueryClientProvider client={queryClient}>
        <BrowserRouter>
          <CreateThreadPage />
        </BrowserRouter>
      </QueryClientProvider>
    )

    // Fill and submit
    await user.type(screen.getByLabelText(/title/i), 'New Thread')
    await user.type(screen.getByLabelText(/content/i), 'Content')
    await user.click(screen.getByRole('button', { name: /create/i }))

    // Error shown
    await waitFor(() => {
      expect(screen.getByText(/server error/i)).toBeInTheDocument()
    })
  })
})
```

---

## Testing Best Practices

### 1. Use Semantic Queries

```tsx
// ❌ BAD: Implementation details
screen.getByTestId('submit-btn')
screen.getByClassName('error-message')

// ✅ GOOD: User-facing queries
screen.getByRole('button', { name: /submit/i })
screen.getByText(/error/i)
```

### 2. Mock External Dependencies

```tsx
// Mock API calls
vi.mock('@/lib/api-client')

// Mock router
vi.mock('react-router-dom', async () => ({
  ...await vi.importActual('react-router-dom'),
  useNavigate: () => vi.fn(),
}))
```

### 3. Test Error Cases

```tsx
it('handles network errors', async () => {
  vi.mocked(apiClient.get).mockRejectedValueOnce(
    new Error('Network error')
  )
  
  render(<ThreadList />)
  
  await waitFor(() => {
    expect(screen.getByText(/network error/i)).toBeInTheDocument()
  })
})
```

### 4. Use Test Factories

```tsx
const createMockThread = (overrides?: Partial<Thread>): Thread => ({
  id: '1',
  title: 'Test',
  // ... defaults
  ...overrides,
})
```

---

## Testing Checklist

- ✅ Test user behavior, not implementation
- ✅ Use semantic queries (getByRole, getByText)
- ✅ Mock external dependencies (API, router)
- ✅ Test error cases
- ✅ Test loading states
- ✅ Test edge cases (empty, 1 item, many items)
- ✅ Use test factories for mock data
- ✅ Test accessibility (ARIA roles)
- ❌ Don't test implementation details
- ❌ Don't mock too much (defeats purpose of integration tests)
- ❌ Don't write tests that are too specific

---

Next: [Deployment →](/en/react/9.advanced-topics/4.deployment)
