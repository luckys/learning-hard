---
title: Performance Optimization - Profiling, Memoization & Code Splitting
description: Master performance optimization: measure before optimizing, React.memo, useMemo, useCallback, code splitting, lazy loading, and Web Vitals. Build fast forums.
---

# Disclaimer

:::u-alert
---
title: Comments in the code are for educational purposes only.
description: In real projects, avoid adding irrelevant or redundant comments.
color: warning
variant: subtle
icon: i-lucide-triangle-alert
---
:::

Performance matters. A slow forum loses users. But premature optimization is the root of all evil. **Measure first, optimize second.**

---

## The Performance Mindset

**The golden rule**: Don't optimize without data.

```
1. Measure (Chrome DevTools)
2. Identify bottleneck
3. Optimize
4. Measure again
5. Verify improvement
```

**Common mistakes:**
- ❌ Optimizing code that's not slow
- ❌ Using React.memo everywhere
- ❌ Memoizing cheap computations
- ❌ Ignoring network performance

---

## React.memo: Prevent Unnecessary Re-renders

**Problem**: Parent re-renders, all children re-render (even if props unchanged).

**Solution**: React.memo skips re-render if props are same.

```tsx
/**
 * React.memo: Shallow comparison of props
 * 
 * Without memo:
 * Parent renders → All children render (even if props same)
 * 
 * With memo:
 * Parent renders → Children only render if props changed
 */
const ThreadCard = memo(function ThreadCard({ thread }: { thread: Thread }) {
  console.log('ThreadCard rendered')
  return <div>{thread.title}</div>
})

// Usage
function ThreadList({ threads }) {
  return (
    <div>
      {threads.map(thread => (
        <ThreadCard key={thread.id} thread={thread} />
      ))}
    </div>
  )
}

// Scenario:
// 1. Parent re-renders (unrelated state change)
// 2. ThreadCard props unchanged
// 3. ThreadCard skips re-render ✅
```

**When to use:**
- ✅ Component renders often
- ✅ Props rarely change
- ✅ Component is expensive to render

**When NOT to use:**
- ❌ Component renders rarely
- ❌ Props always change
- ❌ Component is cheap to render

---

## useMemo: Cache Expensive Computations

**Problem**: Expensive computation runs every render.

**Solution**: useMemo caches result, only recomputes when dependencies change.

```tsx
/**
 * useMemo: Cache expensive calculations
 * 
 * Without useMemo:
 * Every render → Sort threads (expensive!)
 * 
 * With useMemo:
 * Only when threads change → Sort threads
 * Other renders → Use cached result
 */
function ThreadList({ threads, sortBy }) {
  // ❌ BAD: Sorts every render
  // const sorted = threads.sort((a, b) => b.score - a.score)
  
  // ✅ GOOD: Only sorts when threads change
  const sorted = useMemo(() => {
    console.log('Sorting threads...')
    return threads.sort((a, b) => {
      if (sortBy === 'score') return b.score - a.score
      if (sortBy === 'date') return new Date(b.createdAt).getTime() - new Date(a.createdAt).getTime()
      return 0
    })
  }, [threads, sortBy])  // Dependencies
  
  return (
    <div>
      {sorted.map(thread => (
        <ThreadCard key={thread.id} thread={thread} />
      ))}
    </div>
  )
}
```

**When to use:**
- ✅ Expensive computation (sorting, filtering, mapping large arrays)
- ✅ Computation runs frequently
- ✅ Dependencies rarely change

**When NOT to use:**
- ❌ Cheap computation (simple math, string concatenation)
- ❌ Computation runs rarely
- ❌ Dependencies always change

---

## useCallback: Memoize Functions

**Problem**: New function created every render, child re-renders unnecessarily.

**Solution**: useCallback returns same function reference.

```tsx
/**
 * useCallback: Memoize functions
 * 
 * Without useCallback:
 * Every render → New handleClick function
 * Child sees new prop → Re-renders
 * 
 * With useCallback:
 * Same handleClick function (unless dependencies change)
 * Child sees same prop → Skips re-render
 */
function ThreadList({ threads }) {
  // ❌ BAD: New function every render
  // const handleClick = (id: string) => {
  //   console.log('Clicked', id)
  // }
  
  // ✅ GOOD: Same function reference
  const handleClick = useCallback((id: string) => {
    console.log('Clicked', id)
  }, [])  // No dependencies = same function always
  
  return (
    <div>
      {threads.map(thread => (
        <ThreadCard 
          key={thread.id} 
          thread={thread}
          onClick={handleClick}  // Stable reference
        />
      ))}
    </div>
  )
}

// ThreadCard with memo
const ThreadCard = memo(function ThreadCard({ thread, onClick }) {
  return (
    <button onClick={() => onClick(thread.id)}>
      {thread.title}
    </button>
  )
})
```

**When to use:**
- ✅ Passing callback to memoized child
- ✅ Callback used in dependency array
- ✅ Callback is expensive to create

**When NOT to use:**
- ❌ Not passing to memoized child
- ❌ Callback cheap to create
- ❌ Dependencies always change

---

## Code Splitting & Lazy Loading

**Problem**: Bundle too large, slow initial load.

**Solution**: Split code, load only when needed.

```tsx
import { lazy, Suspense } from 'react'

// Load AdminPanel only when needed
const AdminPanel = lazy(() => import('./AdminPanel'))

function App() {
  const [showAdmin, setShowAdmin] = useState(false)
  
  return (
    <div>
      <button onClick={() => setShowAdmin(!showAdmin)}>
        Toggle Admin
      </button>
      
      {showAdmin && (
        <Suspense fallback={<div>Loading admin...</div>}>
          <AdminPanel />
        </Suspense>
      )}
    </div>
  )
}
```

**Benefits:**
- ✅ Smaller initial bundle
- ✅ Faster first page load
- ✅ Load code on-demand

---

## <Profiler>: Measure Component Rendering Performance

**Problem**: You don't know which components are slow. Chrome DevTools shows overall performance, but not per-component.

**Solution**: `<Profiler>` measures rendering time of specific component trees.

### What is <Profiler>?

`<Profiler>` is a built-in React component that measures how long a component tree takes to render and commit.

**Key metrics:**
- **Render time**: How long the component took to render
- **Commit time**: How long React took to apply changes to DOM
- **Phase**: "mount" (first render) or "update" (re-render)

### How It Works

```tsx
import { Profiler } from 'react'

function onRenderCallback(
  id,           // Component identifier
  phase,        // "mount" or "update"
  actualDuration,    // Time spent rendering
  baseDuration,      // Estimated time without memoization
  startTime,    // When React started rendering
  commitTime,   // When React committed changes
  interactions  // Set of interactions
) {
  console.log(`${id} (${phase}) took ${actualDuration}ms`)
}

function ThreadList() {
  return (
    <Profiler id="ThreadList" onRender={onRenderCallback}>
      <div>
        {threads.map(thread => (
          <ThreadCard key={thread.id} thread={thread} />
        ))}
      </div>
    </Profiler>
  )
}
```

### Real-World Example: Profiling Forum Components

```tsx
import { Profiler } from 'react'

/**
 * Log performance metrics to console
 */
function logPerformance(id, phase, actualDuration, baseDuration) {
  console.log(`
    Component: ${id}
    Phase: ${phase}
    Actual: ${actualDuration.toFixed(2)}ms
    Estimated: ${baseDuration.toFixed(2)}ms
    Savings: ${(baseDuration - actualDuration).toFixed(2)}ms
  `)
}

/**
 * Send metrics to analytics service
 */
async function sendToAnalytics(id, phase, actualDuration) {
  if (actualDuration > 100) {  // Only log slow renders
    await fetch('/api/performance', {
      method: 'POST',
      body: JSON.stringify({
        component: id,
        phase,
        duration: actualDuration,
        timestamp: new Date().toISOString(),
      })
    })
  }
}

export function ThreadsPage() {
  const [threads, setThreads] = useState<Thread[]>([])
  const [sortBy, setSortBy] = useState('newest')

  return (
    <div>
      {/* Profile the sort dropdown */}
      <Profiler id="SortControls" onRender={logPerformance}>
        <select value={sortBy} onChange={(e) => setSortBy(e.target.value)}>
          <option value="newest">Newest</option>
          <option value="popular">Popular</option>
          <option value="oldest">Oldest</option>
        </select>
      </Profiler>

      {/* Profile the thread list */}
      <Profiler id="ThreadList" onRender={sendToAnalytics}>
        <div className="space-y-4">
          {threads.map(thread => (
            <ThreadCard key={thread.id} thread={thread} />
          ))}
        </div>
      </Profiler>
    </div>
  )
}
```

### Nested Profilers: Profile Multiple Components

```tsx
function App() {
  return (
    <Profiler id="App" onRender={logPerformance}>
      <Navbar />
      
      <Profiler id="Sidebar" onRender={logPerformance}>
        <Sidebar />
      </Profiler>
      
      <Profiler id="MainContent" onRender={logPerformance}>
        <MainContent />
      </Profiler>
    </Profiler>
  )
}

// Output:
// App (mount) took 45.2ms
// Sidebar (mount) took 12.1ms
// MainContent (mount) took 28.5ms
```

### Profiler + React DevTools

React DevTools has a built-in Profiler tab that visualizes performance data:

1. Open React DevTools
2. Go to "Profiler" tab
3. Click "Record"
4. Interact with your app
5. Click "Stop"
6. See detailed performance breakdown

**Benefits:**
- ✅ Visual representation of render times
- ✅ Identify slow components
- ✅ See which props changed
- ✅ Flamegraph shows component hierarchy

### Performance Comparison: Before & After

```tsx
// BEFORE: No optimization
// ThreadList (update) took 450ms ❌ (renders all 1000 threads)

// AFTER: With React.memo + useMemo
// ThreadList (update) took 12ms ✅ (only re-renders changed threads)

// Improvement: 37x faster!
```

### When to Use <Profiler>

- ✅ Identify slow components
- ✅ Verify optimizations work
- ✅ Monitor performance in production
- ✅ Debug unexpected re-renders
- ✅ Track performance over time

### Performance Profiling Workflow

```
1. Identify slow feature
   ↓
2. Wrap with <Profiler>
   ↓
3. Measure baseline performance
   ↓
4. Apply optimization (React.memo, useMemo, etc.)
   ↓
5. Measure again with <Profiler>
   ↓
6. Verify improvement
   ↓
7. Deploy with confidence
```

### Key Takeaways

✅ **Measure before optimizing** - Use Profiler to find bottlenecks
✅ **Profile in production** - Send metrics to analytics
✅ **Nested profilers** - Profile multiple levels
✅ **React DevTools integration** - Visual performance analysis
✅ **Data-driven decisions** - Optimize what's actually slow

---

## Web Vitals: Measure Real Performance

```typescript
// Measure Core Web Vitals
import { getCLS, getFID, getFCP, getLCP, getTTFB } from 'web-vitals'

getCLS(console.log)  // Cumulative Layout Shift
getFID(console.log)  // First Input Delay
getFCP(console.log)  // First Contentful Paint
getLCP(console.log)  // Largest Contentful Paint
getTTFB(console.log) // Time to First Byte

// Good targets:
// LCP: < 2.5s
// FID: < 100ms
// CLS: < 0.1
```

---

## Performance Checklist

- ✅ Measure with Chrome DevTools
- ✅ Use React.memo for expensive components
- ✅ Use useMemo for expensive computations
- ✅ Use useCallback for callbacks to memoized children
- ✅ Implement code splitting for large features
- ✅ Lazy load images (loading="lazy")
- ✅ Minimize bundle size (tree-shaking, minification)
- ✅ Monitor Web Vitals
- ❌ Don't optimize prematurely
- ❌ Don't memoize everything
- ❌ Don't ignore network performance

---

Next: [Real-time Updates →](/en/react/9.advanced-topics/2.realtime)
