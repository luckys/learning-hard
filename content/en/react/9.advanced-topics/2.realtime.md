---
title: Real-time Updates - WebSockets, SSE & Live Features
description: Master real-time communication in React. Build live notifications, typing indicators, and instant updates with WebSockets, Server-Sent Events, and production-ready patterns.
---

# Disclaimer

:::u-alert
---
title: Comments in the code are for educational purposes only.
description: In real projects, avoid adding irrelevant or redundant comments.
color: warning
variant: subtle
icon: i-lucide-triangle-alert
---
:::

Real-time updates transform forums from static pages to living communities. New posts appear instantly, users see who's typing, notifications arrive without refresh. This is the difference between a forum that feels alive and one that feels dated.

---

## The Problem: Polling is Inefficient

### Traditional Polling Approach

```tsx
// ❌ BAD: Polling every 5 seconds
function ThreadPage() {
  const [posts, setPosts] = useState([])

  useEffect(() => {
    const interval = setInterval(() => {
      fetch('/api/posts')
        .then(res => res.json())
        .then(data => setPosts(data))
    }, 5000) // Poll every 5 seconds

    return () => clearInterval(interval)
  }, [])

  return <div>{/* ... */}</div>
}
```

**Problems:**
- ❌ **Wasteful**: 99% of requests return no new data
- ❌ **Delayed**: Up to 5 seconds delay for new content
- ❌ **Server load**: Constant unnecessary requests
- ❌ **Battery drain**: Mobile devices suffer
- ❌ **Bandwidth**: Wasted on empty responses

**Timeline:**
```
t=0s:     Poll (no new data)
t=5s:     Poll (no new data)
t=7s:     New post created (user doesn't see it yet!)
t=10s:    Poll (sees new post, 3 second delay)
t=15s:    Poll (no new data)
...
```

---

## Real-Time Technologies Comparison

### 1. WebSockets: Bi-directional Communication

**How it works:**
- Full-duplex connection (client ↔ server)
- Persistent connection
- Both sides can send messages anytime

**Pros:**
- ✅ Lowest latency (instant)
- ✅ Bi-directional (client can send to server)
- ✅ Efficient (no HTTP overhead per message)

**Cons:**
- ❌ More complex to implement
- ❌ Requires WebSocket server
- ❌ Harder to scale (stateful connections)

**Use cases:**
- Chat applications
- Collaborative editing
- Gaming
- Live dashboards

### 2. Server-Sent Events (SSE): Server → Client

**How it works:**
- HTTP connection kept open
- Server pushes events to client
- Client cannot send (use regular HTTP for that)

**Pros:**
- ✅ Simple to implement
- ✅ Built-in reconnection
- ✅ Works over HTTP (no special server)
- ✅ Automatic event ID tracking

**Cons:**
- ❌ One-way only (server → client)
- ❌ Limited browser support (no IE)
- ❌ HTTP/1.1 connection limit (6 per domain)

**Use cases:**
- Notifications
- Live feeds
- Stock tickers
- Server logs

### 3. Long Polling: Fake Real-Time

**How it works:**
- Client makes request
- Server holds request until data available
- Server responds, client immediately requests again

**Pros:**
- ✅ Works everywhere (just HTTP)
- ✅ No special server needed

**Cons:**
- ❌ Higher latency than WebSockets/SSE
- ❌ More server resources
- ❌ Still HTTP overhead

**Use cases:**
- Legacy browser support
- Fallback mechanism

### Comparison Table

| Feature | WebSockets | SSE | Long Polling |
|---------|-----------|-----|--------------|
| **Latency** | ~10ms | ~50ms | ~200ms |
| **Direction** | Bi-directional | Server → Client | Bi-directional |
| **Protocol** | ws:// | HTTP | HTTP |
| **Reconnect** | Manual | Automatic | Manual |
| **Browser support** | Modern | Modern (no IE) | All |
| **Complexity** | High | Low | Medium |
| **Scalability** | Hard | Medium | Medium |

---

## Production-Ready WebSocket Hook

### Basic Hook with Reconnection

```tsx
// src/hooks/useWebSocket.ts

import { useEffect, useState, useRef, useCallback } from 'react'

interface UseWebSocketOptions {
  onOpen?: () => void
  onClose?: () => void
  onError?: (error: Event) => void
  onMessage?: (data: any) => void
  reconnectInterval?: number
  maxReconnectAttempts?: number
}

export function useWebSocket(url: string, options: UseWebSocketOptions = {}) {
  const {
    onOpen,
    onClose,
    onError,
    onMessage,
    reconnectInterval = 3000,
    maxReconnectAttempts = 5,
  } = options

  const [socket, setSocket] = useState<WebSocket | null>(null)
  const [lastMessage, setLastMessage] = useState<any>(null)
  const [connectionStatus, setConnectionStatus] = useState<
    'connecting' | 'connected' | 'disconnected' | 'error'
  >('connecting')
  
  const reconnectAttemptsRef = useRef(0)
  const reconnectTimeoutRef = useRef<NodeJS.Timeout>()
  const socketRef = useRef<WebSocket | null>(null)

  /**
   * Connect to WebSocket server
   */
  const connect = useCallback(() => {
    try {
      setConnectionStatus('connecting')
      
      const ws = new WebSocket(url)
      socketRef.current = ws

      /**
       * Connection opened
       */
      ws.onopen = () => {
        console.log('WebSocket connected')
        setConnectionStatus('connected')
        setSocket(ws)
        reconnectAttemptsRef.current = 0 // Reset attempts on success
        onOpen?.()
      }

      /**
       * Message received
       */
      ws.onmessage = (event) => {
        try {
          const data = JSON.parse(event.data)
          setLastMessage(data)
          onMessage?.(data)
        } catch (error) {
          console.error('Failed to parse WebSocket message:', error)
        }
      }

      /**
       * Connection closed
       */
      ws.onclose = () => {
        console.log('WebSocket disconnected')
        setConnectionStatus('disconnected')
        setSocket(null)
        onClose?.()

        // Attempt reconnection
        if (reconnectAttemptsRef.current < maxReconnectAttempts) {
          reconnectAttemptsRef.current++
          console.log(
            `Reconnecting... (attempt ${reconnectAttemptsRef.current}/${maxReconnectAttempts})`
          )
          
          reconnectTimeoutRef.current = setTimeout(() => {
            connect()
          }, reconnectInterval * reconnectAttemptsRef.current) // Exponential backoff
        }
      }

      /**
       * Error occurred
       */
      ws.onerror = (error) => {
        console.error('WebSocket error:', error)
        setConnectionStatus('error')
        onError?.(error)
      }
    } catch (error) {
      console.error('Failed to create WebSocket:', error)
      setConnectionStatus('error')
    }
  }, [url, onOpen, onClose, onError, onMessage, reconnectInterval, maxReconnectAttempts])

  /**
   * Send message to server
   */
  const sendMessage = useCallback((data: any) => {
    if (socketRef.current?.readyState === WebSocket.OPEN) {
      socketRef.current.send(JSON.stringify(data))
    } else {
      console.warn('WebSocket is not connected')
    }
  }, [])

  /**
   * Manually disconnect
   */
  const disconnect = useCallback(() => {
    if (reconnectTimeoutRef.current) {
      clearTimeout(reconnectTimeoutRef.current)
    }
    if (socketRef.current) {
      socketRef.current.close()
      socketRef.current = null
    }
  }, [])

  /**
   * Connect on mount, cleanup on unmount
   */
  useEffect(() => {
    connect()

    return () => {
      disconnect()
    }
  }, [connect, disconnect])

  return {
    socket,
    lastMessage,
    connectionStatus,
    sendMessage,
    disconnect,
    reconnect: connect,
  }
}
```

### Advanced Hook with Heartbeat

```tsx
// src/hooks/useWebSocketWithHeartbeat.ts

import { useEffect, useRef } from 'react'
import { useWebSocket } from './useWebSocket'

interface UseWebSocketWithHeartbeatOptions {
  heartbeatInterval?: number
  heartbeatTimeout?: number
}

export function useWebSocketWithHeartbeat(
  url: string,
  options: UseWebSocketWithHeartbeatOptions = {}
) {
  const { heartbeatInterval = 30000, heartbeatTimeout = 5000 } = options

  const heartbeatIntervalRef = useRef<NodeJS.Timeout>()
  const heartbeatTimeoutRef = useRef<NodeJS.Timeout>()

  const { socket, connectionStatus, sendMessage, ...rest } = useWebSocket(url, {
    onOpen: () => {
      // Start heartbeat when connected
      startHeartbeat()
    },
    onClose: () => {
      // Stop heartbeat when disconnected
      stopHeartbeat()
    },
    onMessage: (data) => {
      // Reset heartbeat timeout on any message
      if (data.type === 'pong') {
        resetHeartbeatTimeout()
      }
    },
  })

  /**
   * Start sending heartbeat pings
   */
  const startHeartbeat = () => {
    heartbeatIntervalRef.current = setInterval(() => {
      sendMessage({ type: 'ping' })

      // Set timeout to detect dead connection
      heartbeatTimeoutRef.current = setTimeout(() => {
        console.warn('Heartbeat timeout - connection may be dead')
        socket?.close() // Force reconnection
      }, heartbeatTimeout)
    }, heartbeatInterval)
  }

  /**
   * Stop heartbeat
   */
  const stopHeartbeat = () => {
    if (heartbeatIntervalRef.current) {
      clearInterval(heartbeatIntervalRef.current)
    }
    if (heartbeatTimeoutRef.current) {
      clearTimeout(heartbeatTimeoutRef.current)
    }
  }

  /**
   * Reset heartbeat timeout (received pong)
   */
  const resetHeartbeatTimeout = () => {
    if (heartbeatTimeoutRef.current) {
      clearTimeout(heartbeatTimeoutRef.current)
    }
  }

  useEffect(() => {
    return () => {
      stopHeartbeat()
    }
  }, [])

  return {
    socket,
    connectionStatus,
    sendMessage,
    ...rest,
  }
}
```

---

## Real-World Examples

### 1. Live Notifications

```tsx
// src/components/notifications/LiveNotifications.tsx

import { useWebSocket } from '@/hooks/useWebSocket'
import { useState, useEffect } from 'react'
import { toast } from 'sonner'

interface Notification {
  id: string
  type: 'new_post' | 'new_reply' | 'mention' | 'like'
  title: string
  message: string
  threadId?: string
  postId?: string
  createdAt: string
}

export function LiveNotifications() {
  const [notifications, setNotifications] = useState<Notification[]>([])
  const { lastMessage, connectionStatus } = useWebSocket('ws://localhost:3001/notifications', {
    onMessage: (data) => {
      if (data.type === 'notification') {
        const notification = data.payload as Notification
        
        // Add to list
        setNotifications(prev => [notification, ...prev])
        
        // Show toast
        toast(notification.title, {
          description: notification.message,
          action: notification.threadId ? {
            label: 'View',
            onClick: () => {
              window.location.href = `/threads/${notification.threadId}`
            },
          } : undefined,
        })
      }
    },
  })

  return (
    <div className="relative">
      {/* Connection status indicator */}
      <div className="flex items-center gap-2">
        <div
          className={`w-2 h-2 rounded-full ${
            connectionStatus === 'connected'
              ? 'bg-green-500'
              : connectionStatus === 'connecting'
              ? 'bg-yellow-500 animate-pulse'
              : 'bg-red-500'
          }`}
        />
        <span className="text-sm text-slate-400">
          {connectionStatus === 'connected' && 'Live'}
          {connectionStatus === 'connecting' && 'Connecting...'}
          {connectionStatus === 'disconnected' && 'Disconnected'}
        </span>
      </div>

      {/* Notifications list */}
      <div className="mt-4 space-y-2">
        {notifications.map(notification => (
          <div
            key={notification.id}
            className="p-3 bg-slate-900 border border-slate-700 rounded-lg"
          >
            <h4 className="font-medium text-slate-100">{notification.title}</h4>
            <p className="text-sm text-slate-400 mt-1">{notification.message}</p>
          </div>
        ))}
      </div>
    </div>
  )
}
```

### 2. Typing Indicators

```tsx
// src/components/thread/TypingIndicators.tsx

import { useWebSocket } from '@/hooks/useWebSocket'
import { useState, useEffect, useRef } from 'react'

interface TypingUser {
  userId: string
  username: string
  lastTyped: number
}

export function TypingIndicators({ threadId }: { threadId: string }) {
  const [typingUsers, setTypingUsers] = useState<TypingUser[]>([])
  const typingTimeoutRef = useRef<Map<string, NodeJS.Timeout>>(new Map())

  const { sendMessage } = useWebSocket('ws://localhost:3001/threads', {
    onMessage: (data) => {
      if (data.type === 'user_typing' && data.threadId === threadId) {
        const { userId, username } = data

        // Add or update typing user
        setTypingUsers(prev => {
          const existing = prev.find(u => u.userId === userId)
          if (existing) {
            return prev.map(u =>
              u.userId === userId ? { ...u, lastTyped: Date.now() } : u
            )
          }
          return [...prev, { userId, username, lastTyped: Date.now() }]
        })

        // Clear existing timeout
        const existingTimeout = typingTimeoutRef.current.get(userId)
        if (existingTimeout) {
          clearTimeout(existingTimeout)
        }

        // Set timeout to remove user after 3 seconds
        const timeout = setTimeout(() => {
          setTypingUsers(prev => prev.filter(u => u.userId !== userId))
          typingTimeoutRef.current.delete(userId)
        }, 3000)

        typingTimeoutRef.current.set(userId, timeout)
      }
    },
  })

  /**
   * Notify server when user is typing
   */
  const handleTyping = () => {
    sendMessage({
      type: 'user_typing',
      threadId,
    })
  }

  if (typingUsers.length === 0) return null

  return (
    <div className="flex items-center gap-2 text-sm text-slate-400 py-2">
      <div className="flex -space-x-2">
        {typingUsers.slice(0, 3).map(user => (
          <div
            key={user.userId}
            className="w-6 h-6 rounded-full bg-blue-500 border-2 border-slate-900 flex items-center justify-center text-xs text-white"
          >
            {user.username[0].toUpperCase()}
          </div>
        ))}
      </div>
      <span>
        {typingUsers.length === 1 && `${typingUsers[0].username} is typing...`}
        {typingUsers.length === 2 &&
          `${typingUsers[0].username} and ${typingUsers[1].username} are typing...`}
        {typingUsers.length > 2 &&
          `${typingUsers[0].username} and ${typingUsers.length - 1} others are typing...`}
      </span>
      <div className="flex gap-1">
        <div className="w-2 h-2 bg-slate-400 rounded-full animate-bounce" style={{ animationDelay: '0ms' }} />
        <div className="w-2 h-2 bg-slate-400 rounded-full animate-bounce" style={{ animationDelay: '150ms' }} />
        <div className="w-2 h-2 bg-slate-400 rounded-full animate-bounce" style={{ animationDelay: '300ms' }} />
      </div>
    </div>
  )
}
```

### 3. Live Post Updates

```tsx
// src/pages/ThreadDetailPage.tsx

import { useWebSocket } from '@/hooks/useWebSocket'
import { useState, useEffect } from 'react'
import { useParams } from 'react-router-dom'
import { PostCard } from '@/components/posts/PostCard'

export function ThreadDetailPage() {
  const { threadId } = useParams()
  const [posts, setPosts] = useState<Post[]>([])

  const { lastMessage, connectionStatus } = useWebSocket('ws://localhost:3001/threads', {
    onOpen: () => {
      // Subscribe to thread updates
      sendMessage({
        type: 'subscribe',
        threadId,
      })
    },
    onMessage: (data) => {
      if (data.threadId !== threadId) return

      switch (data.type) {
        case 'new_post':
          // Add new post to list
          setPosts(prev => [...prev, data.post])
          break

        case 'post_updated':
          // Update existing post
          setPosts(prev =>
            prev.map(p => (p.id === data.post.id ? data.post : p))
          )
          break

        case 'post_deleted':
          // Remove deleted post
          setPosts(prev => prev.filter(p => p.id !== data.postId))
          break

        case 'post_liked':
          // Update like count
          setPosts(prev =>
            prev.map(p =>
              p.id === data.postId
                ? { ...p, likeCount: p.likeCount + 1 }
                : p
            )
          )
          break
      }
    },
  })

  return (
    <div>
      {/* Connection indicator */}
      {connectionStatus !== 'connected' && (
        <div className="bg-yellow-900/20 border border-yellow-700 rounded-lg p-3 mb-4">
          <p className="text-yellow-400 text-sm">
            {connectionStatus === 'connecting' && 'Connecting to live updates...'}
            {connectionStatus === 'disconnected' && 'Disconnected. Reconnecting...'}
            {connectionStatus === 'error' && 'Connection error. Retrying...'}
          </p>
        </div>
      )}

      {/* Posts */}
      <div className="space-y-4">
        {posts.map(post => (
          <PostCard key={post.id} post={post} />
        ))}
      </div>
    </div>
  )
}
```

---

## Scalability: Redis Pub/Sub

For production, use Redis Pub/Sub to scale WebSocket servers:

```typescript
// server/websocket-server.ts

import { createServer } from 'http'
import { WebSocketServer } from 'ws'
import { createClient } from 'redis'

const server = createServer()
const wss = new WebSocketServer({ server })

// Redis clients
const publisher = createClient()
const subscriber = createClient()

await publisher.connect()
await subscriber.connect()

// Subscribe to channels
await subscriber.subscribe('notifications', (message) => {
  const data = JSON.parse(message)
  
  // Broadcast to all connected clients
  wss.clients.forEach(client => {
    if (client.readyState === WebSocket.OPEN) {
      client.send(JSON.stringify(data))
    }
  })
})

// Handle WebSocket connections
wss.on('connection', (ws) => {
  console.log('Client connected')

  ws.on('message', async (message) => {
    const data = JSON.parse(message.toString())
    
    // Publish to Redis (other servers will receive it)
    await publisher.publish('notifications', JSON.stringify(data))
  })

  ws.on('close', () => {
    console.log('Client disconnected')
  })
})

server.listen(3001)
```

---

## Best Practices

### ✅ DO

- ✅ Implement reconnection with exponential backoff
- ✅ Use heartbeat/ping-pong to detect dead connections
- ✅ Handle connection status in UI
- ✅ Validate and sanitize messages
- ✅ Use message queues for reliability
- ✅ Implement authentication (send token on connect)
- ✅ Use Redis Pub/Sub for horizontal scaling

### ❌ DON'T

- ❌ Send sensitive data without encryption
- ❌ Forget to clean up connections
- ❌ Ignore reconnection logic
- ❌ Send large payloads (use references instead)
- ❌ Forget to handle offline scenarios
- ❌ Skip error handling

---

## Summary

### Key Concepts

1. **WebSockets**: Bi-directional, low-latency, persistent connections
2. **SSE**: Server → Client, automatic reconnection, simpler
3. **Reconnection**: Exponential backoff, max attempts
4. **Heartbeat**: Detect dead connections, keep-alive
5. **Scalability**: Redis Pub/Sub for multiple servers

### Real-Time Features

- ✅ Live notifications
- ✅ Typing indicators
- ✅ Instant post updates
- ✅ Online presence
- ✅ Read receipts

---

Next: [Testing →](/en/react/9.advanced-topics/3.testing)
