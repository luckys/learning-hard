---
title: Create Thread
description: Build a rich markdown editor for thread creation with live preview and validation.
---

# Disclaimer

:::u-alert
---
title: Comments in the code are for educational purposes only.
description: In real projects, avoid adding irrelevant or redundant comments.
color: warning
variant: subtle
icon: i-lucide-triangle-alert
---
:::

Creating threads is more complex than categories: we need a rich text editor with markdown support, live preview, and category selection.

---

## What We're Building

A thread creation form with:
- Title field (10-200 characters)
- Markdown editor with toolbar
- Live preview of rendered content
- Category selector
- Real-time validation
- Character counters
- Save draft functionality

---

## Thread Schema

```typescript
// src/features/threads/schemas.ts

import { z } from 'zod'

/**
 * Thread creation schema
 * 
 * More complex than category schema:
 * - Longer title range (10-200 vs 3-50)
 * - Content must be substantial (min 50 chars)
 * - Must belong to a category
 */
export const createThreadSchema = z.object({
  title: z
    .string()
    .min(10, 'Title must be at least 10 characters')
    .max(200, 'Title must be at most 200 characters')
    .regex(/^[^\n]+$/, 'Title cannot contain line breaks'),
  
  content: z
    .string()
    .min(50, 'Content must be at least 50 characters')
    .max(10000, 'Content must be at most 10,000 characters'),
  
  categoryId: z
    .string()
    .uuid('Invalid category selected'),
})

export type CreateThreadInput = z.infer<typeof createThreadSchema>
```

**Why these constraints?**
- **Title 10-200**: Short enough for list view, long enough to be descriptive
- **Content min 50**: Prevent low-quality posts ("hi", "test", etc.)
- **Content max 10k**: Prevent abuse, encourage focused discussions
- **No line breaks in title**: Keeps UI clean

---

## Markdown Editor Component

We'll build a custom markdown editor with preview.

```tsx
// src/components/editor/MarkdownEditor.tsx

import { useState } from 'react'
import { marked } from 'marked'
import DOMPurify from 'dompurify'

interface MarkdownEditorProps {
  value: string
  onChange: (value: string) => void
  placeholder?: string
  minHeight?: number
}

/**
 * Markdown editor with live preview
 * 
 * Features:
 * - Split view (edit | preview)
 * - Toolbar with formatting buttons
 * - Character count
 * - Keyboard shortcuts
 */
export function MarkdownEditor({
  value,
  onChange,
  placeholder = 'Write your post...',
  minHeight = 300,
}: MarkdownEditorProps) {
  const [activeTab, setActiveTab] = useState<'edit' | 'preview'>('edit')

  /**
   * Render markdown to HTML safely
   * 
   * Steps:
   * 1. Parse markdown with marked
   * 2. Sanitize HTML with DOMPurify (prevent XSS)
   * 3. Render in preview
   */
  const renderMarkdown = (markdown: string): string => {
    const html = marked.parse(markdown, {
      gfm: true,  // GitHub Flavored Markdown
      breaks: true,  // Convert \n to <br>
    })
    
    return DOMPurify.sanitize(html)
  }

  /**
   * Insert markdown syntax at cursor position
   * 
   * Used by toolbar buttons
   */
  const insertMarkdown = (
    prefix: string,
    suffix: string = '',
    placeholder: string = 'text'
  ) => {
    const textarea = document.querySelector('textarea') as HTMLTextAreaElement
    if (!textarea) return

    const start = textarea.selectionStart
    const end = textarea.selectionEnd
    const selectedText = value.substring(start, end) || placeholder

    const newText =
      value.substring(0, start) +
      prefix +
      selectedText +
      suffix +
      value.substring(end)

    onChange(newText)

    // Restore focus and selection
    setTimeout(() => {
      textarea.focus()
      textarea.setSelectionRange(
        start + prefix.length,
        start + prefix.length + selectedText.length
      )
    }, 0)
  }

  return (
    <div className="border border-slate-700 rounded-lg overflow-hidden">
      {/* Toolbar */}
      <div className="flex items-center gap-2 px-4 py-2 bg-slate-900 border-b border-slate-700">
        {/* Tab switcher */}
        <div className="flex gap-1 mr-auto">
          <button
            type="button"
            onClick={() => setActiveTab('edit')}
            className={`px-3 py-1 text-sm rounded ${
              activeTab === 'edit'
                ? 'bg-slate-800 text-slate-100'
                : 'text-slate-400 hover:text-slate-200'
            }`}
          >
            Edit
          </button>
          <button
            type="button"
            onClick={() => setActiveTab('preview')}
            className={`px-3 py-1 text-sm rounded ${
              activeTab === 'preview'
                ? 'bg-slate-800 text-slate-100'
                : 'text-slate-400 hover:text-slate-200'
            }`}
          >
            Preview
          </button>
        </div>

        {/* Formatting buttons */}
        {activeTab === 'edit' && (
          <div className="flex items-center gap-1">
            <button
              type="button"
              onClick={() => insertMarkdown('**', '**', 'bold text')}
              title="Bold (Ctrl+B)"
              className="p-2 text-slate-400 hover:text-slate-200 hover:bg-slate-800 rounded"
            >
              <strong>B</strong>
            </button>

            <button
              type="button"
              onClick={() => insertMarkdown('*', '*', 'italic text')}
              title="Italic (Ctrl+I)"
              className="p-2 text-slate-400 hover:text-slate-200 hover:bg-slate-800 rounded italic"
            >
              I
            </button>

            <button
              type="button"
              onClick={() => insertMarkdown('[', '](url)', 'link text')}
              title="Link"
              className="p-2 text-slate-400 hover:text-slate-200 hover:bg-slate-800 rounded"
            >
              üîó
            </button>

            <button
              type="button"
              onClick={() => insertMarkdown('`', '`', 'code')}
              title="Inline code"
              className="p-2 text-slate-400 hover:text-slate-200 hover:bg-slate-800 rounded font-mono"
            >
              {'</>'}
            </button>

            <button
              type="button"
              onClick={() => insertMarkdown('```\n', '\n```', 'code block')}
              title="Code block"
              className="p-2 text-slate-400 hover:text-slate-200 hover:bg-slate-800 rounded"
            >
              Code
            </button>

            <button
              type="button"
              onClick={() => insertMarkdown('\n- ', '', 'list item')}
              title="Bullet list"
              className="p-2 text-slate-400 hover:text-slate-200 hover:bg-slate-800 rounded"
            >
              ‚Ä¢
            </button>
          </div>
        )}

        {/* Character count */}
        <span className="text-xs text-slate-500">
          {value.length.toLocaleString()} characters
        </span>
      </div>

      {/* Editor / Preview */}
      <div style={{ minHeight: `${minHeight}px` }}>
        {activeTab === 'edit' ? (
          <textarea
            value={value}
            onChange={(e) => onChange(e.target.value)}
            placeholder={placeholder}
            className="w-full h-full p-4 bg-slate-950 text-slate-100 resize-none focus:outline-none font-mono"
            style={{ minHeight: `${minHeight}px` }}
          />
        ) : (
          <div
            className="p-4 prose prose-invert max-w-none"
            dangerouslySetInnerHTML={{ __html: renderMarkdown(value) }}
          />
        )}
      </div>

      {/* Help text */}
      <div className="px-4 py-2 bg-slate-900 border-t border-slate-700 text-xs text-slate-500">
        Markdown supported: **bold**, *italic*, `code`, [link](url), lists, etc.
      </div>
    </div>
  )
}
```

### Markdown Editor Explained

**Key features:**

1. **Tab switching**: Edit mode shows textarea, Preview shows rendered markdown
2. **Toolbar buttons**: Insert markdown syntax at cursor position
3. **Character counter**: Help users stay within limits
4. **Safe rendering**: DOMPurify prevents XSS attacks

**Why `dangerouslySetInnerHTML`?**

React escapes HTML by default (good for security). But we WANT to render HTML (from markdown). So we use `dangerouslySetInnerHTML` with sanitization:

```tsx
// ‚ùå Without sanitization: XSS vulnerability
<div dangerouslySetInnerHTML={{ __html: marked.parse(userInput) }} />

// ‚úÖ With sanitization: Safe
<div dangerouslySetInnerHTML={{ __html: DOMPurify.sanitize(marked.parse(userInput)) }} />
```

---

## Create Thread Form

```tsx
// src/features/threads/components/CreateThreadForm.tsx

import { useForm } from 'react-hook-form'
import { zodResolver } from '@hookform/resolvers/zod'
import { useState } from 'react'
import { useNavigate } from 'react-router-dom'
import { createThreadSchema, type CreateThreadInput } from '../schemas'
import { MarkdownEditor } from '@/components/editor/MarkdownEditor'
import { apiClient } from '@/lib/api-client'
import { toast } from '@/lib/toast'
import type { Category, Thread } from '@/types'

interface CreateThreadFormProps {
  categories: Category[]
}

export function CreateThreadForm({ categories }: CreateThreadFormProps) {
  const navigate = useNavigate()
  
  /**
   * React Hook Form setup
   */
  const {
    register,
    handleSubmit,
    watch,
    setValue,
    formState: { errors, isSubmitting },
  } = useForm<CreateThreadInput>({
    resolver: zodResolver(createThreadSchema),
    defaultValues: {
      title: '',
      content: '',
      categoryId: '',
    },
  })

  /**
   * Watch content for MarkdownEditor
   * 
   * MarkdownEditor is controlled component that needs value + onChange
   * React Hook Form stores value internally, so we watch() it
   */
  const content = watch('content')

  /**
   * Submit handler
   */
  const onSubmit = async (data: CreateThreadInput) => {
    try {
      const response = await apiClient.post<Thread>('/threads', data)
      
      toast.success('Thread created successfully!')
      
      // Navigate to new thread
      navigate(`/threads/${response.data.slug}`)
    } catch (error) {
      toast.error(error instanceof Error ? error.message : 'Failed to create thread')
    }
  }

  /**
   * Save draft to localStorage
   * 
   * Auto-save every 30 seconds
   */
  const saveDraft = () => {
    const draft = watch()
    localStorage.setItem('threadDraft', JSON.stringify(draft))
    toast.success('Draft saved')
  }

  return (
    <form onSubmit={handleSubmit(onSubmit)} className="space-y-6">
      {/* Title field */}
      <div>
        <label htmlFor="title" className="block text-sm font-medium text-slate-200 mb-2">
          Thread Title *
        </label>
        <input
          id="title"
          type="text"
          {...register('title')}
          placeholder="What's your question or topic?"
          className="w-full px-4 py-3 bg-slate-900 border border-slate-700 rounded-lg text-slate-100 placeholder-slate-500 focus:border-blue-500 focus:ring-1 focus:ring-blue-500"
        />
        {errors.title && (
          <p className="mt-2 text-sm text-red-400">{errors.title.message}</p>
        )}
        <p className="mt-2 text-xs text-slate-500">
          {watch('title')?.length || 0} / 200 characters
        </p>
      </div>

      {/* Category selector */}
      <div>
        <label htmlFor="categoryId" className="block text-sm font-medium text-slate-200 mb-2">
          Category *
        </label>
        <select
          id="categoryId"
          {...register('categoryId')}
          className="w-full px-4 py-3 bg-slate-900 border border-slate-700 rounded-lg text-slate-100 focus:border-blue-500 focus:ring-1 focus:ring-blue-500"
        >
          <option value="">Select a category</option>
          {categories
            .filter((cat) => cat.parentId === null)  // Only root categories
            .map((category) => (
              <option key={category.id} value={category.id}>
                {category.name}
              </option>
            ))}
        </select>
        {errors.categoryId && (
          <p className="mt-2 text-sm text-red-400">{errors.categoryId.message}</p>
        )}
      </div>

      {/* Content editor */}
      <div>
        <label className="block text-sm font-medium text-slate-200 mb-2">
          Content *
        </label>
        <MarkdownEditor
          value={content}
          onChange={(value) => setValue('content', value, { shouldValidate: true })}
          placeholder="Describe your question or topic in detail..."
          minHeight={400}
        />
        {errors.content && (
          <p className="mt-2 text-sm text-red-400">{errors.content.message}</p>
        )}
        <p className="mt-2 text-xs text-slate-500">
          {content.length} / 10,000 characters (minimum 50)
        </p>
      </div>

      {/* Actions */}
      <div className="flex items-center justify-between">
        <button
          type="button"
          onClick={saveDraft}
          className="px-4 py-2 text-slate-400 hover:text-slate-200"
        >
          Save Draft
        </button>

        <div className="flex gap-3">
          <button
            type="button"
            onClick={() => navigate(-1)}
            className="px-6 py-3 bg-slate-800 text-slate-200 rounded-lg hover:bg-slate-700"
          >
            Cancel
          </button>

          <button
            type="submit"
            disabled={isSubmitting}
            className="px-6 py-3 bg-blue-600 text-white rounded-lg hover:bg-blue-700 disabled:opacity-50 disabled:cursor-not-allowed"
          >
            {isSubmitting ? 'Creating...' : 'Create Thread'}
          </button>
        </div>
      </div>
    </form>
  )
}
```

---

## React Hook Form: watch() and setValue()

**Problem**: MarkdownEditor needs `value` and `onChange`, but React Hook Form manages state internally.

**Solution**: Use `watch()` and `setValue()`.

```tsx
// Watch a field's value
const content = watch('content')

// Update a field's value
setValue('content', newValue, { shouldValidate: true })
```

**Why `shouldValidate: true`?**

Tells React Hook Form to validate the field immediately after updating. Without it, validation only happens on blur/submit.

---

## Create Thread Page

```tsx
// src/pages/CreateThreadPage.tsx

import { useState, useEffect } from 'react'
import { useAuth } from '@/features/auth/hooks/useAuth'
import { Navigate } from 'react-router-dom'
import { CreateThreadForm } from '@/features/threads/components/CreateThreadForm'
import { apiClient } from '@/lib/api-client'
import type { Category } from '@/types'

export function CreateThreadPage() {
  const { user, isLoading: authLoading } = useAuth()
  const [categories, setCategories] = useState<Category[]>([])
  const [isLoadingCategories, setIsLoadingCategories] = useState(true)

  /**
   * Fetch categories for selector
   */
  useEffect(() => {
    async function fetchCategories() {
      try {
        const response = await apiClient.get<{ data: Category[] }>('/categories')
        setCategories(response.data.data)
      } catch (error) {
        console.error('Failed to load categories:', error)
      } finally {
        setIsLoadingCategories(false)
      }
    }

    fetchCategories()
  }, [])

  /**
   * Require authentication
   */
  if (authLoading) {
    return <div>Loading...</div>
  }

  if (!user) {
    return <Navigate to="/sign-in" state={{ from: '/threads/new' }} />
  }

  /**
   * Loading categories
   */
  if (isLoadingCategories) {
    return <div>Loading categories...</div>
  }

  return (
    <div className="container mx-auto px-4 py-8 max-w-4xl">
      <div className="mb-8">
        <h1 className="text-3xl font-bold text-slate-100 mb-2">
          Create New Thread
        </h1>
        <p className="text-slate-400">
          Start a discussion, ask a question, or share your knowledge
        </p>
      </div>

      <div className="bg-slate-900 rounded-lg border border-slate-800 p-6">
        <CreateThreadForm categories={categories} />
      </div>
    </div>
  )
}
```

---

## Draft Auto-Save

Save drafts periodically to prevent data loss.

```tsx
import { useEffect } from 'react'

export function CreateThreadForm({ categories }: CreateThreadFormProps) {
  const { watch } = useForm()

  /**
   * Auto-save draft every 30 seconds
   */
  useEffect(() => {
    const interval = setInterval(() => {
      const draft = watch()
      if (draft.title || draft.content) {
        localStorage.setItem('threadDraft', JSON.stringify(draft))
      }
    }, 30000)  // 30 seconds

    return () => clearInterval(interval)
  }, [watch])

  /**
   * Load draft on mount
   */
  useEffect(() => {
    const savedDraft = localStorage.getItem('threadDraft')
    if (savedDraft) {
      const draft = JSON.parse(savedDraft)
      if (confirm('Load saved draft?')) {
        setValue('title', draft.title || '')
        setValue('content', draft.content || '')
        setValue('categoryId', draft.categoryId || '')
      }
    }
  }, [])

  // ...
}
```

---

## Summary

### New Concepts

1. **Markdown Editor**: Custom controlled component with preview
2. **watch() and setValue()**: Bridge React Hook Form with custom components
3. **DOMPurify**: Sanitize HTML to prevent XSS
4. **marked**: Parse markdown to HTML
5. **Draft auto-save**: Use localStorage + setInterval
6. **Protected routes**: Require authentication

### Best Practices

- ‚úÖ Sanitize user-generated HTML (DOMPurify)
- ‚úÖ Provide live preview for rich content
- ‚úÖ Show character counts for length limits
- ‚úÖ Auto-save drafts to prevent data loss
- ‚úÖ Validate on input for instant feedback
- ‚úÖ Redirect to created thread after success

---

Next: [Filter & Sort ‚Üí](/en/react/4.threads-module/4.filter-sort)
