---
title: Thread Detail Page
description: Master useParams for dynamic routes, parallel data fetching, and nested data display.
---

# Disclaimer

:::u-alert
---
title: Comments in the code are for educational purposes only.
description: In real projects, avoid adding irrelevant or redundant comments.
color: warning
variant: subtle
icon: i-lucide-triangle-alert
---
:::

The thread detail page is the heart of our forum. It displays the thread content, all replies, and allows users to participate in the discussion.

---

## What We're Building

A thread detail page with:
- Thread title, author, category
- Original post content (markdown rendered)
- List of all replies (nested)
- Reply composer
- Vote buttons
- Edit/delete actions (for author)

---

## React Router: Dynamic Routes

React Router lets us define routes with parameters.

```tsx
// src/App.tsx

import { BrowserRouter, Routes, Route } from 'react-router-dom'

function App() {
  return (
    <BrowserRouter>
      <Routes>
        <Route path="/" element={<HomePage />} />
        <Route path="/threads" element={<ThreadsPage />} />
        {/* Dynamic route with :slug parameter */}
        <Route path="/threads/:slug" element={<ThreadDetailPage />} />
      </Routes>
    </BrowserRouter>
  )
}
```

**Route parameters:**
- `/threads/:slug` matches `/threads/how-to-use-react`
- `:slug` is a **parameter** (variable part of URL)
- We can have multiple params: `/users/:userId/posts/:postId`

---

## useParams: Accessing Route Parameters

`useParams` hook extracts parameters from the current URL.

```tsx
import { useParams } from 'react-router-dom'

function ThreadDetailPage() {
  // Extract slug from URL
  const { slug } = useParams<{ slug: string }>()
  
  console.log(slug)  // "how-to-use-react"
  
  // Use slug to fetch thread data
}
```

**Type safety with TypeScript:**
```tsx
// ‚úÖ Type-safe params
const { slug } = useParams<{ slug: string }>()
slug.toUpperCase()  // TypeScript knows it's a string

// ‚ùå Without type
const params = useParams()
params.slug.toUpperCase()  // Error: slug might be undefined
```

**Multiple parameters:**
```tsx
const { userId, postId } = useParams<{ userId: string; postId: string }>()
```

---

## Thread Detail Page Structure

```tsx
// src/pages/ThreadDetailPage.tsx

import { useState, useEffect } from 'react'
import { useParams, useNavigate } from 'react-router-dom'
import { apiClient } from '@/lib/api-client'
import { ThreadHeader } from '@/components/threads/ThreadHeader'
import { PostList } from '@/components/posts/PostList'
import { ReplyComposer } from '@/components/posts/ReplyComposer'
import type { Thread, Post } from '@/types'

export function ThreadDetailPage() {
  /**
   * useParams: Get slug from URL
   * 
   * URL: /threads/how-to-use-react
   * slug: "how-to-use-react"
   */
  const { slug } = useParams<{ slug: string }>()
  const navigate = useNavigate()
  
  /**
   * State for thread and posts
   * 
   * Separate state because they're fetched from different endpoints
   */
  const [thread, setThread] = useState<Thread | null>(null)
  const [posts, setPosts] = useState<Post[]>([])
  const [isLoading, setIsLoading] = useState(true)
  const [error, setError] = useState<string | null>(null)

  /**
   * Fetch thread and posts when component mounts or slug changes
   * 
   * Dependencies: [slug]
   * Why? If user navigates to different thread, we need to fetch new data
   */
  useEffect(() => {
    /**
     * Async function to fetch thread and posts in parallel
     * 
     * Promise.all runs requests concurrently (faster than sequential)
     */
    async function fetchThreadData() {
      try {
        setIsLoading(true)
        setError(null)

        /**
         * Promise.all: Wait for all promises to resolve
         * 
         * Benefits:
         * - Parallel execution (faster than await one, then await other)
         * - If any fails, all fail (atomic operation)
         */
        const [threadResponse, postsResponse] = await Promise.all([
          apiClient.get<Thread>(`/threads/${slug}`),
          apiClient.get<Post[]>(`/threads/${slug}/posts`),
        ])

        setThread(threadResponse.data)
        setPosts(postsResponse.data)

        /**
         * Increment view count (fire and forget)
         * 
         * Don't await because we don't care about response
         * User shouldn't wait for view count to increment
         */
        apiClient.post(`/threads/${slug}/views`).catch(() => {
          // Ignore errors (view counting is not critical)
        })
      } catch (err) {
        /**
         * Handle different error types
         */
        if (err.response?.status === 404) {
          setError('Thread not found')
        } else {
          setError(err instanceof Error ? err.message : 'Failed to load thread')
        }
      } finally {
        setIsLoading(false)
      }
    }

    fetchThreadData()
  }, [slug])

  /**
   * Handle new reply submission
   * 
   * Optimistically add reply to UI before API confirms
   */
  const handleReplyCreated = (newPost: Post) => {
    setPosts((prevPosts) => [...prevPosts, newPost])
  }

  /**
   * Loading state: Show skeleton
   */
  if (isLoading) {
    return (
      <div className="container mx-auto px-4 py-8 max-w-4xl">
        <ThreadDetailSkeleton />
      </div>
    )
  }

  /**
   * Error state: Show error message
   */
  if (error) {
    return (
      <div className="container mx-auto px-4 py-8 max-w-4xl">
        <div className="bg-red-900/20 border border-red-700 rounded-lg p-6 text-center">
          <h2 className="text-xl font-bold text-red-400 mb-2">Error</h2>
          <p className="text-red-300 mb-4">{error}</p>
          <button
            onClick={() => navigate('/threads')}
            className="px-4 py-2 bg-red-600 text-white rounded-md hover:bg-red-700"
          >
            Back to Threads
          </button>
        </div>
      </div>
    )
  }

  /**
   * Success state: Show thread and posts
   */
  if (!thread) {
    return null  // Shouldn't happen, but makes TypeScript happy
  }

  return (
    <div className="container mx-auto px-4 py-8 max-w-4xl">
      {/* Thread header with title, author, category */}
      <ThreadHeader thread={thread} />

      {/* Divider */}
      <div className="border-t border-slate-800 my-8" />

      {/* Posts list (nested replies) */}
      <PostList posts={posts} threadId={thread.id} />

      {/* Reply composer (only for authenticated users) */}
      <div className="mt-8">
        <ReplyComposer
          threadId={thread.id}
          onReplyCreated={handleReplyCreated}
        />
      </div>
    </div>
  )
}
```

---

## Promise.all: Parallel Fetching

**Sequential (slow):**
```tsx
// Takes 2 seconds if each request takes 1 second
const threadResponse = await apiClient.get(`/threads/${slug}`)
const postsResponse = await apiClient.get(`/threads/${slug}/posts`)
```

**Parallel (fast):**
```tsx
// Takes 1 second (both requests run simultaneously)
const [threadResponse, postsResponse] = await Promise.all([
  apiClient.get(`/threads/${slug}`),
  apiClient.get(`/threads/${slug}/posts`),
])
```

**When to use Promise.all:**
- ‚úÖ Requests are independent (don't depend on each other)
- ‚úÖ You need all results before proceeding
- ‚úÖ Performance matters

**When NOT to use:**
- ‚ùå Second request needs data from first
- ‚ùå Requests are optional (use Promise.allSettled instead)

---

## Thread Header Component

```tsx
// src/components/threads/ThreadHeader.tsx

import { Link } from 'react-router-dom'
import { formatDistanceToNow } from 'date-fns'
import { CategoryBreadcrumb } from '@/components/categories/CategoryBreadcrumb'
import type { Thread } from '@/types'

interface ThreadHeaderProps {
  thread: Thread
}

export function ThreadHeader({ thread }: ThreadHeaderProps) {
  return (
    <header>
      {/* Breadcrumb navigation */}
      <nav className="mb-4">
        <CategoryBreadcrumb categoryId={thread.categoryId} />
      </nav>

      {/* Thread title */}
      <h1 className="text-4xl font-bold text-slate-100 mb-4">
        {thread.isPinned && (
          <span className="text-yellow-500 mr-2" title="Pinned thread">
            üìå
          </span>
        )}
        {thread.isLocked && (
          <span className="text-slate-500 mr-2" title="Locked thread">
            üîí
          </span>
        )}
        {thread.title}
      </h1>

      {/* Thread metadata */}
      <div className="flex items-center gap-4 text-sm text-slate-400">
        {/* Author */}
        <div className="flex items-center gap-2">
          <img
            src={thread.author.avatarUrl || '/avatars/default.png'}
            alt={thread.author.displayName}
            className="w-8 h-8 rounded-full"
          />
          <Link
            to={`/users/${thread.author.username}`}
            className="font-medium text-slate-200 hover:text-blue-400"
          >
            {thread.author.displayName}
          </Link>
        </div>

        <span>‚Ä¢</span>

        {/* Created time */}
        <time dateTime={thread.createdAt}>
          {formatDistanceToNow(new Date(thread.createdAt), { addSuffix: true })}
        </time>

        <span>‚Ä¢</span>

        {/* Stats */}
        <span>üëÅ {thread.viewCount} views</span>
        <span>üí¨ {thread.replyCount} replies</span>
      </div>

      {/* Thread content (first post) */}
      <div className="mt-6 p-6 bg-slate-900 rounded-lg border border-slate-800">
        <div
          className="prose prose-invert max-w-none"
          dangerouslySetInnerHTML={{ __html: thread.contentHtml }}
        />
      </div>
    </header>
  )
}
```

---

## Post List Component

```tsx
// src/components/posts/PostList.tsx

import { PostCard } from './PostCard'
import type { Post } from '@/types'

interface PostListProps {
  posts: Post[]
  threadId: string
}

export function PostList({ posts, threadId }: PostListProps) {
  if (posts.length === 0) {
    return (
      <div className="text-center py-12 bg-slate-900 rounded-lg border border-slate-800">
        <p className="text-slate-400">
          No replies yet. Be the first to reply!
        </p>
      </div>
    )
  }

  /**
   * Filter root posts (no parent)
   * 
   * Nested replies are rendered recursively by PostCard
   */
  const rootPosts = posts.filter((post) => post.parentId === null)

  return (
    <div className="space-y-6">
      <h2 className="text-2xl font-bold text-slate-100">
        Replies ({posts.length})
      </h2>

      <div className="space-y-4">
        {rootPosts.map((post) => (
          <PostCard
            key={post.id}
            post={post}
            allPosts={posts}  // Needed for finding children
            threadId={threadId}
          />
        ))}
      </div>
    </div>
  )
}
```

---

## Skeleton Loading

```tsx
// src/components/threads/ThreadDetailSkeleton.tsx

export function ThreadDetailSkeleton() {
  return (
    <div className="animate-pulse space-y-6">
      {/* Breadcrumb skeleton */}
      <div className="flex gap-2">
        <div className="h-4 bg-slate-800 rounded w-20" />
        <div className="h-4 bg-slate-800 rounded w-4" />
        <div className="h-4 bg-slate-800 rounded w-32" />
      </div>

      {/* Title skeleton */}
      <div className="h-10 bg-slate-800 rounded w-3/4" />

      {/* Metadata skeleton */}
      <div className="flex gap-4">
        <div className="h-8 w-8 bg-slate-800 rounded-full" />
        <div className="h-4 bg-slate-800 rounded w-32" />
      </div>

      {/* Content skeleton */}
      <div className="p-6 bg-slate-900 rounded-lg border border-slate-800 space-y-3">
        <div className="h-4 bg-slate-800 rounded w-full" />
        <div className="h-4 bg-slate-800 rounded w-5/6" />
        <div className="h-4 bg-slate-800 rounded w-4/6" />
      </div>

      {/* Posts skeleton */}
      <div className="space-y-4">
        {[...Array(3)].map((_, i) => (
          <div
            key={i}
            className="p-4 bg-slate-900 rounded-lg border border-slate-800 space-y-3"
          >
            <div className="flex gap-2">
              <div className="h-8 w-8 bg-slate-800 rounded-full" />
              <div className="h-4 bg-slate-800 rounded w-24" />
            </div>
            <div className="space-y-2">
              <div className="h-4 bg-slate-800 rounded w-full" />
              <div className="h-4 bg-slate-800 rounded w-3/4" />
            </div>
          </div>
        ))}
      </div>
    </div>
  )
}
```

---

## Error Handling Strategies

**Different error types:**

```tsx
try {
  const response = await apiClient.get(`/threads/${slug}`)
} catch (err) {
  // 404: Thread not found
  if (err.response?.status === 404) {
    setError('Thread not found')
  }
  
  // 403: Access denied (private thread)
  else if (err.response?.status === 403) {
    setError('You do not have permission to view this thread')
  }
  
  // 500: Server error
  else if (err.response?.status >= 500) {
    setError('Server error. Please try again later.')
  }
  
  // Network error
  else if (!err.response) {
    setError('Network error. Check your connection.')
  }
  
  // Other errors
  else {
    setError('Failed to load thread')
  }
}
```

---

## Summary

### New Concepts Learned

1. **useParams**: Extract parameters from URL
   ```tsx
   const { slug } = useParams<{ slug: string }>()
   ```

2. **Promise.all**: Parallel requests
   ```tsx
   const [a, b] = await Promise.all([fetchA(), fetchB()])
   ```

3. **Fire-and-forget requests**: Don't block UI
   ```tsx
   apiClient.post('/track-view').catch(() => {})  // Don't await
   ```

4. **Error handling**: Different responses for different errors

5. **Skeleton loading**: Better UX than spinner

### Best Practices

- ‚úÖ Fetch data in parallel when possible
- ‚úÖ Show detailed error messages
- ‚úÖ Use skeleton loading for better perceived performance
- ‚úÖ Track analytics asynchronously (don't block UI)
- ‚úÖ Handle 404, 403, 500 errors differently
- ‚úÖ Provide way to go back on error

---

## Next Steps

Now that we can display threads, let's learn how to **create** them with a rich markdown editor.

Continue to [Create Thread ‚Üí](/en/react/4.threads-module/3.create-thread)
