---
title: Search Threads
description: Master useDebounce, AbortController, and race condition handling for performant real-time search.
---

# Disclaimer

:::u-alert
---
title: Comments in the code are for educational purposes only.
description: In real projects, avoid adding irrelevant or redundant comments.
color: warning
variant: subtle
icon: i-lucide-triangle-alert
---
:::

Search is tricky: we need to balance responsiveness (instant feedback) with performance (don't spam the API). We'll use **debouncing** and **request cancellation** to solve this.

---

## The Problem: Too Many Requests

**‚ùå Naive approach:**

```tsx
function SearchThreads() {
  const [query, setQuery] = useState('')
  const [results, setResults] = useState<Thread[]>([])

  useEffect(() => {
    if (query) {
      // Fires on EVERY keystroke!
      apiClient.get(`/search?q=${query}`)
        .then(res => setResults(res.data))
    }
  }, [query])

  return (
    <input
      value={query}
      onChange={(e) => setQuery(e.target.value)}
    />
  )
}
```

**What happens when user types "react":**
- Types "r" ‚Üí API call 1
- Types "re" ‚Üí API call 2
- Types "rea" ‚Üí API call 3
- Types "reac" ‚Üí API call 4
- Types "react" ‚Üí API call 5

**5 API calls for 5 characters!** This is wasteful and can overload the server.

---

## Solution 1: Debouncing

**Debouncing** = Wait for user to stop typing before firing the request.

**Concept:**
- User types "r" ‚Üí Start 300ms timer
- User types "e" (before timer ends) ‚Üí Cancel timer, start new 300ms timer
- User types "a" (before timer ends) ‚Üí Cancel timer, start new 300ms timer
- User types "c" (before timer ends) ‚Üí Cancel timer, start new 300ms timer
- User types "t" (before timer ends) ‚Üí Cancel timer, start new 300ms timer
- User pauses... 300ms passes ‚Üí Fire request for "react"

**Result: 1 API call instead of 5!**

---

## useDebounce Hook

```tsx
// src/hooks/useDebounce.ts

import { useState, useEffect } from 'react'

/**
 * useDebounce: Delay value updates
 * 
 * Returns a debounced version of the value that only updates
 * after the specified delay has passed without changes.
 * 
 * Example:
 *   const query = 'react'  // Changes instantly on keystroke
 *   const debouncedQuery = useDebounce(query, 300)  // Changes 300ms after last keystroke
 */
export function useDebounce<T>(value: T, delay: number): T {
  /**
   * State to store debounced value
   * 
   * Starts with initial value
   */
  const [debouncedValue, setDebouncedValue] = useState<T>(value)

  useEffect(() => {
    /**
     * Set up a timer to update debounced value
     * 
     * setTimeout runs after 'delay' milliseconds
     */
    const timer = setTimeout(() => {
      setDebouncedValue(value)
    }, delay)

    /**
     * Cleanup function
     * 
     * Runs when:
     * 1. Value changes (before next effect)
     * 2. Component unmounts
     * 
     * This cancels the pending timer
     */
    return () => {
      clearTimeout(timer)
    }
  }, [value, delay])  // Re-run when value or delay changes

  return debouncedValue
}
```

### How It Works

**Timeline when user types "react":**

```
t=0ms:    User types 'r'
          ‚Üí value = 'r'
          ‚Üí setTimeout 300ms
          
t=50ms:   User types 'e' 
          ‚Üí value = 're'
          ‚Üí clearTimeout (cancel previous timer)
          ‚Üí setTimeout 300ms (new timer)
          
t=100ms:  User types 'a'
          ‚Üí value = 'rea'
          ‚Üí clearTimeout
          ‚Üí setTimeout 300ms
          
t=150ms:  User types 'c'
          ‚Üí value = 'reac'
          ‚Üí clearTimeout
          ‚Üí setTimeout 300ms
          
t=200ms:  User types 't'
          ‚Üí value = 'react'
          ‚Üí clearTimeout
          ‚Üí setTimeout 300ms
          
t=500ms:  Timer fires!
          ‚Üí debouncedValue = 'react'
          ‚Üí Trigger search
```

---

## Solution 2: Canceling Old Requests

**Problem:** User types "react", then quickly changes to "vue". Both requests are in flight. What if "react" response arrives after "vue" response? Wrong results!

**This is a race condition.**

**Solution:** Cancel old requests when new ones start.

### AbortController

```tsx
// Create controller
const controller = new AbortController()

// Pass signal to fetch/axios
fetch('/api/search', {
  signal: controller.signal
})

// Cancel request
controller.abort()
```

**What happens when aborted:**
- Request is canceled (browser stops it)
- Promise rejects with `AbortError`
- We can check `signal.aborted` to ignore the error

---

## Solution 3: useTransition - Non-Blocking UI Updates

**Problem:** While searching, the input becomes unresponsive. User can't type smoothly because React is busy updating the results.

**Solution:** `useTransition` marks updates as non-blocking, keeping the input responsive.

### What is useTransition?

`useTransition` lets you mark state updates as **non-urgent**. React will:
1. Keep urgent updates (input) responsive
2. Process non-urgent updates (search results) in the background
3. Show a loading indicator while processing

### How It Works

```tsx
import { useTransition } from 'react'

function SearchThreads() {
  const [query, setQuery] = useState('')
  const [results, setResults] = useState<Thread[]>([])
  
  // useTransition returns [isPending, startTransition]
  const [isPending, startTransition] = useTransition()
  
  const handleSearch = (newQuery: string) => {
    // Urgent: Update input immediately
    setQuery(newQuery)
    
    // Non-urgent: Update results in background
    startTransition(() => {
      // This update is marked as non-blocking
      const filtered = threads.filter(t => 
        t.title.includes(newQuery)
      )
      setResults(filtered)
    })
  }
  
  return (
    <div>
      <input 
        value={query}
        onChange={(e) => handleSearch(e.target.value)}
        placeholder="Search threads..."
      />
      
      {isPending && <p>Searching...</p>}
      
      <div>
        {results.map(thread => (
          <ThreadCard key={thread.id} thread={thread} />
        ))}
      </div>
    </div>
  )
}
```

### Visual Timeline

```
User types "react":

WITHOUT useTransition:
t=0ms:    User types 'r'
          ‚Üí Input updates (fast)
          ‚Üí Results update (slow, blocks input)
          ‚Üí User can't type smoothly ‚ùå

WITH useTransition:
t=0ms:    User types 'r'
          ‚Üí Input updates immediately (fast) ‚úÖ
          ‚Üí Results update in background
          ‚Üí User can keep typing smoothly ‚úÖ
```

### useTransition vs Debouncing

| Aspect | Debouncing | useTransition |
|--------|-----------|---------------|
| **Purpose** | Reduce API calls | Keep UI responsive |
| **When to use** | API calls, expensive operations | Large lists, complex renders |
| **Input responsiveness** | ‚ö†Ô∏è Delayed | ‚úÖ Immediate |
| **Results update** | After delay | In background |
| **Best for** | Search, filtering | Sorting, filtering large data |

**Use both together:**
- Debouncing: Reduce API calls
- useTransition: Keep UI responsive while processing

---

## Complete Search Component with useTransition

```tsx
// src/components/search/SearchThreads.tsx

import { useState, useEffect, useTransition } from 'react'
import { useDebounce } from '@/hooks/useDebounce'
import { ThreadCard } from '@/components/threads/ThreadCard'
import { apiClient } from '@/lib/api-client'
import type { Thread } from '@/types'

export function SearchThreads() {
  /**
   * Immediate value: updates on every keystroke
   * 
   * This keeps the input responsive
   */
  const [query, setQuery] = useState('')
  
  /**
   * Debounced value: updates 300ms after last keystroke
   * 
   * This is what we use for the API call
   */
  const debouncedQuery = useDebounce(query, 300)
  
  const [results, setResults] = useState<Thread[]>([])
  const [error, setError] = useState<string | null>(null)
  
  /**
   * useTransition: Mark result updates as non-blocking
   * 
   * Returns [isPending, startTransition]
   * - isPending: true while transition is happening
   * - startTransition: Wrap state updates to mark them as non-urgent
   * 
   * This keeps the input responsive while results update in background
   */
  const [isPending, startTransition] = useTransition()

  /**
   * Search effect
   * 
   * Runs when debouncedQuery changes (not query!)
   * This means it waits 300ms after user stops typing
   */
  useEffect(() => {
    /**
     * Early return if query is empty
     * 
     * No need to search for empty string
     */
    if (!debouncedQuery.trim()) {
      setResults([])
      setIsSearching(false)
      setError(null)
      return
    }

    /**
     * Create AbortController for this request
     * 
     * Each effect run gets its own controller
     */
    const controller = new AbortController()

    /**
     * Async search function
     */
    async function search() {
      try {
        setError(null)

        /**
         * Make API call with abort signal
         * 
         * If controller.abort() is called, this request will be canceled
         */
        const response = await apiClient.get<Thread[]>('/threads/search', {
          params: { q: debouncedQuery },
          signal: controller.signal,
        })

        /**
         * Only update results if not aborted
         * 
         * Wrap in startTransition to keep input responsive
         * while results update in the background
         */
        if (!controller.signal.aborted) {
          startTransition(() => {
            setResults(response.data)
          })
        }
      } catch (err) {
        /**
         * Ignore AbortError (expected when canceling)
         * 
         * Handle other errors normally
         */
        if (!controller.signal.aborted) {
          startTransition(() => {
            setError(err instanceof Error ? err.message : 'Search failed')
            setResults([])
          })
        }
      }
    }

    search()

    /**
     * Cleanup: abort request when effect re-runs or unmounts
     * 
     * This cancels the request if:
     * 1. User types again (debouncedQuery changes)
     * 2. Component unmounts
     * 
     * Prevents race conditions!
     */
    return () => {
      controller.abort()
    }
  }, [debouncedQuery])

  return (
    <div className="space-y-6">
      {/* Search input */}
      <div className="relative">
        <input
          type="text"
          value={query}
          onChange={(e) => setQuery(e.target.value)}
          placeholder="Search threads by title, content, or author..."
          className="w-full px-4 py-3 pl-12 bg-slate-900 border border-slate-700 rounded-lg text-slate-100 placeholder-slate-500 focus:border-blue-500 focus:ring-1 focus:ring-blue-500"
        />
        
        {/* Search icon */}
        <div className="absolute left-4 top-1/2 -translate-y-1/2 text-slate-500">
          üîç
        </div>

        {/* Loading spinner - shows while transition is pending */}
        {isPending && (
          <div className="absolute right-4 top-1/2 -translate-y-1/2">
            <div className="animate-spin h-5 w-5 border-2 border-blue-500 border-t-transparent rounded-full" />
          </div>
        )}
      </div>

      {/* Help text */}
      {!query && (
        <div className="text-center py-12 text-slate-500">
          <p>Start typing to search threads...</p>
        </div>
      )}

      {/* Error state */}
      {error && (
        <div className="bg-red-900/20 border border-red-700 rounded-lg p-4">
          <p className="text-red-400">{error}</p>
        </div>
      )}

      {/* Results */}
      {query && !isSearching && results.length === 0 && !error && (
        <div className="text-center py-12 text-slate-400">
          <p>No threads found for "{query}"</p>
        </div>
      )}

      {results.length > 0 && (
        <div>
          <p className="text-sm text-slate-400 mb-4">
            Found {results.length} thread{results.length === 1 ? '' : 's'}
          </p>
          
          <div className="space-y-4">
            {results.map((thread) => (
              <ThreadCard key={thread.id} thread={thread} />
            ))}
          </div>
        </div>
      )}
    </div>
  )
}
```

---

## Search Page

```tsx
// src/pages/SearchPage.tsx

import { SearchThreads } from '@/components/search/SearchThreads'

export function SearchPage() {
  return (
    <div className="container mx-auto px-4 py-8 max-w-4xl">
      <div className="mb-8">
        <h1 className="text-3xl font-bold text-slate-100 mb-2">
          Search Threads
        </h1>
        <p className="text-slate-400">
          Search through all forum threads by title, content, or author
        </p>
      </div>

      <SearchThreads />
    </div>
  )
}
```

---

## Summary: Search Performance Patterns

### The Three-Layer Approach

**1. Debouncing (useDebounce)**
- Reduces API calls
- Waits for user to stop typing
- Example: 5 keystrokes ‚Üí 1 API call

**2. Request Cancellation (AbortController)**
- Prevents race conditions
- Cancels old requests when new ones start
- Ensures latest results are shown

**3. Non-Blocking UI (useTransition)**
- Keeps input responsive
- Updates results in background
- Shows loading indicator

### When to Use Each

| Scenario | Solution |
|----------|----------|
| User types quickly | Debouncing |
| User changes query before results arrive | AbortController |
| Results take long to render | useTransition |
| Large list of results | useDeferredValue (next lesson) |

### Key Takeaways

‚úÖ **Debouncing** = Reduce API calls
‚úÖ **AbortController** = Prevent race conditions
‚úÖ **useTransition** = Keep UI responsive
‚úÖ **Use all three together** = Perfect search experience

### Performance Metrics

With all three patterns:
- API calls: 80% reduction (debouncing)
- Race conditions: 0% (AbortController)
- Input lag: 0ms (useTransition)
- User experience: ‚≠ê‚≠ê‚≠ê‚≠ê‚≠ê

---

## Advanced: Search with Filters

Combine search with filters (category, date range, etc.)

```tsx
export function SearchThreads() {
  const [query, setQuery] = useState('')
  const debouncedQuery = useDebounce(query, 300)
  const [selectedCategory, setSelectedCategory] = useState<string | null>(null)
  const [results, setResults] = useState<Thread[]>([])
  const [isSearching, setIsSearching] = useState(false)

  useEffect(() => {
    if (!debouncedQuery.trim()) {
      setResults([])
      return
    }

    const controller = new AbortController()

    async function search() {
      setIsSearching(true)

      try {
        const response = await apiClient.get<Thread[]>('/threads/search', {
          params: {
            q: debouncedQuery,
            categoryId: selectedCategory,  // Add filter
          },
          signal: controller.signal,
        })

        if (!controller.signal.aborted) {
          setResults(response.data)
        }
      } catch (err) {
        if (!controller.signal.aborted) {
          console.error(err)
        }
      } finally {
        if (!controller.signal.aborted) {
          setIsSearching(false)
        }
      }
    }

    search()

    return () => controller.abort()
  }, [debouncedQuery, selectedCategory])  // Re-search when filter changes

  return (
    <div>
      <input
        value={query}
        onChange={(e) => setQuery(e.target.value)}
        placeholder="Search..."
      />
      
      <select
        value={selectedCategory || ''}
        onChange={(e) => setSelectedCategory(e.target.value || null)}
      >
        <option value="">All Categories</option>
        {/* Category options */}
      </select>

      <ThreadList threads={results} />
    </div>
  )
}
```

---

## URL Integration

Store search query in URL for bookmarking/sharing.

```tsx
import { useSearchParams } from 'react-router-dom'

export function SearchThreads() {
  const [searchParams, setSearchParams] = useSearchParams()
  
  /**
   * Get query from URL
   * 
   * URL: /search?q=react
   * query will be 'react'
   */
  const query = searchParams.get('q') || ''
  const debouncedQuery = useDebounce(query, 300)
  
  const [results, setResults] = useState<Thread[]>([])
  const [isSearching, setIsSearching] = useState(false)

  /**
   * Update URL when query changes
   */
  const handleQueryChange = (newQuery: string) => {
    if (newQuery) {
      setSearchParams({ q: newQuery })
    } else {
      setSearchParams({})  // Remove query param if empty
    }
  }

  /**
   * Search effect (same as before)
   */
  useEffect(() => {
    // ... search logic
  }, [debouncedQuery])

  return (
    <input
      value={query}
      onChange={(e) => handleQueryChange(e.target.value)}
      placeholder="Search..."
    />
  )
}
```

**Benefits:**
- URL is shareable: `/search?q=react hooks`
- Bookmarkable: Save search for later
- Back button works: Go back to previous search
- Deep linking: Link directly to search results

---

## Highlighting Search Results

Highlight matched terms in results.

```tsx
function highlightText(text: string, query: string): string {
  if (!query) return text

  const regex = new RegExp(`(${query})`, 'gi')
  return text.replace(regex, '<mark>$1</mark>')
}

function SearchResultCard({ thread, query }: { thread: Thread; query: string }) {
  return (
    <div>
      <h3 dangerouslySetInnerHTML={{ __html: highlightText(thread.title, query) }} />
      <p dangerouslySetInnerHTML={{ __html: highlightText(thread.excerpt, query) }} />
    </div>
  )
}
```

---

## Summary

### Key Concepts

1. **Debouncing**: Wait for user to stop typing
   ```tsx
   const debouncedValue = useDebounce(value, 300)
   ```

2. **AbortController**: Cancel old requests
   ```tsx
   const controller = new AbortController()
   fetch(url, { signal: controller.signal })
   controller.abort()
   ```

3. **Race Conditions**: Handle out-of-order responses
   ```tsx
   if (!controller.signal.aborted) {
     setResults(data)  // Only update if not aborted
   }
   ```

4. **URL State**: Persist search in URL
   ```tsx
   const query = searchParams.get('q')
   setSearchParams({ q: newQuery })
   ```

### Best Practices

- ‚úÖ Debounce search input (300-500ms is good)
- ‚úÖ Cancel old requests when new ones start
- ‚úÖ Show loading state during search
- ‚úÖ Handle empty results gracefully
- ‚úÖ Store search query in URL
- ‚úÖ Highlight matched terms in results
- ‚úÖ Provide clear error messages

### Common Pitfalls

- ‚ùå Searching on every keystroke (too many requests)
- ‚ùå Not canceling old requests (race conditions)
- ‚ùå Not handling AbortError (unnecessary error logs)
- ‚ùå Forgetting to clear results when query is empty
- ‚ùå Not checking `signal.aborted` before updating state

---

## Threads Module Complete! üéâ

You've mastered:
- ‚úÖ Listing threads with pagination
- ‚úÖ Thread detail with parallel fetching
- ‚úÖ Creating threads with markdown editor
- ‚úÖ Filtering and sorting with derived state
- ‚úÖ Real-time search with debouncing

**Next:** Posts module (nested replies, voting, rich interactions)

Continue to [Posts Module ‚Üí](/en/react/5.posts-module/1.display-posts)
