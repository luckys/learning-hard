---
title: Filter & Sort Threads
description: Master derived state, URL persistence, and state minimization patterns for filtering and sorting.
---

# Disclaimer

:::u-alert
---
title: Comments in the code are for educational purposes only.
description: In real projects, avoid adding irrelevant or redundant comments.
color: warning
variant: subtle
icon: i-lucide-triangle-alert
---
:::

Users need to filter threads (by category, author) and sort them (recent, popular). We'll implement this using **derived state** - calculate values from existing state instead of storing duplicates.

---

## The Problem: Redundant State

**‚ùå Common mistake: Store filtered results in state**

```tsx
function ThreadsPage() {
  const [threads, setThreads] = useState<Thread[]>([])
  const [filteredThreads, setFilteredThreads] = useState<Thread[]>([])  // ‚ùå Redundant!
  const [filter, setFilter] = useState('all')

  useEffect(() => {
    // Have to manually keep filteredThreads in sync
    const filtered = threads.filter(/* ... */)
    setFilteredThreads(filtered)
  }, [threads, filter])

  // What if threads update from elsewhere?
  // filteredThreads might be stale!
}
```

**Problems:**
- Two sources of truth (`threads` and `filteredThreads`)
- Easy to get out of sync
- Extra re-renders
- More memory usage

---

## The Solution: Derived State

**‚úÖ Calculate on every render**

```tsx
function ThreadsPage() {
  const [threads, setThreads] = useState<Thread[]>([])
  const [filter, setFilter] = useState('all')

  // Derived: always in sync with threads and filter
  const filteredThreads = threads.filter(/* ... */)
  
  // No useEffect needed!
  // No risk of stale data!
}
```

**Why this works:**
- Single source of truth (`threads`)
- Always up-to-date (recalculates every render)
- Less code
- Fewer bugs

**"But isn't recalculating expensive?"**

For most cases, no! Filtering/sorting arrays with hundreds of items is fast (<1ms). If it becomes slow, use `useMemo` (we'll cover that later).

---

## Filter Types

```typescript
// src/types/filters.ts

export type ThreadFilter = 
  | 'all'           // All threads
  | 'my'            // Threads I created
  | 'following'     // Threads I'm following
  | 'unanswered'    // Threads with no replies
  | 'solved'        // Threads marked as solved

export type ThreadSort = 
  | 'recent'        // Newest first
  | 'popular'       // Most views
  | 'trending'      // Most replies in last 24h
  | 'unanswered'    // Oldest unanswered first
```

---

## Threads Page with Filters

```tsx
// src/pages/ThreadsPage.tsx

import { useState, useEffect } from 'react'
import { useAuth } from '@/features/auth/hooks/useAuth'
import { ThreadFilters } from '@/components/threads/ThreadFilters'
import { ThreadSortDropdown } from '@/components/threads/ThreadSortDropdown'
import { ThreadList } from '@/components/threads/ThreadList'
import { apiClient } from '@/lib/api-client'
import type { Thread, ThreadFilter, ThreadSort } from '@/types'

export function ThreadsPage() {
  const { user } = useAuth()
  
  /**
   * Source state: threads from API
   */
  const [threads, setThreads] = useState<Thread[]>([])
  const [isLoading, setIsLoading] = useState(true)
  
  /**
   * UI state: current filter and sort
   * 
   * These are the ONLY things we store in state
   * Everything else is derived
   */
  const [activeFilter, setActiveFilter] = useState<ThreadFilter>('all')
  const [activeSort, setActiveSort] = useState<ThreadSort>('recent')

  /**
   * Fetch threads on mount
   */
  useEffect(() => {
    async function fetchThreads() {
      try {
        const response = await apiClient.get<{ data: Thread[] }>('/threads')
        setThreads(response.data.data)
      } catch (error) {
        console.error('Failed to fetch threads:', error)
      } finally {
        setIsLoading(false)
      }
    }

    fetchThreads()
  }, [])

  /**
   * DERIVED STATE: Filter threads
   * 
   * Why derived?
   * - Always in sync with source data
   * - No useEffect needed
   * - Single source of truth
   * 
   * This recalculates on every render, but it's fast
   */
  const filteredThreads = threads.filter((thread) => {
    switch (activeFilter) {
      case 'all':
        return true
      
      case 'my':
        // Only threads I created
        return user && thread.authorId === user.id
      
      case 'following':
        // Only threads I'm following (would need following data)
        return thread.isFollowing === true
      
      case 'unanswered':
        // Threads with no replies
        return thread.replyCount === 0
      
      case 'solved':
        // Threads marked as solved
        return thread.isSolved === true
      
      default:
        return true
    }
  })

  /**
   * DERIVED STATE: Sort filtered threads
   * 
   * Why create a copy with [...filteredThreads]?
   * - .sort() mutates the array
   * - We don't want to mutate filteredThreads
   * - Spread creates a shallow copy
   */
  const sortedThreads = [...filteredThreads].sort((a, b) => {
    switch (activeSort) {
      case 'recent':
        // Newest first
        return new Date(b.createdAt).getTime() - new Date(a.createdAt).getTime()
      
      case 'popular':
        // Most views first
        return b.viewCount - a.viewCount
      
      case 'trending':
        // Most replies in last 24h
        // (In real app, would filter by date)
        return b.replyCount - a.replyCount
      
      case 'unanswered':
        // Oldest unanswered first
        if (a.replyCount === 0 && b.replyCount > 0) return -1
        if (b.replyCount === 0 && a.replyCount > 0) return 1
        return new Date(a.createdAt).getTime() - new Date(b.createdAt).getTime()
      
      default:
        return 0
    }
  })

  if (isLoading) {
    return <ThreadListSkeleton />
  }

  return (
    <div className="container mx-auto px-4 py-8">
      {/* Header */}
      <div className="flex items-center justify-between mb-6">
        <h1 className="text-3xl font-bold text-slate-100">
          Forum Threads
        </h1>
        
        <Link
          to="/threads/new"
          className="px-4 py-2 bg-blue-600 text-white rounded-md hover:bg-blue-700"
        >
          New Thread
        </Link>
      </div>

      {/* Filters and Sort */}
      <div className="flex items-center justify-between mb-6 gap-4">
        <ThreadFilters
          active={activeFilter}
          onChange={setActiveFilter}
        />
        
        <ThreadSortDropdown
          active={activeSort}
          onChange={setActiveSort}
        />
      </div>

      {/* Results count */}
      <p className="text-sm text-slate-400 mb-4">
        Showing {sortedThreads.length} of {threads.length} threads
      </p>

      {/* Thread list */}
      <ThreadList threads={sortedThreads} />

      {/* Empty state */}
      {sortedThreads.length === 0 && (
        <div className="text-center py-12 bg-slate-900 rounded-lg border border-slate-800">
          <p className="text-slate-400">
            No threads match your filters
          </p>
          <button
            onClick={() => {
              setActiveFilter('all')
              setActiveSort('recent')
            }}
            className="mt-4 px-4 py-2 bg-slate-800 text-slate-200 rounded-md hover:bg-slate-700"
          >
            Clear Filters
          </button>
        </div>
      )}
    </div>
  )
}
```

---

## Thread Filters Component

```tsx
// src/components/threads/ThreadFilters.tsx

import type { ThreadFilter } from '@/types'

interface ThreadFiltersProps {
  active: ThreadFilter
  onChange: (filter: ThreadFilter) => void
}

/**
 * Filter buttons for threads
 * 
 * This is a "controlled component":
 * - Parent owns the state (activeFilter)
 * - Parent passes current value and change handler
 * - This component just renders and calls onChange
 * 
 * Benefits:
 * - State can be synced with URL
 * - Easy to test (no internal state)
 * - Multiple components can share same state
 */
export function ThreadFilters({ active, onChange }: ThreadFiltersProps) {
  /**
   * Filter definitions
   * 
   * Data-driven rendering: map over array instead of hardcoding buttons
   */
  const filters: { value: ThreadFilter; label: string; icon: string }[] = [
    { value: 'all', label: 'All Threads', icon: 'üìö' },
    { value: 'my', label: 'My Threads', icon: '‚úèÔ∏è' },
    { value: 'following', label: 'Following', icon: '‚≠ê' },
    { value: 'unanswered', label: 'Unanswered', icon: '‚ùì' },
    { value: 'solved', label: 'Solved', icon: '‚úÖ' },
  ]

  return (
    <div className="flex gap-2 flex-wrap">
      {filters.map((filter) => (
        <button
          key={filter.value}
          onClick={() => onChange(filter.value)}
          className={`
            px-4 py-2 rounded-lg font-medium transition-colors
            flex items-center gap-2
            ${
              active === filter.value
                ? 'bg-blue-600 text-white'
                : 'bg-slate-800 text-slate-300 hover:bg-slate-700'
            }
          `}
        >
          <span>{filter.icon}</span>
          <span>{filter.label}</span>
        </button>
      ))}
    </div>
  )
}
```

---

## Thread Sort Dropdown

```tsx
// src/components/threads/ThreadSortDropdown.tsx

import type { ThreadSort } from '@/types'

interface ThreadSortDropdownProps {
  active: ThreadSort
  onChange: (sort: ThreadSort) => void
}

export function ThreadSortDropdown({ active, onChange }: ThreadSortDropdownProps) {
  const sortOptions: { value: ThreadSort; label: string }[] = [
    { value: 'recent', label: 'Most Recent' },
    { value: 'popular', label: 'Most Popular' },
    { value: 'trending', label: 'Trending' },
    { value: 'unanswered', label: 'Oldest Unanswered' },
  ]

  return (
    <div className="flex items-center gap-2">
      <span className="text-sm text-slate-400">Sort by:</span>
      <select
        value={active}
        onChange={(e) => onChange(e.target.value as ThreadSort)}
        className="px-3 py-2 bg-slate-800 border border-slate-700 rounded-md text-slate-200 focus:border-blue-500"
      >
        {sortOptions.map((option) => (
          <option key={option.value} value={option.value}>
            {option.label}
          </option>
        ))}
      </select>
    </div>
  )
}
```

---

## URL State Persistence

Users expect filters to persist when sharing links or refreshing. Store filter/sort in URL.

```tsx
import { useSearchParams } from 'react-router-dom'

export function ThreadsPage() {
  const [searchParams, setSearchParams] = useSearchParams()
  const { user } = useAuth()
  
  /**
   * Get filter/sort from URL, with fallbacks
   * 
   * URL: /threads?filter=my&sort=popular
   * searchParams.get('filter') returns 'my'
   */
  const activeFilter = (searchParams.get('filter') as ThreadFilter) || 'all'
  const activeSort = (searchParams.get('sort') as ThreadSort) || 'recent'

  /**
   * Update URL when filter/sort changes
   */
  const handleFilterChange = (filter: ThreadFilter) => {
    setSearchParams({
      filter,
      sort: activeSort,
    })
  }

  const handleSortChange = (sort: ThreadSort) => {
    setSearchParams({
      filter: activeFilter,
      sort,
    })
  }

  // Rest of component uses activeFilter and activeSort from URL
  // ...
}
```

**Benefits:**
- Bookmarkable: `/threads?filter=my&sort=popular`
- Shareable: Send link to friend with your filters
- Back button works: Browser history tracks filter changes
- Refresh preserves state

---

## Performance: When to Use useMemo

**Rule: Don't optimize prematurely!**

Filtering/sorting is usually fast enough without memoization. But if you have thousands of threads:

```tsx
import { useMemo } from 'react'

export function ThreadsPage() {
  const [threads, setThreads] = useState<Thread[]>([])
  const [activeFilter, setActiveFilter] = useState('all')
  const [activeSort, setActiveSort] = useState('recent')

  /**
   * useMemo: Cache expensive calculation
   * 
   * Only recalculate when dependencies change
   */
  const sortedThreads = useMemo(() => {
    // Filter
    const filtered = threads.filter((thread) => {
      // ... filtering logic
    })

    // Sort
    return [...filtered].sort((a, b) => {
      // ... sorting logic
    })
  }, [threads, activeFilter, activeSort])  // Dependencies

  // sortedThreads is cached between renders
  // Only recalculates when threads, activeFilter, or activeSort change
}
```

### useMemo Deep Dive

**Without useMemo:**
```tsx
// Recalculates EVERY render
const sortedThreads = threads.filter(...).sort(...)

// Even if you just hover a button ‚Üí re-render ‚Üí recalculate
```

**With useMemo:**
```tsx
// Recalculates ONLY when dependencies change
const sortedThreads = useMemo(() => {
  return threads.filter(...).sort(...)
}, [threads, activeFilter, activeSort])
```

**When to use useMemo:**
- ‚úÖ Expensive calculations (sorting 10,000 items)
- ‚úÖ Creating objects/arrays passed to children (prevents re-renders)
- ‚úÖ You've measured and it's actually slow

**When NOT to use:**
- ‚ùå Cheap calculations (adding numbers, accessing properties)
- ‚ùå Premature optimization (measure first!)
- ‚ùå Every calculation "just in case"

---

## Category Filter

Add category-specific filtering.

```tsx
export function ThreadsPage() {
  const { categorySlug } = useParams<{ categorySlug?: string }>()
  const [threads, setThreads] = useState<Thread[]>([])
  const [activeFilter, setActiveFilter] = useState<ThreadFilter>('all')
  const [activeSort, setActiveSort] = useState<ThreadSort>('recent')

  /**
   * Filter by category if categorySlug exists
   * 
   * URL: /categories/technical-support/threads
   */
  const filteredThreads = threads
    .filter((thread) => {
      // First: filter by category if categorySlug exists
      if (categorySlug && thread.category.slug !== categorySlug) {
        return false
      }

      // Then: apply user-selected filter
      switch (activeFilter) {
        case 'all':
          return true
        case 'my':
          return user && thread.authorId === user.id
        // ... other filters
        default:
          return true
      }
    })
    .sort((a, b) => {
      // ... sorting logic
    })

  return (
    <div>
      {categorySlug && (
        <div className="mb-4">
          <Link to="/threads" className="text-blue-400 hover:text-blue-300">
            ‚Üê All Categories
          </Link>
        </div>
      )}
      
      <ThreadList threads={filteredThreads} />
    </div>
  )
}
```

---

## Summary

### Key Concepts

1. **Derived State**: Calculate from existing state, don't store duplicates
   ```tsx
   const filtered = threads.filter(...)  // ‚úÖ Derived
   const [filtered, setFiltered] = useState([])  // ‚ùå Redundant
   ```

2. **Controlled Components**: Parent owns state, child just renders
   ```tsx
   <ThreadFilters active={filter} onChange={setFilter} />
   ```

3. **URL State**: Persist filters in URL for bookmarking/sharing
   ```tsx
   const [searchParams, setSearchParams] = useSearchParams()
   ```

4. **useMemo**: Cache expensive calculations
   ```tsx
   const sorted = useMemo(() => expensive(), [deps])
   ```

5. **Array Immutability**: Copy before sorting
   ```tsx
   [...array].sort()  // ‚úÖ Creates copy
   array.sort()  // ‚ùå Mutates original
   ```

### Best Practices

- ‚úÖ Keep state minimal (store filter/sort, derive results)
- ‚úÖ Persist UI state in URL when appropriate
- ‚úÖ Use controlled components for shared state
- ‚úÖ Don't optimize prematurely (measure first!)
- ‚úÖ Copy arrays before sorting/mutating

---

Next: [Search Threads ‚Üí](/en/react/4.threads-module/5.search)
