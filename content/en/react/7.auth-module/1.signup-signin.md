---
title: Sign Up & Sign In - Validation Patterns & Security
description: Master multi-layer validation, password security, async validation, error handling, and JWT token management. Build production-ready authentication forms.
---

# Disclaimer

:::u-alert
---
title: Comments in the code are for educational purposes only.
description: In real projects, avoid adding irrelevant or redundant comments.
color: warning
variant: subtle
icon: i-lucide-triangle-alert
---
:::

Authentication is the gateway to your app. Building secure auth forms requires **multi-layer validation**: HTML5 for UX, client-side for feedback, async for real-time checks, and server-side for security. Never trust the client.

---

## The Validation Pyramid: Defense in Depth

Validation is **not a single layer**. It's a pyramid where each layer catches different errors:

```
        ┌──────────────────────────────────────┐
        │   Server-Side Validation             │ (CRITICAL - can't trust client)
        │  • Email not already registered      │
        │  • Password strength verified        │
        │  • Rate limiting enforced            │
        │  • CSRF tokens validated             │
        ├──────────────────────────────────────┤
        │   API Response Validation            │ (Catch server errors)
        │  • Parse response structure          │
        │  • Validate token format             │
        ├──────────────────────────────────────┤
        │   Submit Handler Validation          │ (Before API call)
        │  • Final schema check                │
        │  • Async checks (email exists?)      │
        ├──────────────────────────────────────┤
        │   Real-Time Validation               │ (As user types)
        │  • Password strength feedback        │
        │  • Username availability check       │
        │  • Email format validation           │
        ├──────────────────────────────────────┤
        │   HTML5 Native Validation            │ (Obvious mistakes)
        │  • type="email" format               │
        │  • required attribute                │
        │  • minlength/maxlength               │
        └──────────────────────────────────────┘
```

**Why multiple layers?**
- **HTML5**: Catches obvious mistakes (empty, invalid format)
- **Real-time**: Gives instant feedback (password too weak)
- **Submit**: Final check before API (all fields valid?)
- **API**: Catches server-side issues (email already exists)
- **Server**: Final security check (can't trust client)

**Key principle**: Never trust client-side validation alone. Always validate on the server.

---

## Validation Schemas with Zod

### Password Security Rules

```typescript
// src/features/auth/schemas.ts

import { z } from 'zod'

/**
 * Password validation rules based on NIST guidelines
 * 
 * Why these rules?
 * - 8 chars: Minimum entropy (NIST recommendation)
 * - Uppercase: Increases character set (harder to brute force)
 * - Number: Prevents common patterns (password123)
 * - Special char: Further increases entropy
 * 
 * Why NOT these rules?
 * - Frequent changes: Users write them down (NIST says no)
 * - Expiration: Doesn't improve security
 * - Complexity rules only: Better to enforce length
 */
const passwordSchema = z
  .string('Password required')
  .min(8, 'Password must be at least 8 characters')
  .regex(/[A-Z]/, 'Must contain at least one uppercase letter')
  .regex(/[0-9]/, 'Must contain at least one number')
  .regex(/[!@#$%^&*]/, 'Must contain at least one special character (!@#$%^&*)')

/**
 * Username validation
 * 
 * Why lowercase only?
 * - Prevents alice vs Alice being different users
 * - Simpler database queries
 * - Better UX (no case confusion)
 */
const usernameSchema = z
  .string('Username required')
  .min(3, 'Username must be at least 3 characters')
  .max(20, 'Username must be at most 20 characters')
  .regex(/^[a-z0-9_]+$/, 'Only lowercase letters, numbers, and underscores')
  .transform((val) => val.toLowerCase())  // Normalize to lowercase

export const signUpSchema = z
  .object({
    username: usernameSchema,
    email: z
      .string('Email required')
      .email('Please enter a valid email')
      .toLowerCase()
      .transform((val) => val.trim()),  // Remove whitespace
    
    password: passwordSchema,
    
    confirmPassword: z.string('Please confirm password'),
  })
  .refine((data) => data.password === data.confirmPassword, {
    message: "Passwords don't match",
    path: ['confirmPassword'],
  })

export type SignUpInput = z.infer<typeof signUpSchema>

export const signInSchema = z.object({
  email: z
    .string('Email required')
    .email('Please enter a valid email')
    .toLowerCase()
    .transform((val) => val.trim()),
  
  password: z
    .string('Password required')
    .min(1, 'Password required'),
})

export type SignInInput = z.infer<typeof signInSchema>
```

### Async Validation: Check Email Availability

```typescript
/**
 * Async validation: Check if email already registered
 * 
 * This runs AFTER sync validation passes
 * Only called on form submission (not on every keystroke)
 * 
 * Why async?
 * - Can't validate without API call
 * - Expensive operation (database query)
 * - Should only run when necessary
 */
export const signUpSchemaWithAsync = signUpSchema.refine(
  async (data) => {
    try {
      const response = await fetch('/api/auth/check-email', {
        method: 'POST',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify({ email: data.email }),
      })
      
      const { exists } = await response.json()
      return !exists  // Return true if email is available
    } catch (error) {
      // If API fails, allow submission (server will catch it)
      console.error('Email check failed:', error)
      return true
    }
  },
  {
    message: 'Email already registered. Try signing in instead.',
    path: ['email'],
  }
)
```

---

## Sign Up Form

```tsx
// src/pages/SignUpPage.tsx

import { useForm } from 'react-hook-form'
import { zodResolver } from '@hookform/resolvers/zod'
import { z } from 'zod'
import { apiClient } from '@/lib/api-client'
import { useNavigate } from 'react-router-dom'

const signUpSchema = z.object({
  username: z.string().min(3).max(20).regex(/^[a-zA-Z0-9_]+$/),
  email: z.string().email(),
  password: z.string().min(8),
  confirmPassword: z.string(),
}).refine((data) => data.password === data.confirmPassword, {
  message: "Passwords don't match",
  path: ['confirmPassword'],
})

type SignUpInput = z.infer<typeof signUpSchema>

export function SignUpPage() {
  const navigate = useNavigate()
  const { register, handleSubmit, formState: { errors, isSubmitting } } = useForm<SignUpInput>({
    resolver: zodResolver(signUpSchema),
  })

  const onSubmit = async (data: SignUpInput) => {
    try {
      const response = await apiClient.post('/auth/signup', {
        username: data.username,
        email: data.email,
        password: data.password,
      })

      // Store JWT token
      localStorage.setItem('auth_token', response.data.token)

      // Redirect to home
      navigate('/')
    } catch (error) {
      // Handle errors (email already exists, etc.)
    }
  }

  return (
    <div className="min-h-screen flex items-center justify-center bg-slate-950">
      <div className="w-full max-w-md p-8 bg-slate-900 rounded-lg border border-slate-800">
        <h1 className="text-2xl font-bold mb-6">Create Account</h1>

        <form onSubmit={handleSubmit(onSubmit)} className="space-y-4">
          <div>
            <label className="block text-sm font-medium mb-2">Username</label>
            <input {...register('username')} className="w-full px-4 py-2 bg-slate-800 border border-slate-700 rounded-lg" />
            {errors.username && <p className="text-red-400 text-sm mt-1">{errors.username.message}</p>}
          </div>

          <div>
            <label className="block text-sm font-medium mb-2">Email</label>
            <input type="email" {...register('email')} className="w-full px-4 py-2 bg-slate-800 border border-slate-700 rounded-lg" />
            {errors.email && <p className="text-red-400 text-sm mt-1">{errors.email.message}</p>}
          </div>

          <div>
            <label className="block text-sm font-medium mb-2">Password</label>
            <input type="password" {...register('password')} className="w-full px-4 py-2 bg-slate-800 border border-slate-700 rounded-lg" />
            {errors.password && <p className="text-red-400 text-sm mt-1">{errors.password.message}</p>}
          </div>

          <div>
            <label className="block text-sm font-medium mb-2">Confirm Password</label>
            <input type="password" {...register('confirmPassword')} className="w-full px-4 py-2 bg-slate-800 border border-slate-700 rounded-lg" />
            {errors.confirmPassword && <p className="text-red-400 text-sm mt-1">{errors.confirmPassword.message}</p>}
          </div>

          <button
            type="submit"
            disabled={isSubmitting}
            className="w-full px-4 py-3 bg-blue-600 text-white rounded-lg hover:bg-blue-700 font-medium"
          >
            {isSubmitting ? 'Creating account...' : 'Sign Up'}
          </button>
        </form>
      </div>
    </div>
  )
}
```

---

## Sign In Form

```tsx
// src/pages/SignInPage.tsx

const signInSchema = z.object({
  email: z.string().email(),
  password: z.string().min(1, 'Password is required'),
})

type SignInInput = z.infer<typeof signInSchema>

export function SignInPage() {
  const navigate = useNavigate()
  const { register, handleSubmit, formState: { errors, isSubmitting } } = useForm<SignInInput>({
    resolver: zodResolver(signInSchema),
  })

  const onSubmit = async (data: SignInInput) => {
    try {
      const response = await apiClient.post('/auth/signin', data)
      localStorage.setItem('auth_token', response.data.token)
      navigate('/')
    } catch (error) {
      // Handle invalid credentials
    }
  }

  return (
    <div className="min-h-screen flex items-center justify-center bg-slate-950">
      <div className="w-full max-w-md p-8 bg-slate-900 rounded-lg border border-slate-800">
        <h1 className="text-2xl font-bold mb-6">Sign In</h1>

        <form onSubmit={handleSubmit(onSubmit)} className="space-y-4">
          <div>
            <label className="block text-sm font-medium mb-2">Email</label>
            <input type="email" {...register('email')} className="w-full px-4 py-2 bg-slate-800 border border-slate-700 rounded-lg" />
            {errors.email && <p className="text-red-400 text-sm mt-1">{errors.email.message}</p>}
          </div>

          <div>
            <label className="block text-sm font-medium mb-2">Password</label>
            <input type="password" {...register('password')} className="w-full px-4 py-2 bg-slate-800 border border-slate-700 rounded-lg" />
            {errors.password && <p className="text-red-400 text-sm mt-1">{errors.password.message}</p>}
          </div>

          <button
            type="submit"
            disabled={isSubmitting}
            className="w-full px-4 py-3 bg-blue-600 text-white rounded-lg hover:bg-blue-700 font-medium"
          >
            {isSubmitting ? 'Signing in...' : 'Sign In'}
          </button>
        </form>
      </div>
    </div>
  )
}
```

---

## Validation Best Practices

### 1. Normalize User Input

```typescript
// Zod transforms normalize data before validation
const schema = z.object({
  email: z.string().email().toLowerCase().trim(),
  username: z.string().toLowerCase(),
})

// User types: "  ALICE@EXAMPLE.COM  "
// Stored as: "alice@example.com"
// Benefit: No duplicate accounts due to case/whitespace
```

### 2. Password Security

✅ **DO:**
- Require minimum 8 characters (NIST SP 800-63B)
- Require mixed case + numbers + symbols
- Hash on server (bcrypt, argon2, scrypt)
- Use HTTPS only (never HTTP)
- Implement rate limiting (5 attempts, 15 min lockout)
- Use secure random tokens (crypto.getRandomValues)

❌ **DON'T:**
- Send passwords in plain text
- Store passwords unhashed
- Require frequent changes (NIST says no)
- Restrict special characters
- Implement password hints
- Show password requirements AFTER submission

### 3. Error Messages: Be Helpful, Not Leaky

✅ **Good error messages:**
```
❌ "Email already registered. Try signing in instead."
❌ "Password must contain uppercase, number, and special character."
❌ "Username must be 3-20 characters, lowercase only."
```

❌ **Bad error messages:**
```
❌ "Invalid input"
❌ "Error"
❌ "Email not found" (reveals if email exists)
❌ "Username taken" (reveals if username exists)
```

**Why?** Good messages help users fix errors. Bad messages leak information (email enumeration attacks).

### 4. Rate Limiting: Prevent Brute Force

```typescript
// Server-side (pseudo-code)
async function handleSignUp(email, password) {
  // Check rate limit: max 5 attempts per 15 minutes
  const attempts = await getRecentAttempts(email)
  
  if (attempts >= 5) {
    const oldestAttempt = attempts[0].timestamp
    const timeSinceOldest = Date.now() - oldestAttempt
    
    if (timeSinceOldest < 15 * 60 * 1000) {
      // Still within 15 minute window
      throw new Error('Too many attempts. Try again later.')
    }
  }
  
  // Validate and create account...
}
```

### 5. CSRF Protection

```typescript
// Include CSRF token in form submission
<form>
  <input type="hidden" name="csrf_token" value={csrfToken} />
  {/* form fields */}
</form>

// Server validates token
if (request.body.csrf_token !== session.csrf_token) {
  throw new Error('Invalid CSRF token')
}
```

---

## Advanced: useId for Accessible Forms

**Problem:** Form labels need unique IDs to associate with inputs. Hardcoding IDs causes issues:
- Duplicate IDs in SSR (server + client)
- ID collisions when reusing components
- Manual ID management is error-prone

**Solution:** `useId` generates unique, stable IDs automatically.

### What is useId?

`useId` generates a unique ID that:
- ✅ Is stable across renders
- ✅ Works with server-side rendering
- ✅ Prevents ID collisions
- ✅ Is automatically unique per component instance

### How It Works

```tsx
import { useId } from 'react'

function SignUpForm() {
  // Generate unique IDs for this form instance
  const usernameId = useId()
  const emailId = useId()
  const passwordId = useId()
  
  return (
    <form>
      {/* Label htmlFor matches input id */}
      <label htmlFor={usernameId}>Username</label>
      <input id={usernameId} name="username" />
      
      <label htmlFor={emailId}>Email</label>
      <input id={emailId} name="email" type="email" />
      
      <label htmlFor={passwordId}>Password</label>
      <input id={passwordId} name="password" type="password" />
    </form>
  )
}
```

### Why This Matters for Accessibility

**Without proper IDs:**
```html
<!-- ❌ BAD: Label not associated with input -->
<label>Username</label>
<input name="username" />

<!-- Screen reader can't connect them -->
<!-- Clicking label doesn't focus input -->
```

**With useId:**
```html
<!-- ✅ GOOD: Label properly associated -->
<label for="username-abc123">Username</label>
<input id="username-abc123" name="username" />

<!-- Screen reader announces: "Username input" -->
<!-- Clicking label focuses input -->
```

### Complete Accessible Form

```tsx
import { useId } from 'react'
import { useForm } from 'react-hook-form'
import { zodResolver } from '@hookform/resolvers/zod'
import { signUpSchema } from '@/features/auth/schemas'
import type { SignUpInput } from '@/features/auth/schemas'

export function AccessibleSignUpForm() {
  // Generate unique IDs for this form instance
  const usernameId = useId()
  const emailId = useId()
  const passwordId = useId()
  const confirmPasswordId = useId()
  
  const { register, handleSubmit, formState: { errors } } = useForm<SignUpInput>({
    resolver: zodResolver(signUpSchema),
  })

  return (
    <form onSubmit={handleSubmit(onSubmit)} className="space-y-4">
      {/* Username field */}
      <div>
        <label htmlFor={usernameId} className="block text-sm font-medium mb-2">
          Username
          <span className="text-red-500" aria-label="required">*</span>
        </label>
        <input
          id={usernameId}
          {...register('username')}
          placeholder="3-20 characters, lowercase only"
          className="w-full px-4 py-2 bg-slate-800 border border-slate-700 rounded-lg"
          aria-invalid={!!errors.username}
          aria-describedby={errors.username ? `${usernameId}-error` : undefined}
        />
        {errors.username && (
          <p id={`${usernameId}-error`} className="text-red-400 text-sm mt-1" role="alert">
            {errors.username.message}
          </p>
        )}
      </div>

      {/* Email field */}
      <div>
        <label htmlFor={emailId} className="block text-sm font-medium mb-2">
          Email
          <span className="text-red-500" aria-label="required">*</span>
        </label>
        <input
          id={emailId}
          type="email"
          {...register('email')}
          placeholder="your@email.com"
          className="w-full px-4 py-2 bg-slate-800 border border-slate-700 rounded-lg"
          aria-invalid={!!errors.email}
          aria-describedby={errors.email ? `${emailId}-error` : undefined}
        />
        {errors.email && (
          <p id={`${emailId}-error`} className="text-red-400 text-sm mt-1" role="alert">
            {errors.email.message}
          </p>
        )}
      </div>

      {/* Password field */}
      <div>
        <label htmlFor={passwordId} className="block text-sm font-medium mb-2">
          Password
          <span className="text-red-500" aria-label="required">*</span>
        </label>
        <input
          id={passwordId}
          type="password"
          {...register('password')}
          placeholder="Min 8 chars, uppercase, number, special char"
          className="w-full px-4 py-2 bg-slate-800 border border-slate-700 rounded-lg"
          aria-invalid={!!errors.password}
          aria-describedby={errors.password ? `${passwordId}-error` : undefined}
        />
        {errors.password && (
          <p id={`${passwordId}-error`} className="text-red-400 text-sm mt-1" role="alert">
            {errors.password.message}
          </p>
        )}
      </div>

      {/* Confirm Password field */}
      <div>
        <label htmlFor={confirmPasswordId} className="block text-sm font-medium mb-2">
          Confirm Password
          <span className="text-red-500" aria-label="required">*</span>
        </label>
        <input
          id={confirmPasswordId}
          type="password"
          {...register('confirmPassword')}
          placeholder="Re-enter your password"
          className="w-full px-4 py-2 bg-slate-800 border border-slate-700 rounded-lg"
          aria-invalid={!!errors.confirmPassword}
          aria-describedby={errors.confirmPassword ? `${confirmPasswordId}-error` : undefined}
        />
        {errors.confirmPassword && (
          <p id={`${confirmPasswordId}-error`} className="text-red-400 text-sm mt-1" role="alert">
            {errors.confirmPassword.message}
          </p>
        )}
      </div>

      <button
        type="submit"
        className="w-full px-4 py-3 bg-blue-600 text-white rounded-lg hover:bg-blue-700 font-medium"
      >
        Create Account
      </button>
    </form>
  )
}
```

### Accessibility Attributes Explained

| Attribute | Purpose | Example |
|-----------|---------|---------|
| `htmlFor` | Links label to input | `<label htmlFor={id}>` |
| `id` | Unique identifier | `<input id={id}>` |
| `aria-invalid` | Marks invalid fields | `aria-invalid={hasError}` |
| `aria-describedby` | Links error messages | `aria-describedby={errorId}` |
| `role="alert"` | Announces errors | `<p role="alert">` |

### Key Benefits

✅ **Unique IDs** - No collisions, even with multiple forms
✅ **SSR compatible** - Works with server-side rendering
✅ **Accessible** - Screen readers understand form structure
✅ **Keyboard navigation** - Clicking labels focuses inputs
✅ **Reusable** - Same component works multiple times

### When to Use useId

- ✅ Form labels and inputs
- ✅ Dialog IDs for aria-labelledby
- ✅ List item IDs
- ✅ Any element needing unique ID
- ❌ NOT for database IDs (use UUIDs instead)
- ❌ NOT for keys in lists (use unique data IDs)

---

## Summary: Validation Patterns

### Key Concepts

1. **Validation Pyramid**: Multiple layers, each catching different errors
   ```
   Server > API Response > Submit > Real-time > HTML5
   ```

2. **Never trust the client**: Always validate on server
   ```tsx
   // Client validation: For UX
   // Server validation: For security
   ```

3. **Async validation**: Check email availability
   ```tsx
   const schema = signUpSchema.refine(async (data) => {
     const exists = await checkEmailExists(data.email)
     return !exists
   })
   ```

4. **Password security**: Follow NIST guidelines
   - 8+ characters
   - Mixed case + numbers + symbols
   - Hash with bcrypt/argon2
   - Rate limit attempts

5. **Error messages**: Helpful but not leaky
   ```
   ✅ "Email already registered"
   ❌ "Email not found"
   ```

### Best Practices

- ✅ Normalize input (lowercase, trim)
- ✅ Validate on client (UX) AND server (security)
- ✅ Use Zod schemas for single source of truth
- ✅ Implement rate limiting
- ✅ Use HTTPS only
- ✅ Hash passwords (never store plain text)
- ✅ Provide helpful error messages
- ✅ Test validation edge cases
- ❌ Don't trust client-side validation
- ❌ Don't leak information in error messages
- ❌ Don't store passwords in logs

---

Next: [Auth Context →](/en/react/7.auth-module/2.auth-context)
