---
title: Auth Context - Global State Management
description: Master React Context API for authentication state, useContext hook, and provider patterns.
---

# Disclaimer

:::u-alert
---
title: Comments in the code are for educational purposes only.
description: In real projects, avoid adding irrelevant or redundant comments.
color: warning
variant: subtle
icon: i-lucide-triangle-alert
---
:::

Authentication state needs to be accessible **everywhere**: navbar, protected routes, user profile, post forms. Passing it through props would be a nightmare. **Context API** solves this by providing global state.

---

## The Problem: Prop Drilling Hell

Before Context, sharing state across the app required passing props through EVERY component in the tree, even if they don't use it.

**Example scenario**: User authentication

```tsx
// ‚ùå PROP DRILLING: Passing user through 5 levels!

function App() {
  const [user, setUser] = useState<User | null>(null)
  
  return <Layout user={user} setUser={setUser} />
}

function Layout({ user, setUser }) {
  // Layout doesn't use user, just passes it down!
  return (
    <div>
      <Navbar user={user} setUser={setUser} />
      <Main user={user} />
    </div>
  )
}

function Navbar({ user, setUser }) {
  // Navbar doesn't use user, just passes it down!
  return (
    <nav>
      <Logo />
      <UserMenu user={user} setUser={setUser} />
    </nav>
  )
}

function UserMenu({ user, setUser }) {
  // FINALLY! This component actually uses user
  return (
    <div>
      {user ? (
        <button onClick={() => setUser(null)}>Sign Out</button>
      ) : (
        <Link to="/sign-in">Sign In</Link>
      )}
    </div>
  )
}
```

**Visual diagram:**
```
        App (has user)
         ‚Üì props
      Layout (doesn't need user, just passes it)
         ‚Üì props
       Navbar (doesn't need user, just passes it)
         ‚Üì props
      UserMenu (FINALLY uses user!)
```

**Problems with prop drilling:**
- ‚ùå **Tedious**: Add props to every intermediate component
- ‚ùå **Fragile**: Change signature, update EVERYTHING
- ‚ùå **Unreadable**: Hard to see where data originates
- ‚ùå **Inefficient**: Components re-render even if they don't use the prop

---

## The Solution: React Context API

**Context** lets you "teleport" data from a parent to ANY descendant, skipping intermediate components.

**With Context:**
```tsx
// ‚úÖ CONTEXT: Direct access from any component!

function App() {
  return (
    <AuthProvider>  {/* Provides user state */}
      <Layout />
    </AuthProvider>
  )
}

function Layout() {
  // No user props! Clean!
  return (
    <div>
      <Navbar />
      <Main />
    </div>
  )
}

function Navbar() {
  // No user props! Clean!
  return (
    <nav>
      <Logo />
      <UserMenu />
    </nav>
  )
}

function UserMenu() {
  // Direct access to user via useAuth hook!
  const { user, signOut } = useAuth()
  
  return (
    <div>
      {user ? (
        <button onClick={signOut}>Sign Out</button>
      ) : (
        <Link to="/sign-in">Sign In</Link>
      )}
    </div>
  )
}
```

**Visual diagram:**
```
        App
         |
    AuthProvider (provides user state)
         |
      Layout (no props!)
         |
       Navbar (no props!)
         |
      UserMenu ‚îÄ‚îÄ‚îÄ useAuth() ‚îÄ‚îÄ‚Üí Gets user directly!
```

**Benefits:**
- ‚úÖ **No prop drilling**: Skip intermediate components
- ‚úÖ **Clean components**: Only components that need data access it
- ‚úÖ **Easy refactoring**: Move components without changing props
- ‚úÖ **Better performance**: Intermediate components don't re-render

---

## Context API: The Three Pieces

Context requires three pieces:

### 1. Create Context

```tsx
import { createContext } from 'react'

/**
 * createContext: Create a "channel" for data
 * 
 * Think of it like a radio frequency:
 * - Provider broadcasts on this frequency
 * - Consumers tune in to this frequency
 * - No interference with other frequencies (contexts)
 */
const AuthContext = createContext<AuthContextType | undefined>(undefined)
```

**Why `undefined` as default?**
- Forces you to wrap app in Provider
- If you forget, you get clear error
- Prevents accidentally using context outside Provider

### 2. Provider Component

```tsx
export function AuthProvider({ children }: { children: ReactNode }) {
  // State lives here
  const [user, setUser] = useState<User | null>(null)
  
  /**
   * Provider: Broadcasts data to descendants
   * 
   * value: What to share (state + functions)
   * children: Components that can access this data
   */
  return (
    <AuthContext.Provider value={{ user, setUser }}>
      {children}
    </AuthContext.Provider>
  )
}
```

**Provider pattern:**
- Wraps your app (or part of it)
- Contains the actual state
- Passes state + setters via `value` prop
- Re-renders consumers when `value` changes

### 3. useContext Hook

```tsx
import { useContext } from 'react'

/**
 * useContext: Access context from any descendant
 * 
 * Like tuning a radio to a frequency:
 * - Listens to AuthContext channel
 * - Gets the current value
 * - Re-renders when value changes
 */
export function useAuth() {
  const context = useContext(AuthContext)
  
  // Safety check: Ensure used within Provider
  if (!context) {
    throw new Error('useAuth must be used within AuthProvider')
  }
  
  return context
}
```

**Why custom hook (`useAuth`) instead of using `useContext` directly?**
- ‚úÖ **Type safety**: No undefined checks everywhere
- ‚úÖ **Better errors**: Clear message if used wrong
- ‚úÖ **Abstraction**: Hide Context implementation details
- ‚úÖ **Convention**: Easier to understand (`useAuth` vs `useContext(AuthContext)`)

---

## Complete Auth Context Implementation

```tsx
// src/contexts/AuthContext.tsx

import { createContext, useContext, useState, useEffect, ReactNode } from 'react'
import { apiClient } from '@/lib/api-client'

interface User {
  id: string
  username: string
  email: string
  role: 'user' | 'moderator' | 'admin'
  avatarUrl: string | null
}

interface AuthContextType {
  user: User | null
  isLoading: boolean
  isAuthenticated: boolean
  signIn: (email: string, password: string) => Promise<void>
  signUp: (data: SignUpData) => Promise<void>
  signOut: () => void
}

const AuthContext = createContext<AuthContextType | undefined>(undefined)

export function AuthProvider({ children }: { children: ReactNode }) {
  const [user, setUser] = useState<User | null>(null)
  const [isLoading, setIsLoading] = useState(true)

  useEffect(() => {
    // Check for existing token on mount
    const token = localStorage.getItem('auth_token')
    if (token) {
      fetchUser()
    } else {
      setIsLoading(false)
    }
  }, [])

  const fetchUser = async () => {
    try {
      const response = await apiClient.get<User>('/auth/me')
      setUser(response.data)
    } catch (error) {
      localStorage.removeItem('auth_token')
    } finally {
      setIsLoading(false)
    }
  }

  const signIn = async (email: string, password: string) => {
    const response = await apiClient.post('/auth/signin', { email, password })
    localStorage.setItem('auth_token', response.data.token)
    setUser(response.data.user)
  }

  const signUp = async (data: SignUpData) => {
    const response = await apiClient.post('/auth/signup', data)
    localStorage.setItem('auth_token', response.data.token)
    setUser(response.data.user)
  }

  const signOut = () => {
    localStorage.removeItem('auth_token')
    setUser(null)
  }

  return (
    <AuthContext.Provider value={{
      user,
      isLoading,
      isAuthenticated: !!user,
      signIn,
      signUp,
      signOut,
    }}>
      {children}
    </AuthContext.Provider>
  )
}

export function useAuth() {
  const context = useContext(AuthContext)
  if (!context) {
    throw new Error('useAuth must be used within AuthProvider')
  }
  return context
}
```

---

## Usage

```tsx
// src/App.tsx

import { AuthProvider } from '@/contexts/AuthContext'

export function App() {
  return (
    <AuthProvider>
      <BrowserRouter>
        <Routes>
          {/* ... */}
        </Routes>
      </BrowserRouter>
    </AuthProvider>
  )
}

// In any component:
import { useAuth } from '@/contexts/AuthContext'

function Navbar() {
  const { user, isAuthenticated, signOut } = useAuth()

  if (!isAuthenticated) {
    return <Link to="/sign-in">Sign In</Link>
  }

  return (
    <div>
      <span>Welcome, {user.username}!</span>
      <button onClick={signOut}>Sign Out</button>
    </div>
  )
}
```

---

## Context Optimization: Preventing Unnecessary Re-renders

**Problem**: Every time Provider's value changes, ALL consumers re-render.

```tsx
// ‚ùå BAD: Creates new object every render!
function AuthProvider({ children }) {
  const [user, setUser] = useState(null)
  const [theme, setTheme] = useState('dark')
  
  return (
    <AuthContext.Provider value={{
      user,        // Different object every time!
      setUser,     // Same function, but in new object
      theme,       // Unrelated state changes cause re-renders
      setTheme,
    }}>
      {children}
    </AuthContext.Provider>
  )
}

// Component that only cares about user
function UserMenu() {
  const { user } = useAuth()
  // Re-renders when theme changes! üò±
  return <div>{user?.name}</div>
}
```

**Solution 1: useMemo to memoize value**

```tsx
import { useMemo } from 'react'

function AuthProvider({ children }) {
  const [user, setUser] = useState(null)
  const [isLoading, setIsLoading] = useState(true)
  
  /**
   * useMemo: Only create new value object when dependencies change
   * 
   * Without useMemo: New object every render
   * With useMemo: Same object until user/isLoading changes
   */
  const value = useMemo(
    () => ({
      user,
      isLoading,
      isAuthenticated: !!user,
      signIn,
      signUp,
      signOut,
    }),
    [user, isLoading]  // Only recreate when these change
  )
  
  return (
    <AuthContext.Provider value={value}>
      {children}
    </AuthContext.Provider>
  )
}
```

**Solution 2: Split contexts by concern**

```tsx
// ‚ùå One big context (theme and auth unrelated)
const AppContext = createContext({ user, theme, ... })

// ‚úÖ Separate contexts
const AuthContext = createContext({ user, ... })
const ThemeContext = createContext({ theme, ... })

// Now components only re-render for relevant changes
function UserMenu() {
  const { user } = useAuth()  // Only re-renders when auth changes
  return <div>{user?.name}</div>
}

function ThemeSwitcher() {
  const { theme, setTheme } = useTheme()  // Only re-renders when theme changes
  return <button onClick={() => setTheme('light')}>Toggle</button>
}
```

---

## Multiple Contexts: Composition Pattern

**Problem**: App needs multiple contexts (auth, theme, notifications, etc.)

**Solution**: Compose Providers

```tsx
// src/App.tsx

import { AuthProvider } from '@/contexts/AuthContext'
import { ThemeProvider } from '@/contexts/ThemeContext'
import { NotificationProvider } from '@/contexts/NotificationContext'

function App() {
  return (
    <AuthProvider>
      <ThemeProvider>
        <NotificationProvider>
          <BrowserRouter>
            <Routes>{/* ... */}</Routes>
          </BrowserRouter>
        </NotificationProvider>
      </ThemeProvider>
    </AuthProvider>
  )
}
```

**Better: AppProviders component**

```tsx
// src/providers/AppProviders.tsx

export function AppProviders({ children }: { children: ReactNode }) {
  return (
    <AuthProvider>
      <ThemeProvider>
        <NotificationProvider>
          {children}
        </NotificationProvider>
      </ThemeProvider>
    </AuthProvider>
  )
}

// src/App.tsx
function App() {
  return (
    <AppProviders>
      <BrowserRouter>
        <Routes>{/* ... */}</Routes>
      </BrowserRouter>
    </AppProviders>
  )
}
```

---

## When to Use Context

‚úÖ **Use Context when:**
- Data needed in many components at different nesting levels
- Prop drilling becomes painful (>3 levels)
- Data changes infrequently (authentication, theme, locale)
- You want cleaner component interfaces

**Examples in our forum:**
- ‚úÖ Authentication (used everywhere)
- ‚úÖ Theme (dark/light mode)
- ‚úÖ Locale (i18n)
- ‚úÖ Notifications (toast system)

‚ùå **Don't use Context when:**
- Data is only used in one place
- Data changes very frequently (causes many re-renders)
- You need time-travel debugging (use Redux/Zustand)
- State management is complex (use state management library)

**Examples in our forum:**
- ‚ùå Form state (use React Hook Form)
- ‚ùå List filters (pass as props or URL params)
- ‚ùå Modal open/closed (component-level state)
- ‚ùå Hover state (component-level state)

---

## Context vs Other Solutions

| Solution | When to Use | Pros | Cons |
|----------|-------------|------|------|
| **Props** | 1-2 levels down | Simple, explicit | Prop drilling |
| **Context** | Many levels, infrequent changes | No drilling, clean | Can cause re-renders |
| **Zustand/Redux** | Complex state, frequent changes | Time-travel, middleware | More boilerplate |
| **React Query** | Server state | Caching, auto-refetch | Only for server data |
| **URL State** | Shareable state | Bookmarkable, SSR-friendly | Only for serializable data |

**Our forum uses:**
- Props: Parent ‚Üí child (category ‚Üí card)
- Context: Auth, theme
- React Query: API data (threads, posts)
- URL State: Filters, search, pagination

---

## Testing Context

```tsx
// src/contexts/__tests__/AuthContext.test.tsx

import { render, screen, waitFor } from '@testing-library/react'
import userEvent from '@testing-library/user-event'
import { AuthProvider, useAuth } from '../AuthContext'
import { apiClient } from '@/lib/api-client'

vi.mock('@/lib/api-client')

// Test component that uses context
function TestComponent() {
  const { user, signIn, signOut } = useAuth()
  
  return (
    <div>
      {user ? (
        <>
          <p>Logged in as: {user.username}</p>
          <button onClick={signOut}>Sign Out</button>
        </>
      ) : (
        <>
          <p>Not logged in</p>
          <button onClick={() => signIn('test@example.com', 'password')}>
            Sign In
          </button>
        </>
      )}
    </div>
  )
}

describe('AuthContext', () => {
  it('provides authentication state', async () => {
    const user = userEvent.setup()
    
    vi.mocked(apiClient.post).mockResolvedValueOnce({
      data: {
        token: 'fake-token',
        user: { id: '1', username: 'alice', email: 'alice@test.com' },
      },
    })
    
    render(
      <AuthProvider>
        <TestComponent />
      </AuthProvider>
    )
    
    // Initially not logged in
    expect(screen.getByText('Not logged in')).toBeInTheDocument()
    
    // Sign in
    await user.click(screen.getByText('Sign In'))
    
    // Should be logged in
    await waitFor(() => {
      expect(screen.getByText('Logged in as: alice')).toBeInTheDocument()
    })
    
    // Sign out
    await user.click(screen.getByText('Sign Out'))
    
    // Should be logged out
    expect(screen.getByText('Not logged in')).toBeInTheDocument()
  })
  
  it('throws error when useAuth used outside Provider', () => {
    // Suppress console.error for this test
    const spy = vi.spyOn(console, 'error').mockImplementation(() => {})
    
    expect(() => {
      render(<TestComponent />)  // No Provider!
    }).toThrow('useAuth must be used within AuthProvider')
    
    spy.mockRestore()
  })
})
```

---

## Summary: Context API Patterns

### Key Concepts

1. **Context solves prop drilling**
   ```tsx
   // Before: <A user={u}> ‚Üí <B user={u}> ‚Üí <C user={u}>
   // After: <C> uses useAuth() directly
   ```

2. **Three pieces required**
   - `createContext`: Create the channel
   - `Provider`: Broadcast data
   - `useContext`: Receive data

3. **Custom hook pattern**
   ```tsx
   export function useAuth() {
     const context = useContext(AuthContext)
     if (!context) throw new Error('...')
     return context
   }
   ```

4. **Optimize with useMemo**
   ```tsx
   const value = useMemo(() => ({ user, signIn, signOut }), [user])
   ```

5. **Split contexts by concern**
   - AuthContext: Authentication
   - ThemeContext: UI theme
   - NotificationContext: Toasts

### Best Practices

- ‚úÖ Use Context for global, infrequently-changing data
- ‚úÖ Create custom hooks for type safety
- ‚úÖ Memoize Provider value to prevent re-renders
- ‚úÖ Split contexts by concern
- ‚úÖ Test context providers
- ‚ùå Don't use Context for frequently-changing data
- ‚ùå Don't put unrelated data in one context
- ‚ùå Don't forget to wrap app in Provider

---

Next: [Protected Routes ‚Üí](/en/react/7.auth-module/3.protected-routes)
