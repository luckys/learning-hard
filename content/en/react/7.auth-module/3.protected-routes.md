---
title: Protected Routes - RBAC, Guards & Security
description: Master route protection with role-based access control, permission systems, token refresh, and production-ready security patterns. Build secure, scalable authorization.
---

# Disclaimer

:::u-alert
---
title: Comments in the code are for educational purposes only.
description: In real projects, avoid adding irrelevant or redundant comments.
color: warning
variant: subtle
icon: i-lucide-triangle-alert
---
:::

Not all routes are public. Some require authentication, others require specific roles or permissions. Protected routes are the gatekeepers of your application, ensuring users only access what they're authorized to see.

---

## Authentication vs Authorization

### Key Differences

**Authentication (AuthN)**: *Who are you?*
- Verifies identity
- Login with credentials
- JWT tokens
- Session management

**Authorization (AuthZ)**: *What can you do?*
- Verifies permissions
- Role-based access
- Permission checks
- Resource ownership

### Visual Comparison

```
Authentication Flow:
User → Credentials → Verify → Token → Authenticated ✅

Authorization Flow:
Authenticated User → Check Role → Check Permission → Access Resource ✅
                                                   → Deny Access ❌
```

### Example

```tsx
// Authentication: Is user logged in?
if (!isAuthenticated) {
  return <Navigate to="/sign-in" />
}

// Authorization: Does user have permission?
if (user.role !== 'admin') {
  return <Navigate to="/forbidden" />
}
```

---

## Basic Protected Route

### Simple Implementation

```tsx
// src/components/auth/ProtectedRoute.tsx

import { Navigate, useLocation } from 'react-router-dom'
import { useAuth } from '@/contexts/AuthContext'

interface ProtectedRouteProps {
  children: React.ReactNode
}

export function ProtectedRoute({ children }: ProtectedRouteProps) {
  const { user, isLoading, isAuthenticated } = useAuth()
  const location = useLocation()

  /**
   * Show loading state while checking auth
   */
  if (isLoading) {
    return (
      <div className="min-h-screen flex items-center justify-center">
        <div className="animate-spin rounded-full h-12 w-12 border-b-2 border-blue-500" />
      </div>
    )
  }

  /**
   * Redirect to sign-in if not authenticated
   * Save current location to redirect back after login
   */
  if (!isAuthenticated) {
    return <Navigate to="/sign-in" state={{ from: location }} replace />
  }

  /**
   * User is authenticated, render children
   */
  return <>{children}</>
}
```

### Usage

```tsx
// src/App.tsx

<Routes>
  {/* Public routes */}
  <Route path="/" element={<HomePage />} />
  <Route path="/sign-in" element={<SignInPage />} />

  {/* Protected routes */}
  <Route
    path="/threads/new"
    element={
      <ProtectedRoute>
        <CreateThreadPage />
      </ProtectedRoute>
    }
  />

  <Route
    path="/profile"
    element={
      <ProtectedRoute>
        <ProfilePage />
      </ProtectedRoute>
    }
  />
</Routes>
```

---

## Role-Based Access Control (RBAC)

### Role Hierarchy

```
Admin (highest)
├─ Can do everything
├─ Manage users
├─ Moderate content
└─ Access admin panel

Moderator
├─ Moderate content
├─ Ban users
└─ Delete posts

User (lowest)
├─ Create threads
├─ Create posts
└─ Edit own content
```

### Role-Based Protected Route

```tsx
// src/components/auth/ProtectedRoute.tsx

import { Navigate, useLocation } from 'react-router-dom'
import { useAuth } from '@/contexts/AuthContext'

type UserRole = 'user' | 'moderator' | 'admin'

interface ProtectedRouteProps {
  children: React.ReactNode
  requiredRole?: UserRole
  requiredPermissions?: string[]
}

export function ProtectedRoute({
  children,
  requiredRole,
  requiredPermissions = [],
}: ProtectedRouteProps) {
  const { user, isLoading, isAuthenticated } = useAuth()
  const location = useLocation()

  if (isLoading) {
    return <LoadingScreen />
  }

  if (!isAuthenticated) {
    return <Navigate to="/sign-in" state={{ from: location }} replace />
  }

  /**
   * Check role requirement
   * Admin has access to everything
   */
  if (requiredRole && !hasRole(user, requiredRole)) {
    return (
      <div className="min-h-screen flex items-center justify-center">
        <div className="text-center">
          <h1 className="text-4xl font-bold text-slate-100 mb-4">403</h1>
          <p className="text-slate-400 mb-6">
            You don't have permission to access this page
          </p>
          <Link
            to="/"
            className="px-4 py-2 bg-blue-600 text-white rounded-lg hover:bg-blue-700"
          >
            Go Home
          </Link>
        </div>
      </div>
    )
  }

  /**
   * Check permissions
   */
  if (requiredPermissions.length > 0 && !hasPermissions(user, requiredPermissions)) {
    return <Navigate to="/forbidden" replace />
  }

  return <>{children}</>
}

/**
 * Check if user has required role
 */
function hasRole(user: User | null, requiredRole: UserRole): boolean {
  if (!user) return false
  
  // Admin has access to everything
  if (user.role === 'admin') return true
  
  // Exact role match
  if (user.role === requiredRole) return true
  
  // Moderator has access to user routes
  if (requiredRole === 'user' && user.role === 'moderator') return true
  
  return false
}

/**
 * Check if user has all required permissions
 */
function hasPermissions(user: User | null, requiredPermissions: string[]): boolean {
  if (!user || !user.permissions) return false
  
  return requiredPermissions.every(permission =>
    user.permissions.includes(permission)
  )
}
```

### Usage with Roles

```tsx
<Routes>
  {/* User routes */}
  <Route
    path="/threads/new"
    element={
      <ProtectedRoute requiredRole="user">
        <CreateThreadPage />
      </ProtectedRoute>
    }
  />

  {/* Moderator routes */}
  <Route
    path="/moderation"
    element={
      <ProtectedRoute requiredRole="moderator">
        <ModerationQueue />
      </ProtectedRoute>
    }
  />

  {/* Admin routes */}
  <Route
    path="/admin"
    element={
      <ProtectedRoute requiredRole="admin">
        <AdminDashboard />
      </ProtectedRoute>
    }
  />
</Routes>
```

---

## Permission-Based Access Control

### Permission System

```typescript
// src/types/permissions.ts

export const PERMISSIONS = {
  // Thread permissions
  THREAD_CREATE: 'thread:create',
  THREAD_EDIT_OWN: 'thread:edit:own',
  THREAD_EDIT_ANY: 'thread:edit:any',
  THREAD_DELETE_OWN: 'thread:delete:own',
  THREAD_DELETE_ANY: 'thread:delete:any',
  
  // Post permissions
  POST_CREATE: 'post:create',
  POST_EDIT_OWN: 'post:edit:own',
  POST_EDIT_ANY: 'post:edit:any',
  POST_DELETE_OWN: 'post:delete:own',
  POST_DELETE_ANY: 'post:delete:any',
  
  // User permissions
  USER_BAN: 'user:ban',
  USER_EDIT: 'user:edit',
  USER_DELETE: 'user:delete',
  
  // Admin permissions
  ADMIN_ACCESS: 'admin:access',
  ADMIN_SETTINGS: 'admin:settings',
} as const

export type Permission = typeof PERMISSIONS[keyof typeof PERMISSIONS]

/**
 * Role → Permissions mapping
 */
export const ROLE_PERMISSIONS: Record<UserRole, Permission[]> = {
  user: [
    PERMISSIONS.THREAD_CREATE,
    PERMISSIONS.THREAD_EDIT_OWN,
    PERMISSIONS.THREAD_DELETE_OWN,
    PERMISSIONS.POST_CREATE,
    PERMISSIONS.POST_EDIT_OWN,
    PERMISSIONS.POST_DELETE_OWN,
  ],
  moderator: [
    // All user permissions
    ...ROLE_PERMISSIONS.user,
    // Plus moderator permissions
    PERMISSIONS.THREAD_EDIT_ANY,
    PERMISSIONS.THREAD_DELETE_ANY,
    PERMISSIONS.POST_EDIT_ANY,
    PERMISSIONS.POST_DELETE_ANY,
    PERMISSIONS.USER_BAN,
  ],
  admin: [
    // All moderator permissions
    ...ROLE_PERMISSIONS.moderator,
    // Plus admin permissions
    PERMISSIONS.USER_EDIT,
    PERMISSIONS.USER_DELETE,
    PERMISSIONS.ADMIN_ACCESS,
    PERMISSIONS.ADMIN_SETTINGS,
  ],
}
```

### Permission Hook

```tsx
// src/hooks/usePermissions.ts

import { useAuth } from '@/contexts/AuthContext'
import { ROLE_PERMISSIONS, Permission } from '@/types/permissions'

export function usePermissions() {
  const { user } = useAuth()

  /**
   * Check if user has specific permission
   */
  const hasPermission = (permission: Permission): boolean => {
    if (!user) return false
    
    const userPermissions = ROLE_PERMISSIONS[user.role] || []
    return userPermissions.includes(permission)
  }

  /**
   * Check if user has all permissions
   */
  const hasAllPermissions = (permissions: Permission[]): boolean => {
    return permissions.every(permission => hasPermission(permission))
  }

  /**
   * Check if user has any permission
   */
  const hasAnyPermission = (permissions: Permission[]): boolean => {
    return permissions.some(permission => hasPermission(permission))
  }

  /**
   * Check if user can edit resource
   */
  const canEdit = (resource: { authorId: string }, editAnyPermission: Permission, editOwnPermission: Permission): boolean => {
    // Can edit any
    if (hasPermission(editAnyPermission)) return true
    
    // Can edit own
    if (hasPermission(editOwnPermission) && resource.authorId === user?.id) return true
    
    return false
  }

  return {
    hasPermission,
    hasAllPermissions,
    hasAnyPermission,
    canEdit,
  }
}
```

### Usage with Permissions

```tsx
// src/pages/ThreadDetailPage.tsx

import { usePermissions } from '@/hooks/usePermissions'
import { PERMISSIONS } from '@/types/permissions'

export function ThreadDetailPage() {
  const { thread } = useThread()
  const { hasPermission, canEdit } = usePermissions()

  const canEditThread = canEdit(
    thread,
    PERMISSIONS.THREAD_EDIT_ANY,
    PERMISSIONS.THREAD_EDIT_OWN
  )

  const canDeleteThread = canEdit(
    thread,
    PERMISSIONS.THREAD_DELETE_ANY,
    PERMISSIONS.THREAD_DELETE_OWN
  )

  return (
    <div>
      <h1>{thread.title}</h1>
      
      {canEditThread && (
        <button onClick={handleEdit}>Edit</button>
      )}
      
      {canDeleteThread && (
        <button onClick={handleDelete}>Delete</button>
      )}
    </div>
  )
}
```

---

## Token Refresh & Expiration

### Automatic Token Refresh

```tsx
// src/contexts/AuthContext.tsx

import { createContext, useContext, useEffect, useRef } from 'react'
import { jwtDecode } from 'jwt-decode'

export function AuthProvider({ children }: { children: React.ReactNode }) {
  const [user, setUser] = useState<User | null>(null)
  const [token, setToken] = useState<string | null>(null)
  const refreshTimeoutRef = useRef<NodeJS.Timeout>()

  /**
   * Schedule token refresh before expiration
   */
  const scheduleTokenRefresh = useCallback((token: string) => {
    try {
      const decoded = jwtDecode<{ exp: number }>(token)
      const expiresAt = decoded.exp * 1000 // Convert to milliseconds
      const now = Date.now()
      const timeUntilExpiry = expiresAt - now
      
      // Refresh 5 minutes before expiration
      const refreshTime = timeUntilExpiry - 5 * 60 * 1000
      
      if (refreshTime > 0) {
        refreshTimeoutRef.current = setTimeout(async () => {
          await refreshToken()
        }, refreshTime)
      }
    } catch (error) {
      console.error('Failed to schedule token refresh:', error)
    }
  }, [])

  /**
   * Refresh access token
   */
  const refreshToken = async () => {
    try {
      const response = await fetch('/api/auth/refresh', {
        method: 'POST',
        credentials: 'include', // Send refresh token cookie
      })

      if (!response.ok) {
        throw new Error('Token refresh failed')
      }

      const data = await response.json()
      
      setToken(data.accessToken)
      localStorage.setItem('token', data.accessToken)
      
      // Schedule next refresh
      scheduleTokenRefresh(data.accessToken)
    } catch (error) {
      console.error('Token refresh error:', error)
      // Logout user if refresh fails
      logout()
    }
  }

  /**
   * Initialize token refresh on mount
   */
  useEffect(() => {
    const storedToken = localStorage.getItem('token')
    if (storedToken) {
      setToken(storedToken)
      scheduleTokenRefresh(storedToken)
    }

    return () => {
      if (refreshTimeoutRef.current) {
        clearTimeout(refreshTimeoutRef.current)
      }
    }
  }, [scheduleTokenRefresh])

  return (
    <AuthContext.Provider value={{ user, token, refreshToken }}>
      {children}
    </AuthContext.Provider>
  )
}
```

### Axios Interceptor for Token Refresh

```typescript
// src/lib/api-client.ts

import axios from 'axios'

const apiClient = axios.create({
  baseURL: '/api',
})

// Request interceptor: Add token to headers
apiClient.interceptors.request.use(
  (config) => {
    const token = localStorage.getItem('token')
    if (token) {
      config.headers.Authorization = `Bearer ${token}`
    }
    return config
  },
  (error) => Promise.reject(error)
)

// Response interceptor: Handle token expiration
apiClient.interceptors.response.use(
  (response) => response,
  async (error) => {
    const originalRequest = error.config

    // Token expired
    if (error.response?.status === 401 && !originalRequest._retry) {
      originalRequest._retry = true

      try {
        // Refresh token
        const response = await axios.post('/api/auth/refresh', {}, {
          withCredentials: true,
        })

        const { accessToken } = response.data
        
        // Save new token
        localStorage.setItem('token', accessToken)
        
        // Retry original request with new token
        originalRequest.headers.Authorization = `Bearer ${accessToken}`
        return apiClient(originalRequest)
      } catch (refreshError) {
        // Refresh failed, logout user
        localStorage.removeItem('token')
        window.location.href = '/sign-in'
        return Promise.reject(refreshError)
      }
    }

    return Promise.reject(error)
  }
)

export default apiClient
```

---

## Redirect Flows

### Remember Intended Location

```tsx
// src/pages/SignInPage.tsx

import { useNavigate, useLocation } from 'react-router-dom'

export function SignInPage() {
  const navigate = useNavigate()
  const location = useLocation()
  
  // Get intended location from state
  const from = location.state?.from?.pathname || '/'

  const handleSignIn = async (credentials: Credentials) => {
    try {
      await signIn(credentials)
      
      // Redirect to intended location
      navigate(from, { replace: true })
    } catch (error) {
      // Handle error
    }
  }

  return (
    <form onSubmit={handleSignIn}>
      {/* Form fields */}
    </form>
  )
}
```

### Deep Linking

```tsx
// src/components/auth/ProtectedRoute.tsx

export function ProtectedRoute({ children }: ProtectedRouteProps) {
  const { isAuthenticated } = useAuth()
  const location = useLocation()

  if (!isAuthenticated) {
    // Save full URL including search params and hash
    const intendedUrl = `${location.pathname}${location.search}${location.hash}`
    
    return (
      <Navigate
        to="/sign-in"
        state={{ from: intendedUrl }}
        replace
      />
    )
  }

  return <>{children}</>
}
```

---

## Loading States & UX

### Skeleton Screen

```tsx
// src/components/auth/ProtectedRoute.tsx

function LoadingScreen() {
  return (
    <div className="min-h-screen bg-slate-950 p-8">
      <div className="max-w-4xl mx-auto">
        {/* Navbar skeleton */}
        <div className="h-16 bg-slate-900 rounded-lg mb-8 animate-pulse" />
        
        {/* Content skeleton */}
        <div className="space-y-4">
          <div className="h-32 bg-slate-900 rounded-lg animate-pulse" />
          <div className="h-48 bg-slate-900 rounded-lg animate-pulse" />
          <div className="h-24 bg-slate-900 rounded-lg animate-pulse" />
        </div>
      </div>
    </div>
  )
}
```

### Progressive Loading

```tsx
export function ProtectedRoute({ children }: ProtectedRouteProps) {
  const { user, isLoading, isAuthenticated } = useAuth()
  const [showContent, setShowContent] = useState(false)

  useEffect(() => {
    if (!isLoading && isAuthenticated) {
      // Delay content reveal for smooth transition
      const timer = setTimeout(() => setShowContent(true), 100)
      return () => clearTimeout(timer)
    }
  }, [isLoading, isAuthenticated])

  if (isLoading) {
    return <LoadingScreen />
  }

  if (!isAuthenticated) {
    return <Navigate to="/sign-in" replace />
  }

  return (
    <div className={`transition-opacity duration-300 ${showContent ? 'opacity-100' : 'opacity-0'}`}>
      {children}
    </div>
  )
}
```

---

## Testing Protected Routes

### Unit Tests

```tsx
// src/components/auth/__tests__/ProtectedRoute.test.tsx

import { render, screen } from '@testing-library/react'
import { BrowserRouter } from 'react-router-dom'
import { ProtectedRoute } from '../ProtectedRoute'
import { AuthContext } from '@/contexts/AuthContext'

describe('ProtectedRoute', () => {
  it('shows loading state while checking auth', () => {
    const mockAuthValue = {
      user: null,
      isLoading: true,
      isAuthenticated: false,
    }

    render(
      <BrowserRouter>
        <AuthContext.Provider value={mockAuthValue}>
          <ProtectedRoute>
            <div>Protected Content</div>
          </ProtectedRoute>
        </AuthContext.Provider>
      </BrowserRouter>
    )

    expect(screen.getByRole('status')).toBeInTheDocument()
  })

  it('redirects to sign-in when not authenticated', () => {
    const mockAuthValue = {
      user: null,
      isLoading: false,
      isAuthenticated: false,
    }

    render(
      <BrowserRouter>
        <AuthContext.Provider value={mockAuthValue}>
          <ProtectedRoute>
            <div>Protected Content</div>
          </ProtectedRoute>
        </AuthContext.Provider>
      </BrowserRouter>
    )

    expect(window.location.pathname).toBe('/sign-in')
  })

  it('renders children when authenticated', () => {
    const mockAuthValue = {
      user: { id: '1', role: 'user' },
      isLoading: false,
      isAuthenticated: true,
    }

    render(
      <BrowserRouter>
        <AuthContext.Provider value={mockAuthValue}>
          <ProtectedRoute>
            <div>Protected Content</div>
          </ProtectedRoute>
        </AuthContext.Provider>
      </BrowserRouter>
    )

    expect(screen.getByText('Protected Content')).toBeInTheDocument()
  })

  it('blocks access when user lacks required role', () => {
    const mockAuthValue = {
      user: { id: '1', role: 'user' },
      isLoading: false,
      isAuthenticated: true,
    }

    render(
      <BrowserRouter>
        <AuthContext.Provider value={mockAuthValue}>
          <ProtectedRoute requiredRole="admin">
            <div>Admin Content</div>
          </ProtectedRoute>
        </AuthContext.Provider>
      </BrowserRouter>
    )

    expect(screen.queryByText('Admin Content')).not.toBeInTheDocument()
    expect(screen.getByText(/don't have permission/i)).toBeInTheDocument()
  })
})
```

---

## Best Practices

### ✅ DO

- ✅ Always check authentication on the server
- ✅ Use token refresh to avoid re-login
- ✅ Show loading states during auth checks
- ✅ Remember intended location for post-login redirect
- ✅ Implement proper RBAC with clear role hierarchy
- ✅ Use permissions for fine-grained access control
- ✅ Test protected routes thoroughly

### ❌ DON'T

- ❌ Trust client-side checks alone
- ❌ Store sensitive data in localStorage
- ❌ Forget to handle token expiration
- ❌ Show protected content before auth check completes
- ❌ Use overly complex permission systems
- ❌ Forget to clean up timers and subscriptions

---

## Summary

### Key Concepts

1. **Authentication**: Verify identity (who you are)
2. **Authorization**: Verify permissions (what you can do)
3. **RBAC**: Role-based access control (admin, moderator, user)
4. **Permissions**: Fine-grained access control
5. **Token Refresh**: Automatic token renewal
6. **Redirect Flows**: Remember intended location

### Security Checklist

- ✅ Server-side validation
- ✅ Token expiration handling
- ✅ Automatic token refresh
- ✅ Role hierarchy
- ✅ Permission system
- ✅ Loading states
- ✅ Error handling
- ✅ Test coverage

---

Next: [User Profile →](/en/react/7.auth-module/4.user-profile)
