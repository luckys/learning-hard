---
title: Delete Category - Destructive Operations & Portals  
description: Master React Portals for modals, confirmation dialogs, cascade warnings, keyboard accessibility, and safe deletion patterns. Learn how to handle destructive operations responsibly with rollback capabilities.
---

# Disclaimer

:::u-alert
---
title: Comments in the code are for educational purposes only.
description: In real projects, avoid adding irrelevant or redundant comments.
color: warning
variant: subtle
icon: i-lucide-triangle-alert
---
:::

Deleting is the most **dangerous operation** in any application. Unlike edits (which can be reverted), deletion is permanent. We need multiple safety layers: confirmation dialogs, cascade warnings, authorization checks, and rollback capabilities.

**Why deletion is special:**
- ❌ **Irreversible**: No undo button
- ❌ **Cascading effects**: May delete related data
- ❌ **User error prone**: Easy to click wrong button
- ❌ **Security critical**: Must check permissions

**Our safety layers:**
1. **Authorization**: Only admins can delete
2. **Confirmation modal**: Double-check user intent
3. **Cascade warning**: Show what else will be deleted
4. **Loading state**: Prevent double-clicks
5. **Error handling**: Clear messages and rollback
6. **Optimistic UI**: Instant feedback with rollback on failure

---

## The Challenge: Modals and the DOM Tree

Before building the delete functionality, we need to understand a fundamental problem: **where to render modals in the DOM tree**.

### Understanding the DOM Tree

The DOM (Document Object Model) is a tree structure:

```
<html>
  <body>
    <div id="root">
      <App>
        <Navbar />
        <CategoryPage>
          <CategoryCard>
            <DeleteButton />
            <Modal />  ← Where should this render?
          </CategoryCard>
        </CategoryPage>
      </App>
    </div>
  </body>
</html>
```

**Problem**: If `<Modal />` renders inside `<CategoryCard>`, it inherits all parent styles and constraints.

### CSS Stacking Context: The Root Cause

**Stacking context** determines which elements appear on top of others. It's created by:
- `position: relative/absolute/fixed` with `z-index`
- `transform`, `filter`, `opacity < 1`
- `overflow: hidden`

**Example problem:**

```tsx
<div style={{ position: 'relative', overflow: 'hidden', zIndex: 1 }}>
  <CategoryCard />
  <Modal style={{ zIndex: 9999 }} />  {/* Still gets clipped! */}
</div>
```

**Why it fails:**
- Modal is inside a parent with `overflow: hidden`
- Modal gets clipped by parent boundaries
- `z-index` only works within the same stacking context
- Modal can't escape parent's stacking context

**Visual:**
```
┌─────────────────────────────────┐
│ Parent (overflow: hidden)       │
│  ┌──────────────┐              │
│  │ CategoryCard │              │
│  └──────────────┘              │
│  ┌────────────────────┐        │ ← Modal gets clipped!
│  │ Modal              │        │
│  │ (wants to be full  │        │
│  └────────────────────┘        │
└─────────────────────────────────┘
```

### The Solution: React Portals

**Portals** let us render components **outside the parent DOM hierarchy**, breaking free from stacking context constraints.

```
<html>
  <body>
    <div id="root">
      <App>
        <CategoryCard>
          <DeleteButton />  ← Button triggers modal
        </CategoryCard>
      </App>
    </div>
    
    <!-- Modal renders here via portal -->
    <div class="modal-overlay">
      <Modal />  ← Rendered at body level!
    </div>
  </body>
</html>
```

**Benefits:**
- ✅ Modal always appears on top
- ✅ No stacking context issues
- ✅ Full viewport control
- ✅ Proper z-index behavior
- ✅ No parent style inheritance

---

## React Portals: createPortal API

```tsx
import { createPortal } from 'react-dom'

/**
 * createPortal(children, container, key?)
 * 
 * Arguments:
 * 1. children: React element to render
 * 2. container: DOM node to render into
 * 3. key?: Optional key for React reconciliation
 * 
 * Returns: React portal
 */
const modal = createPortal(
  <div>Modal content</div>,
  document.body
)
```

**Key behavior:**
- Event bubbling still follows React tree (not DOM tree)
- Context works normally
- Refs work normally
- Just the rendering location changes

---

## Confirmation Modal Implementation

```tsx
// src/components/ui/ConfirmModal.tsx

import { createPortal } from 'react-dom'
import { useEffect } from 'react'

interface ConfirmModalProps {
  isOpen: boolean
  onClose: () => void
  onConfirm: () => void
  title: string
  message: string
  confirmText?: string
  cancelText?: string
  variant?: 'danger' | 'warning'
}

/**
 * Confirmation modal using React Portal
 * 
 * Portal: Render component in different DOM location
 * Useful for modals, tooltips, dropdowns
 */
export function ConfirmModal({
  isOpen,
  onClose,
  onConfirm,
  title,
  message,
  confirmText = 'Confirm',
  cancelText = 'Cancel',
  variant = 'danger',
}: ConfirmModalProps) {
  /**
   * Close modal on Escape key
   */
  useEffect(() => {
    const handleEscape = (e: KeyboardEvent) => {
      if (e.key === 'Escape') {
        onClose()
      }
    }

    if (isOpen) {
      document.addEventListener('keydown', handleEscape)
      // Prevent body scroll when modal is open
      document.body.style.overflow = 'hidden'
    }

    return () => {
      document.removeEventListener('keydown', handleEscape)
      document.body.style.overflow = 'unset'
    }
  }, [isOpen, onClose])

  if (!isOpen) return null

  /**
   * createPortal renders modal at document.body level
   * 
   * This breaks free from:
   * - Parent overflow constraints
   * - Parent stacking contexts  
   * - Parent transform/filter/clip-path
   * 
   * But maintains:
   * - React event bubbling
   * - Context access
   * - Ref access
   */
  return createPortal(
    <>
      {/* Backdrop */}
      <div
        className="fixed inset-0 bg-black/50 z-40"
        onClick={onClose}
        aria-hidden="true"
      />

      {/* Modal */}
      <div className="fixed inset-0 z-50 flex items-center justify-center p-4">
        <div
          className="bg-slate-900 rounded-lg border border-slate-800 shadow-xl max-w-md w-full"
          role="dialog"
          aria-modal="true"
          aria-labelledby="modal-title"
        >
          {/* Header */}
          <div className="p-6 pb-4">
            <h2
              id="modal-title"
              className="text-xl font-bold text-slate-100"
            >
              {title}
            </h2>
          </div>

          {/* Content */}
          <div className="px-6 pb-6">
            <p className="text-slate-300">{message}</p>
          </div>

          {/* Actions */}
          <div className="flex gap-3 px-6 pb-6">
            <button
              type="button"
              onClick={onClose}
              className="flex-1 px-4 py-2 bg-slate-800 text-slate-200 rounded-md hover:bg-slate-700"
            >
              {cancelText}
            </button>
            <button
              type="button"
              onClick={onConfirm}
              className={`flex-1 px-4 py-2 rounded-md ${
                variant === 'danger'
                  ? 'bg-red-600 text-white hover:bg-red-700'
                  : 'bg-yellow-600 text-white hover:bg-yellow-700'
              }`}
            >
              {confirmText}
            </button>
          </div>
        </div>
      </div>
    </>,
    document.body  // Render at body level
  )
}
```

### Why Portals?

**Problem without portal:**
```tsx
<div style={{ overflow: 'hidden', position: 'relative' }}>
  <Modal />  {/* Modal gets clipped by parent! */}
</div>
```

**Solution with portal:**
```tsx
createPortal(<Modal />, document.body)
// Modal renders at body level, ignores parent constraints
```

---

## Delete Button with Modal

```tsx
// src/features/categories/components/DeleteCategoryButton.tsx

import { useState } from 'react'
import { useNavigate } from 'react-router-dom'
import { ConfirmModal } from '@/components/ui/ConfirmModal'
import { apiClient } from '@/lib/api-client'
import { toast } from '@/lib/toast'
import type { Category } from '@/types'

interface DeleteCategoryButtonProps {
  category: Category
}

export function DeleteCategoryButton({ category }: DeleteCategoryButtonProps) {
  const navigate = useNavigate()
  const [showModal, setShowModal] = useState(false)
  const [isDeleting, setIsDeleting] = useState(false)

  const handleDelete = async () => {
    setIsDeleting(true)

    try {
      await apiClient.delete(`/categories/${category.id}`)
      
      toast.success('Category deleted successfully')
      
      // Navigate away from deleted category
      navigate('/categories')
    } catch (error) {
      toast.error(error instanceof Error ? error.message : 'Failed to delete category')
    } finally {
      setIsDeleting(false)
      setShowModal(false)
    }
  }

  return (
    <>
      <button
        type="button"
        onClick={() => setShowModal(true)}
        className="px-4 py-2 bg-red-600 text-white rounded-md hover:bg-red-700"
      >
        Delete Category
      </button>

      <ConfirmModal
        isOpen={showModal}
        onClose={() => setShowModal(false)}
        onConfirm={handleDelete}
        title="Delete Category?"
        message={`Are you sure you want to delete "${category.name}"? This action cannot be undone.`}
        confirmText={isDeleting ? 'Deleting...' : 'Delete'}
        variant="danger"
      />
    </>
  )
}
```

---

## Cascade Warning

Check if category has threads before deleting.

```tsx
export function DeleteCategoryButton({ category }: DeleteCategoryButtonProps) {
  const navigate = useNavigate()
  const [showModal, setShowModal] = useState(false)
  const [isDeleting, setIsDeleting] = useState(false)

  /**
   * Get warning message based on thread count
   */
  const getWarningMessage = () => {
    if (category.threadCount === 0) {
      return `Are you sure you want to delete "${category.name}"?`
    }

    return `"${category.name}" has ${category.threadCount} thread(s). Deleting this category will also delete all threads. This action cannot be undone.`
  }

  const handleDelete = async () => {
    setIsDeleting(true)

    try {
      /**
       * API should handle cascade deletion:
       * 1. Delete all threads in category
       * 2. Delete all posts in those threads
       * 3. Delete category
       */
      await apiClient.delete(`/categories/${category.id}`)
      
      toast.success('Category and associated threads deleted')
      navigate('/categories')
    } catch (error) {
      toast.error(error instanceof Error ? error.message : 'Failed to delete category')
    } finally {
      setIsDeleting(false)
      setShowModal(false)
    }
  }

  return (
    <>
      <button
        type="button"
        onClick={() => setShowModal(true)}
        className="px-4 py-2 bg-red-600 text-white rounded-md hover:bg-red-700"
      >
        Delete Category
      </button>

      <ConfirmModal
        isOpen={showModal}
        onClose={() => setShowModal(false)}
        onConfirm={handleDelete}
        title="Delete Category?"
        message={getWarningMessage()}
        confirmText={isDeleting ? 'Deleting...' : 'Delete'}
        variant={category.threadCount > 0 ? 'danger' : 'warning'}
      />
    </>
  )
}
```

---

## Authorization Check

Only allow admins/moderators to delete categories.

```tsx
import { useAuth } from '@/features/auth/hooks/useAuth'

export function DeleteCategoryButton({ category }: DeleteCategoryButtonProps) {
  const { user } = useAuth()

  // Only show button to authorized users
  if (!user || (user.role !== 'admin' && user.role !== 'moderator')) {
    return null
  }

  // ... rest of component
}
```

---

## Optimistic Deletion

Remove from UI immediately for better UX.

```tsx
export function useCategoryDelete() {
  const queryClient = useQueryClient()

  return useMutation({
    mutationFn: async (categoryId: string) => {
      return apiClient.delete(`/categories/${categoryId}`)
    },

    /**
     * Optimistically remove from cache
     */
    onMutate: async (categoryId) => {
      // Cancel outgoing queries
      await queryClient.cancelQueries({ queryKey: ['categories'] })

      // Snapshot previous state
      const previous = queryClient.getQueryData<Category[]>(['categories'])

      // Remove category from cache
      if (previous) {
        queryClient.setQueryData<Category[]>(
          ['categories'],
          previous.filter((cat) => cat.id !== categoryId)
        )
      }

      return { previous }
    },

    /**
     * Rollback on error
     */
    onError: (err, variables, context) => {
      if (context?.previous) {
        queryClient.setQueryData(['categories'], context.previous)
      }
      toast.error('Failed to delete category')
    },

    onSuccess: () => {
      toast.success('Category deleted')
    },
  })
}
```

---

## Summary

### New Concepts
1. **React Portal**: Render component outside parent tree
   ```tsx
   createPortal(<Modal />, document.body)
   ```

2. **Modal Patterns**:
   - Backdrop prevents background clicks
   - Escape key closes modal
   - Prevent body scroll when open
   - Focus trap for accessibility

3. **Cascade Deletion**: Warn users about consequences

4. **Authorization**: Check user permissions before showing actions

### Best Practices
- ✅ Always confirm destructive actions
- ✅ Show clear warning messages
- ✅ Disable buttons during deletion
- ✅ Check authorization before showing delete button
- ✅ Handle cascade deletion properly
- ✅ Use optimistic updates for instant feedback

---

## Keyboard Accessibility

```tsx
export function ConfirmModal({ isOpen, onClose, onConfirm }) {
  const modalRef = useRef<HTMLDivElement>(null)
  const previousFocusRef = useRef<HTMLElement | null>(null)

  useEffect(() => {
    if (!isOpen) return

    // Save currently focused element
    previousFocusRef.current = document.activeElement as HTMLElement

    // Focus modal
    modalRef.current?.focus()

    // Trap focus inside modal
    const handleTab = (e: KeyboardEvent) => {
      if (e.key !== 'Tab') return

      const focusable = modalRef.current?.querySelectorAll(
        'button, [href], input, select, textarea, [tabindex]:not([tabindex="-1"])'
      )
      if (!focusable || focusable.length === 0) return

      const first = focusable[0] as HTMLElement
      const last = focusable[focusable.length - 1] as HTMLElement

      if (e.shiftKey && document.activeElement === first) {
        e.preventDefault()
        last.focus()
      } else if (!e.shiftKey && document.activeElement === last) {
        e.preventDefault()
        first.focus()
      }
    }

    document.addEventListener('keydown', handleTab)

    return () => {
      document.removeEventListener('keydown', handleTab)
      // Restore focus
      previousFocusRef.current?.focus()
    }
  }, [isOpen])

  // ... rest of component
}
```

---

## Complete Delete Flow

```tsx
// src/features/categories/components/DeleteCategoryButton.tsx

import { useState } from 'react'
import { useNavigate } from 'react-router-dom'
import { useMutation, useQueryClient } from '@tanstack/react-query'
import { ConfirmModal } from '@/components/ui/ConfirmModal'
import { apiClient } from '@/lib/api-client'
import { toast } from '@/lib/toast'
import { useAuth } from '@/features/auth/hooks/useAuth'
import type { Category } from '@/types'

interface DeleteCategoryButtonProps {
  category: Category
}

export function DeleteCategoryButton({ category }: DeleteCategoryButtonProps) {
  const { user } = useAuth()
  const navigate = useNavigate()
  const queryClient = useQueryClient()
  const [showModal, setShowModal] = useState(false)

  /**
   * Authorization check
   */
  const canDelete = user && ['admin', 'moderator'].includes(user.role)

  /**
   * Delete mutation with optimistic updates
   */
  const deleteMutation = useMutation({
    mutationFn: async () => {
      return apiClient.delete(`/categories/${category.id}`)
    },

    onMutate: async () => {
      // Cancel outgoing queries
      await queryClient.cancelQueries({ queryKey: ['categories'] })

      // Snapshot for rollback
      const previous = queryClient.getQueryData<Category[]>(['categories'])

      // Optimistically remove
      if (previous) {
        queryClient.setQueryData<Category[]>(
          ['categories'],
          previous.filter((c) => c.id !== category.id)
        )
      }

      return { previous }
    },

    onError: (err, variables, context) => {
      // Rollback
      if (context?.previous) {
        queryClient.setQueryData(['categories'], context.previous)
      }
      toast.error('Failed to delete category')
    },

    onSuccess: () => {
      toast.success(`"${category.name}" deleted successfully`)
      setShowModal(false)
      navigate('/categories')
    },
  })

  if (!canDelete) return null

  const warningMessage =
    category.threadCount === 0
      ? `Are you sure you want to delete "${category.name}"? This action cannot be undone.`
      : `Warning: "${category.name}" contains ${category.threadCount} thread(s). Deleting this category will permanently delete all threads and their posts. This action cannot be undone.`

  return (
    <>
      <button
        onClick={() => setShowModal(true)}
        className="px-4 py-2 bg-red-600 text-white rounded-lg hover:bg-red-700 font-medium transition-colors"
        aria-label={`Delete ${category.name}`}
      >
        Delete
      </button>

      <ConfirmModal
        isOpen={showModal}
        onClose={() => setShowModal(false)}
        onConfirm={() => deleteMutation.mutate()}
        title="Delete Category?"
        message={warningMessage}
        confirmText={deleteMutation.isPending ? 'Deleting...' : 'Delete'}
        cancelText="Cancel"
        variant={category.threadCount > 0 ? 'danger' : 'warning'}
        isLoading={deleteMutation.isPending}
      />
    </>
  )
}
```

---

## Testing Delete Flow

```tsx
import { render, screen, waitFor } from '@testing-library/react'
import userEvent from '@testing-library/user-event'
import { DeleteCategoryButton } from '../DeleteCategoryButton'
import { apiClient } from '@/lib/api-client'

vi.mock('@/lib/api-client')

describe('DeleteCategoryButton', () => {
  const mockCategory: Category = {
    id: '1',
    name: 'Test Category',
    slug: 'test',
    threadCount: 5,
  }

  it('shows confirmation modal with cascade warning', async () => {
    const user = userEvent.setup()

    render(<DeleteCategoryButton category={mockCategory} />)

    await user.click(screen.getByText('Delete'))

    expect(screen.getByText(/Warning.*contains 5 thread/)).toBeInTheDocument()
  })

  it('calls API and removes optimistically', async () => {
    const user = userEvent.setup()
    vi.mocked(apiClient.delete).mockResolvedValueOnce({})

    render(<DeleteCategoryButton category={mockCategory} />)

    await user.click(screen.getByText('Delete'))
    await user.click(screen.getByText('Delete', { selector: 'button[type="button"]' }))

    await waitFor(() => {
      expect(apiClient.delete).toHaveBeenCalledWith('/categories/1')
    })
  })
})
```

---

## Summary

### Key Concepts Mastered

1. **React Portals**: Render outside DOM hierarchy
   - `createPortal(children, container)`
   - Breaks CSS constraints, maintains React behavior

2. **CSS Stacking Context**: Why portals matter
   - Created by position, transform, overflow, etc.
   - z-index only works within same context

3. **Keyboard Accessibility**:
   - Focus trap (Tab cycling)
   - ESC to close
   - Focus restoration
   - ARIA roles

4. **Optimistic Updates**: Better UX
   - Update UI immediately
   - Rollback on error
   - Show loading states

5. **Cascade Warnings**: User safety
   - Show impact of deletion
   - Clear messaging
   - Confirmation required

### Best Practices

- ✅ Always use portals for modals
- ✅ Implement focus trap
- ✅ Restore focus on close
- ✅ Check authorization before showing delete
- ✅ Warn about cascade effects
- ✅ Optimistic updates with rollback
- ✅ Loading states prevent double-clicks
- ✅ Test delete flows thoroughly

---

Next: [Nested Categories →](/en/react/4.categories-module/5.nested-categories)
