---
title: Nested Categories
description: Master recursion in React to display hierarchical category trees.
---

# Disclaimer

:::u-alert
---
title: Comments in the code are for educational purposes only.
description: In real projects, avoid adding irrelevant or redundant comments.
color: warning
variant: subtle
icon: i-lucide-triangle-alert
---
:::

Categories can be nested (subcategories). We use **recursion** to render tree structures.

---

## Tree Structure

```
ğŸ“ Technical Support (parent)
  â”œâ”€ ğŸ“ Bug Reports (child)
  â”œâ”€ ğŸ“ Feature Requests (child)
  â””â”€ ğŸ“ Installation Help (child)
      â””â”€ ğŸ“ Windows (grandchild)
```

Each category has a `parentId` that references its parent.

---

## Recursion: The Pattern

**Recursion** = function that calls itself.

**Requirements:**
1. **Base case**: When to stop
2. **Recursive case**: Call itself with simpler input

```tsx
// Example: Countdown
function countdown(n: number) {
  if (n === 0) {
    console.log('Done!')  // Base case
    return
  }
  
  console.log(n)
  countdown(n - 1)  // Recursive case
}

countdown(3)
// Output: 3, 2, 1, Done!
```

---

## Recursive Component

```tsx
// src/components/categories/CategoryTreeItem.tsx

import { Link } from 'react-router-dom'
import type { Category } from '@/types'

interface CategoryTreeItemProps {
  category: Category
  allCategories: Category[]  // Needed to find children
  level?: number  // Indentation level
}

/**
 * Recursive component that renders a category and its children
 * 
 * How recursion works:
 * 1. Render this category
 * 2. Find its children
 * 3. Recursively render each child (calls itself!)
 * 4. Each child repeats steps 1-3
 */
export function CategoryTreeItem({
  category,
  allCategories,
  level = 0,
}: CategoryTreeItemProps) {
  /**
   * Find direct children of this category
   * 
   * Child: category where parentId === this category's id
   */
  const children = allCategories.filter((cat) => cat.parentId === category.id)

  /**
   * Calculate indentation based on depth
   * 
   * Level 0: 0px
   * Level 1: 20px
   * Level 2: 40px
   */
  const indent = level * 20

  return (
    <div>
      {/* This category */}
      <Link
        to={`/categories/${category.slug}`}
        className="block p-3 hover:bg-slate-800 rounded-md transition-colors"
        style={{ paddingLeft: `${indent + 12}px` }}  // Dynamic indentation
      >
        <div className="flex items-center gap-2">
          {/* Icon */}
          <span className="text-lg">
            {children.length > 0 ? 'ğŸ“' : 'ğŸ“„'}
          </span>

          {/* Name */}
          <span className="text-slate-100 font-medium">
            {category.name}
          </span>

          {/* Thread count */}
          <span className="text-xs text-slate-500 ml-auto">
            {category.threadCount}
          </span>
        </div>

        {/* Description */}
        {category.description && (
          <p className="text-sm text-slate-400 mt-1">
            {category.description}
          </p>
        )}
      </Link>

      {/* Children (RECURSIVE CALL) */}
      {children.length > 0 && (
        <div>
          {children.map((child) => (
            <CategoryTreeItem
              key={child.id}
              category={child}
              allCategories={allCategories}
              level={level + 1}  // Increase depth
            />
          ))}
        </div>
      )}
    </div>
  )
}
```

### How Recursion Works Here

**Step-by-step execution:**

```tsx
// Initial call
<CategoryTreeItem
  category={technicalSupport}  // parentId: null
  allCategories={all}
  level={0}
/>

// Finds children: [bugReports, featureRequests]

// Recursively calls itself for each child:
<CategoryTreeItem
  category={bugReports}  // parentId: technicalSupport.id
  allCategories={all}
  level={1}
/>

// And so on...
```

**Visual trace:**

```
CategoryTreeItem(Technical Support, level=0)
  â†’ Renders "Technical Support"
  â†’ Finds children: [Bug Reports, Feature Requests]
  â†’ Calls CategoryTreeItem(Bug Reports, level=1)
      â†’ Renders "Bug Reports" (indented)
      â†’ Finds children: []
      â†’ Done
  â†’ Calls CategoryTreeItem(Feature Requests, level=1)
      â†’ Renders "Feature Requests" (indented)
      â†’ Finds children: [Windows]
      â†’ Calls CategoryTreeItem(Windows, level=2)
          â†’ Renders "Windows" (more indented)
          â†’ Finds children: []
          â†’ Done
      â†’ Done
  â†’ Done
```

---

## Category Tree Component

```tsx
// src/components/categories/CategoryTree.tsx

import { CategoryTreeItem } from './CategoryTreeItem'
import type { Category } from '@/types'

interface CategoryTreeProps {
  categories: Category[]
}

/**
 * Renders entire category tree
 * 
 * Only renders root categories (parentId === null)
 * Children are rendered recursively by CategoryTreeItem
 */
export function CategoryTree({ categories }: CategoryTreeProps) {
  /**
   * Find root categories (no parent)
   */
  const rootCategories = categories.filter((cat) => cat.parentId === null)

  return (
    <div className="space-y-2">
      {rootCategories.map((category) => (
        <CategoryTreeItem
          key={category.id}
          category={category}
          allCategories={categories}
          level={0}
        />
      ))}
    </div>
  )
}
```

---

## Collapsible Tree

Add expand/collapse functionality.

```tsx
import { useState } from 'react'

export function CategoryTreeItem({
  category,
  allCategories,
  level = 0,
}: CategoryTreeItemProps) {
  const children = allCategories.filter((cat) => cat.parentId === category.id)
  
  /**
   * Track expanded state
   * 
   * Default: expanded if has children
   */
  const [isExpanded, setIsExpanded] = useState(children.length > 0)

  const indent = level * 20

  return (
    <div>
      <div
        className="block p-3 hover:bg-slate-800 rounded-md transition-colors cursor-pointer"
        style={{ paddingLeft: `${indent + 12}px` }}
        onClick={() => setIsExpanded(!isExpanded)}
      >
        <div className="flex items-center gap-2">
          {/* Expand/collapse icon */}
          {children.length > 0 && (
            <button
              type="button"
              className="text-slate-400 hover:text-slate-200"
              onClick={(e) => {
                e.stopPropagation()  // Don't trigger parent click
                setIsExpanded(!isExpanded)
              }}
            >
              {isExpanded ? 'â–¼' : 'â–¶'}
            </button>
          )}

          <span className="text-lg">
            {children.length > 0 ? 'ğŸ“' : 'ğŸ“„'}
          </span>

          <Link
            to={`/categories/${category.slug}`}
            className="text-slate-100 font-medium hover:text-blue-400"
            onClick={(e) => e.stopPropagation()}  // Don't collapse when clicking name
          >
            {category.name}
          </Link>

          <span className="text-xs text-slate-500 ml-auto">
            {category.threadCount}
          </span>
        </div>

        {category.description && (
          <p className="text-sm text-slate-400 mt-1">
            {category.description}
          </p>
        )}
      </div>

      {/* Only show children if expanded */}
      {isExpanded && children.length > 0 && (
        <div>
          {children.map((child) => (
            <CategoryTreeItem
              key={child.id}
              category={child}
              allCategories={allCategories}
              level={level + 1}
            />
          ))}
        </div>
      )}
    </div>
  )
}
```

---

## Breadcrumb Navigation

Show category hierarchy as breadcrumbs.

```tsx
// src/components/categories/CategoryBreadcrumb.tsx

import { Link } from 'react-router-dom'
import type { Category } from '@/types'

interface CategoryBreadcrumbProps {
  category: Category
  allCategories: Category[]
}

/**
 * Build breadcrumb trail using recursion
 * 
 * Start from current category, walk up to root
 */
export function CategoryBreadcrumb({
  category,
  allCategories,
}: CategoryBreadcrumbProps) {
  /**
   * Recursively build ancestor chain
   */
  function getAncestors(cat: Category): Category[] {
    if (!cat.parentId) {
      return [cat]  // Base case: root category
    }

    const parent = allCategories.find((c) => c.id === cat.parentId)
    if (!parent) {
      return [cat]
    }

    // Recursive case: prepend parent's ancestors
    return [...getAncestors(parent), cat]
  }

  const breadcrumbs = getAncestors(category)

  return (
    <nav className="flex items-center gap-2 text-sm" aria-label="Breadcrumb">
      <Link to="/categories" className="text-slate-400 hover:text-slate-200">
        Home
      </Link>

      {breadcrumbs.map((crumb, index) => (
        <div key={crumb.id} className="flex items-center gap-2">
          <span className="text-slate-600">/</span>
          
          {index === breadcrumbs.length - 1 ? (
            // Last item: not a link
            <span className="text-slate-100 font-medium">
              {crumb.name}
            </span>
          ) : (
            // Ancestor: link
            <Link
              to={`/categories/${crumb.slug}`}
              className="text-slate-400 hover:text-slate-200"
            >
              {crumb.name}
            </Link>
          )}
        </div>
      ))}
    </nav>
  )
}
```

---

## Performance: useMemo

Building child arrays on every render is expensive. Cache with `useMemo`.

```tsx
import { useMemo } from 'react'

export function CategoryTreeItem({
  category,
  allCategories,
  level = 0,
}: CategoryTreeItemProps) {
  /**
   * useMemo: Cache expensive computation
   * 
   * Only recompute when dependencies change
   */
  const children = useMemo(() => {
    return allCategories.filter((cat) => cat.parentId === category.id)
  }, [allCategories, category.id])

  // Rest of component...
}
```

### useMemo Explained

**Without useMemo:**
```tsx
// Recalculates EVERY render (even if allCategories didn't change)
const children = allCategories.filter((cat) => cat.parentId === category.id)
```

**With useMemo:**
```tsx
// Only recalculates when allCategories or category.id changes
const children = useMemo(() => {
  return allCategories.filter((cat) => cat.parentId === category.id)
}, [allCategories, category.id])
```

**When to use useMemo:**
- Expensive calculations (filtering large arrays, complex math)
- Referential equality matters (passing objects to child components)

**When NOT to use:**
- Simple calculations (addition, string concatenation)
- Premature optimization

---

## Summary

### Recursion Pattern
1. **Base case**: When to stop (no children)
2. **Recursive case**: Process current + recurse on children
3. **Pass state down**: Each level needs context (allCategories, level)

### New Concepts
1. **Recursion in React**: Component calls itself
2. **Tree structures**: Nested data with parent/child relationships
3. **Dynamic styling**: Indentation based on depth
4. **Event propagation**: `stopPropagation()` to prevent bubbling
5. **useMemo**: Cache expensive computations

### Best Practices
- âœ… Always have a base case (prevent infinite loops)
- âœ… Pass all data needed for recursion
- âœ… Use `key` prop in mapped arrays
- âœ… Optimize with useMemo for large trees
- âœ… Handle empty states (no children)

---

## Categories Module Complete! ğŸ‰

You've learned:
- âœ… Components, props, JSX
- âœ… Lists and keys
- âœ… useState for interactivity
- âœ… Forms with React Hook Form + Zod
- âœ… API integration
- âœ… useEffect for side effects
- âœ… Portals for modals
- âœ… Recursion for tree structures
- âœ… useMemo for performance

**Next module:** Threads (more complex than categories)

Continue to [Threads Module â†’](/en/react/4.threads-module/1.list-threads)
