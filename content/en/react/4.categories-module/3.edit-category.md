---
title: Edit Category - Side Effects & Data Fetching
description: Master useEffect for data fetching, loading states, and optimistic UI updates. Learn the dependency array, cleanup functions, and async patterns.
---

# Disclaimer

:::u-alert
---
title: Comments in the code are for educational purposes only.
description: In real projects, avoid adding irrelevant or redundant comments.
color: warning
variant: subtle
icon: i-lucide-triangle-alert
---
:::

Editing requires fetching existing data, populating forms, and handling updates. This introduces **useEffect** - React's hook for side effects - one of the most important concepts to master.

---

## What's Different from Create?

| Aspect | Create | Edit |
|--------|--------|------|
| HTTP Method | POST | PUT |
| Initial Values | Empty | Fetch from API |
| Route | `/categories/new` | `/categories/:id/edit` |
| Data Flow | User input → API | API → Form → API |
| After Success | Navigate to list | Navigate to detail |

---

## useEffect: Side Effects in React

### The Problem: Pure Functions

React components are **pure functions**:
```
Input (props) → Component → Output (JSX)
```

**Pure function rule:** Same input always produces same output.

```tsx
// ✅ Pure: Same props = same JSX
function CategoryCard({ category }) {
  return <div>{category.name}</div>
}

// ❌ Impure: Side effects (API calls, mutations)
function CategoryCard({ category }) {
  fetch('/api/categories/' + category.id)  // Side effect!
  return <div>{category.name}</div>
}
```

**Problems with side effects in render:**
- Runs on EVERY render (wasteful)
- Can't use async/await (render must be synchronous)
- Causes infinite loops
- Hard to debug

### The Solution: useEffect

`useEffect` lets us run side effects **after** render, not during.

```tsx
import { useEffect } from 'react'

function CategoryDetail() {
  const [category, setCategory] = useState(null)

  /**
   * useEffect: Run side effects after render
   * 
   * Signature: useEffect(setup, dependencies?)
   * 
   * - setup: Function that runs after render
   * - dependencies: Array of values to watch
   */
  useEffect(() => {
    // This runs AFTER component renders
    // Safe to use async/await here
    fetch('/api/categories/1')
      .then(res => res.json())
      .then(data => setCategory(data))
  }, [])  // Empty dependency array = run once on mount

  return <div>{category?.name}</div>
}
```

### Execution Timeline

```
Component renders
  ↓
Browser paints to screen
  ↓
useEffect runs (side effects)
  ↓
setState called
  ↓
Component re-renders
  ↓
Browser paints again
  ↓
useEffect runs again (if dependencies changed)
```

### The Dependency Array

The dependency array controls **when** the effect runs:

```tsx
// ❌ No dependency array: Runs after EVERY render
useEffect(() => {
  fetch('/api/categories')  // Infinite API calls!
})

// ✅ Empty array: Runs once on mount
useEffect(() => {
  fetch('/api/categories')  // Runs once
}, [])

// ✅ With dependencies: Runs when dependencies change
useEffect(() => {
  fetch(`/api/categories/${id}`)  // Runs when id changes
}, [id])

// ✅ Multiple dependencies
useEffect(() => {
  fetch(`/api/categories/${id}?sort=${sort}`)
}, [id, sort])  // Runs when id OR sort changes
```

**Rule:** Include ALL variables from outer scope that the effect uses:

```tsx
// ❌ Missing dependency
function CategoryDetail({ categoryId }) {
  useEffect(() => {
    fetch(`/api/categories/${categoryId}`)  // Uses categoryId
  }, [])  // But categoryId not in dependencies!
  // If categoryId changes, effect doesn't re-run
  // Stale data!
}

// ✅ Correct
function CategoryDetail({ categoryId }) {
  useEffect(() => {
    fetch(`/api/categories/${categoryId}`)
  }, [categoryId])  // Include categoryId
  // If categoryId changes, effect re-runs
}
```

### Cleanup Function

Effects can return a cleanup function that runs:
- Before the effect runs again
- When component unmounts

```tsx
useEffect(() => {
  // Setup
  const timer = setTimeout(() => {
    console.log('Hello')
  }, 1000)

  // Cleanup: Return a function
  return () => {
    clearTimeout(timer)  // Cancel timer if component unmounts
  }
}, [])
```

**Why cleanup matters:**

```tsx
// ❌ Without cleanup: Memory leak
function SearchResults({ query }) {
  useEffect(() => {
    const controller = new AbortController()
    
    fetch(`/api/search?q=${query}`, {
      signal: controller.signal
    })
    .then(res => res.json())
    .then(data => setResults(data))
    
    // If component unmounts, request still completes
    // setState called on unmounted component = warning
  }, [query])
}

// ✅ With cleanup: Cancel request
function SearchResults({ query }) {
  useEffect(() => {
    const controller = new AbortController()
    
    fetch(`/api/search?q=${query}`, {
      signal: controller.signal
    })
    .then(res => res.json())
    .then(data => setResults(data))
    
    // Cleanup: Abort request if component unmounts
    return () => controller.abort()
  }, [query])
}
```

---

## Edit Category Page

```tsx
// src/pages/EditCategoryPage.tsx

import { useState, useEffect } from 'react'
import { useParams, useNavigate } from 'react-router-dom'
import { EditCategoryForm } from '@/features/categories/components/EditCategoryForm'
import { apiClient } from '@/lib/api-client'
import type { Category } from '@/types'

export function EditCategoryPage() {
  const { id } = useParams<{ id: string }>()
  const navigate = useNavigate()
  
  const [category, setCategory] = useState<Category | null>(null)
  const [isLoading, setIsLoading] = useState(true)
  const [error, setError] = useState<string | null>(null)

  /**
   * Fetch category data when component mounts or id changes
   */
  useEffect(() => {
    async function fetchCategory() {
      try {
        setIsLoading(true)
        setError(null)
        
        const response = await apiClient.get<Category>(`/categories/${id}`)
        setCategory(response.data)
      } catch (err) {
        setError(err instanceof Error ? err.message : 'Failed to load category')
      } finally {
        setIsLoading(false)
      }
    }

    fetchCategory()
  }, [id])

  const handleSuccess = (updatedCategory: Category) => {
    navigate(`/categories/${updatedCategory.slug}`)
  }

  if (isLoading) {
    return <div className="p-8 text-center">Loading...</div>
  }

  if (error || !category) {
    return (
      <div className="p-8 text-center text-red-400">
        {error || 'Category not found'}
      </div>
    )
  }

  return (
    <div className="container mx-auto px-4 py-8 max-w-2xl">
      <h1 className="text-3xl font-bold mb-2">Edit Category</h1>
      <p className="text-slate-400 mb-6">Update "{category.name}" details</p>
      
      <div className="bg-slate-900 rounded-lg border border-slate-800 p-6">
        <EditCategoryForm
          category={category}
          onSuccess={handleSuccess}
        />
      </div>
    </div>
  )
}
```

---

## Edit Form Component

```tsx
// src/features/categories/components/EditCategoryForm.tsx

import { useForm } from 'react-hook-form'
import { zodResolver } from '@hookform/resolvers/zod'
import { createCategorySchema, type CreateCategoryInput } from '../schemas'
import { apiClient } from '@/lib/api-client'
import { toast } from '@/lib/toast'
import type { Category } from '@/types'

interface EditCategoryFormProps {
  category: Category
  onSuccess: (category: Category) => void
}

export function EditCategoryForm({ category, onSuccess }: EditCategoryFormProps) {
  const {
    register,
    handleSubmit,
    formState: { errors, isSubmitting },
  } = useForm<CreateCategoryInput>({
    resolver: zodResolver(createCategorySchema),
    
    /**
     * defaultValues: Populate form with existing data
     * 
     * This is the key difference from Create form.
     * Form starts with existing values instead of empty.
     */
    defaultValues: {
      name: category.name,
      description: category.description || '',
      parentId: category.parentId,
    },
  })

  const onSubmit = async (data: CreateCategoryInput) => {
    try {
      /**
       * PUT request to update existing resource
       * 
       * URL includes the category ID
       */
      const response = await apiClient.put<Category>(
        `/categories/${category.id}`,
        data
      )

      toast.success('Category updated successfully!')
      onSuccess(response.data)
    } catch (error) {
      toast.error(error instanceof Error ? error.message : 'Failed to update category')
    }
  }

  return (
    <form onSubmit={handleSubmit(onSubmit)} className="space-y-6">
      <div>
        <label htmlFor="name" className="block text-sm font-medium text-slate-200 mb-2">
          Category Name *
        </label>
        <input
          id="name"
          type="text"
          {...register('name')}
          className="w-full px-4 py-3 bg-slate-900 border border-slate-700 rounded-lg text-slate-100 focus:border-blue-500 focus:ring-1 focus:ring-blue-500"
        />
        {errors.name && (
          <p className="mt-2 text-sm text-red-400">{errors.name.message}</p>
        )}
      </div>

      <div>
        <label htmlFor="description" className="block text-sm font-medium text-slate-200 mb-2">
          Description
        </label>
        <textarea
          id="description"
          rows={3}
          {...register('description')}
          className="w-full px-4 py-3 bg-slate-900 border border-slate-700 rounded-lg text-slate-100 focus:border-blue-500 focus:ring-1 focus:ring-blue-500"
        />
        {errors.description && (
          <p className="mt-2 text-sm text-red-400">{errors.description.message}</p>
        )}
      </div>

      <div className="flex gap-3">
        <button
          type="submit"
          disabled={isSubmitting}
          className="flex-1 px-6 py-3 bg-blue-600 text-white rounded-lg hover:bg-blue-700 disabled:opacity-50"
        >
          {isSubmitting ? 'Updating...' : 'Update Category'}
        </button>
      </div>
    </form>
  )
}
```

---

## Optimistic Updates

For better UX, update the UI immediately before the API responds:

```tsx
export function useCategoryUpdate() {
  const queryClient = useQueryClient()

  return useMutation({
    mutationFn: async ({ id, data }: { id: string; data: CreateCategoryInput }) => {
      return apiClient.put<Category>(`/categories/${id}`, data)
    },
    
    /**
     * onMutate: Runs BEFORE request
     * 
     * 1. Save current state (for rollback)
     * 2. Update UI optimistically
     */
    onMutate: async ({ id, data }) => {
      await queryClient.cancelQueries({ queryKey: ['categories', id] })

      const previous = queryClient.getQueryData<Category>(['categories', id])

      if (previous) {
        queryClient.setQueryData<Category>(['categories', id], {
          ...previous,
          ...data,
        })
      }

      return { previous }
    },

    /**
     * onError: Rollback on failure
     */
    onError: (err, variables, context) => {
      if (context?.previous) {
        queryClient.setQueryData(['categories', variables.id], context.previous)
      }
      toast.error('Failed to update category')
    },

    onSuccess: (response) => {
      queryClient.setQueryData(['categories', response.data.id], response.data)
      toast.success('Category updated!')
    },
  })
}
```

---

## Summary

### Key Concepts

1. **useEffect**: Run side effects after render
   - `[]` = run once on mount
   - `[dep]` = run when dep changes
   - Return cleanup function

2. **Dependency Array**: Controls when effect runs
   - Include ALL variables from outer scope
   - Missing dependencies = stale data

3. **Cleanup**: Cancel requests on unmount
   - Prevent memory leaks
   - Prevent setState warnings

4. **Optimistic Updates**: Update UI before API responds
   - Better perceived performance
   - Rollback on error

### Best Practices

- ✅ Always include dependencies
- ✅ Use cleanup functions for async operations
- ✅ Use AbortController for fetch requests
- ✅ Show loading states
- ✅ Handle errors gracefully
- ✅ Implement optimistic updates for mutations

---

Next: [Delete Category →](/en/react/4.categories-module/4.delete-category)

**Signature:**
```tsx
useEffect(setup, dependencies?)
```

- `setup`: Function that runs the effect
- `dependencies`: Array of values the effect depends on

**When it runs:**
```tsx
useEffect(() => {
  // Runs after every render
})

useEffect(() => {
  // Runs once after mount
}, [])

useEffect(() => {
  // Runs when categoryId changes
}, [categoryId])
```

---

## Edit Category Page

```tsx
// src/pages/EditCategoryPage.tsx

import { useState, useEffect } from 'react'
import { useParams, useNavigate } from 'react-router-dom'
import { EditCategoryForm } from '@/features/categories/components/EditCategoryForm'
import { apiClient } from '@/lib/api-client'
import type { Category } from '@/types'

export function EditCategoryPage() {
  const { id } = useParams<{ id: string }>()  // Get category ID from URL
  const navigate = useNavigate()
  
  const [category, setCategory] = useState<Category | null>(null)
  const [isLoading, setIsLoading] = useState(true)
  const [error, setError] = useState<string | null>(null)

  /**
   * Fetch category data when component mounts or ID changes
   * 
   * useEffect runs AFTER render, so user sees loading state first
   */
  useEffect(() => {
    /**
     * Why async function inside useEffect?
     * 
     * useEffect callback cannot be async directly
     * So we define async function and call it immediately
     */
    async function fetchCategory() {
      try {
        setIsLoading(true)
        setError(null)
        
        const response = await apiClient.get<Category>(`/categories/${id}`)
        setCategory(response.data)
      } catch (err) {
        setError(err instanceof Error ? err.message : 'Failed to load category')
      } finally {
        setIsLoading(false)
      }
    }

    fetchCategory()
  }, [id])  // Re-run if ID changes

  const handleSuccess = (updatedCategory: Category) => {
    navigate(`/categories/${updatedCategory.slug}`)
  }

  // Loading state
  if (isLoading) {
    return (
      <div className="container mx-auto px-4 py-8 max-w-2xl">
        <div className="animate-pulse space-y-4">
          <div className="h-8 bg-slate-800 rounded w-1/3" />
          <div className="h-64 bg-slate-800 rounded" />
        </div>
      </div>
    )
  }

  // Error state
  if (error || !category) {
    return (
      <div className="container mx-auto px-4 py-8 max-w-2xl">
        <div className="bg-red-900/20 border border-red-700 rounded-lg p-4">
          <p className="text-red-400">{error || 'Category not found'}</p>
        </div>
      </div>
    )
  }

  // Success state: render form
  return (
    <div className="container mx-auto px-4 py-8 max-w-2xl">
      <div className="mb-8">
        <h1 className="text-3xl font-bold text-slate-100 mb-2">
          Edit Category
        </h1>
        <p className="text-slate-400">
          Update "{category.name}" details
        </p>
      </div>

      <div className="bg-slate-900 rounded-lg border border-slate-800 p-6">
        <EditCategoryForm
          category={category}
          onSuccess={handleSuccess}
        />
      </div>
    </div>
  )
}
```

### useEffect Deep Dive

**The dependency array:**

```tsx
useEffect(() => {
  fetchCategory()
}, [id])  // Only re-run when id changes
```

**What happens:**
1. Component mounts → effect runs
2. User clicks different category → `id` changes → effect runs again
3. Component re-renders for other reasons → effect does NOT run (because `id` didn't change)

**Common mistake:**
```tsx
// ❌ Missing dependency
useEffect(() => {
  console.log(userId)
}, [])  // userId is stale!

// ✅ Include all dependencies
useEffect(() => {
  console.log(userId)
}, [userId])
```

**Cleanup:**

```tsx
useEffect(() => {
  const timer = setTimeout(() => {
    console.log('Hello')
  }, 1000)

  // Cleanup function
  return () => {
    clearTimeout(timer)
  }
}, [])
```

Cleanup runs:
- Before effect runs again
- When component unmounts

---

## Edit Form Component

```tsx
// src/features/categories/components/EditCategoryForm.tsx

import { useForm } from 'react-hook-form'
import { zodResolver } from '@hookform/resolvers/zod'
import { createCategorySchema, type CreateCategoryInput } from '../schemas'
import { apiClient } from '@/lib/api-client'
import { toast } from '@/lib/toast'
import type { Category } from '@/types'

interface EditCategoryFormProps {
  category: Category
  onSuccess: (category: Category) => void
}

export function EditCategoryForm({ category, onSuccess }: EditCategoryFormProps) {
  const {
    register,
    handleSubmit,
    formState: { errors, isSubmitting },
  } = useForm<CreateCategoryInput>({
    resolver: zodResolver(createCategorySchema),
    
    /**
     * defaultValues: Populate form with existing data
     * 
     * This is how edit forms differ from create forms
     */
    defaultValues: {
      name: category.name,
      description: category.description || '',
      parentId: category.parentId,
    },
  })

  const onSubmit = async (data: CreateCategoryInput) => {
    try {
      /**
       * PUT request to update existing resource
       * 
       * URL includes the category ID
       */
      const response = await apiClient.put<Category>(
        `/categories/${category.id}`,
        data
      )

      toast.success('Category updated successfully!')
      onSuccess(response.data)
    } catch (error) {
      toast.error(error instanceof Error ? error.message : 'Failed to update category')
    }
  }

  return (
    <form onSubmit={handleSubmit(onSubmit)} className="space-y-6">
      <div>
        <label htmlFor="name" className="block text-sm font-medium text-slate-200">
          Category Name *
        </label>
        <input
          id="name"
          type="text"
          {...register('name')}
          className="mt-1 block w-full rounded-md bg-slate-800 border-slate-700 text-slate-100 focus:border-blue-500 focus:ring-blue-500"
        />
        {errors.name && (
          <p className="mt-1 text-sm text-red-500">{errors.name.message}</p>
        )}
      </div>

      <div>
        <label htmlFor="description" className="block text-sm font-medium text-slate-200">
          Description
        </label>
        <textarea
          id="description"
          {...register('description')}
          rows={3}
          className="mt-1 block w-full rounded-md bg-slate-800 border-slate-700 text-slate-100 focus:border-blue-500 focus:ring-blue-500"
        />
        {errors.description && (
          <p className="mt-1 text-sm text-red-500">{errors.description.message}</p>
        )}
      </div>

      <div className="flex gap-3">
        <button
          type="submit"
          disabled={isSubmitting}
          className="flex-1 px-4 py-2 bg-blue-600 text-white rounded-md hover:bg-blue-700 disabled:opacity-50"
        >
          {isSubmitting ? 'Updating...' : 'Update Category'}
        </button>
      </div>
    </form>
  )
}
```

---

## Optimistic Updates

For better UX, update the UI **immediately** before the API responds. If the API fails, revert.

```tsx
export function useCategoryUpdate() {
  const queryClient = useQueryClient()

  return useMutation({
    mutationFn: async ({ id, data }: { id: string; data: CreateCategoryInput }) => {
      return apiClient.put<Category>(`/categories/${id}`, data)
    },
    
    /**
     * onMutate: Runs BEFORE request
     * 
     * 1. Save current state (for rollback)
     * 2. Update UI optimistically
     */
    onMutate: async ({ id, data }) => {
      // Cancel outgoing requests
      await queryClient.cancelQueries({ queryKey: ['categories', id] })

      // Snapshot current value
      const previous = queryClient.getQueryData<Category>(['categories', id])

      // Optimistically update
      if (previous) {
        queryClient.setQueryData<Category>(['categories', id], {
          ...previous,
          ...data,
        })
      }

      // Return context for rollback
      return { previous }
    },

    /**
     * onError: Rollback on failure
     */
    onError: (err, variables, context) => {
      if (context?.previous) {
        queryClient.setQueryData(['categories', variables.id], context.previous)
      }
      toast.error('Failed to update category')
    },

    /**
     * onSuccess: Confirm update
     */
    onSuccess: (response) => {
      queryClient.setQueryData(['categories', response.data.id], response.data)
      toast.success('Category updated!')
    },
  })
}
```

---

## Summary

### New Concepts
1. **useEffect**: Run side effects after render
   - `[]` = run once
   - `[dep]` = run when dep changes
   - Return cleanup function

2. **Populating Forms**: Set `defaultValues` in useForm

3. **PUT vs POST**: 
   - POST creates new resource
   - PUT updates existing resource

4. **Optimistic Updates**: Update UI before API responds

### Best Practices
- ✅ Show loading states during fetch
- ✅ Handle errors gracefully
- ✅ Use cleanup functions in useEffect
- ✅ Include all dependencies in dependency array
- ✅ Provide rollback for optimistic updates

---

Next: [Delete Category →](/en/react/3.categories-module/4.delete-category)
