---
title: List Categories - Your First React Feature
description: Build your first complete React feature from scratch. Master components, props, JSX, lists, TypeScript, testing, and React's mental model through the simplest CRUD operation.
---

# Disclaimer

:::u-alert
---
title: Comments in the code are for educational purposes only.
description: In real projects, avoid adding irrelevant or redundant comments.
color: warning
variant: subtle
icon: i-lucide-triangle-alert
---
:::

We start with the **simplest possible feature**: displaying a list of forum categories. This teaches you React fundamentals in a real-world context, building confidence before tackling more complex features.

**Why start here?**
- No API calls yet (static data)
- No user input (read-only)
- Pure rendering logic
- Immediate visual feedback
- Foundation for all other features

---

## What We're Building

A category list for our forum that displays:
- Category name and description
- Thread count (not post count - threads are top-level discussions)
- Visual hierarchy (nested categories)
- Clickable cards that navigate to category detail
- Responsive grid layout

**Visual structure:**
```
üìÅ General Discussion (245 threads)
   "A place for general discussions and community chat"
   
üìÅ Technical Support (89 threads)
   "Get help with technical issues and questions"
   
  ‚îî‚îÄ üìÅ Bug Reports (34 threads)
  ‚îî‚îÄ üìÅ Feature Requests (55 threads)
  
üìÅ Announcements (12 threads)
   "Official announcements and news"
```

---

## React Components: The Foundation

### What is a Component?

A **component** is a JavaScript function that returns **JSX** (UI markup). It's React's way of building reusable pieces of UI.

**The simplest component:**
```tsx
function Greeting() {
  return <h1>Hello, World!</h1>
}
```

**Using the component:**
```tsx
<Greeting />  // Renders: <h1>Hello, World!</h1>
```

### Components vs HTML Tags

| HTML Tag | React Component |
|----------|----------------|
| `<div>` | Built-in |
| `<button>` | Built-in |
| `<CategoryCard>` | Your custom component! |
| `<ThreadList>` | Your custom component! |

**Think of components as:**
- Custom HTML tags you define
- Reusable UI building blocks
- Functions that return markup
- LEGO pieces you combine

### Why Functions? (Not Classes)

React started with class components (before 2019), then switched to functions. Here's why functions won:

```tsx
// ‚ùå OLD WAY: Class components (verbose, confusing)
class Greeting extends React.Component {
  render() {
    return <h1>Hello, {this.props.name}!</h1>
  }
}

// ‚úÖ NEW WAY: Function components (simple, clear)
function Greeting({ name }) {
  return <h1>Hello, {name}!</h1>
}
```

**Benefits of functions:**
1. **Simpler mental model**: `input (props) ‚Üí output (JSX)`
2. **No `this` keyword**: Less confusion
3. **Easier to test**: Pure functions are testable
4. **Composable**: Mix and match easily
5. **Hooks**: Modern React features only work in functions
6. **Less code**: ~40% less boilerplate

---

## Thinking in React: The Mental Model

Before writing code, we need to understand **how React thinks**.

### The React Philosophy

React is **declarative**, not imperative:

**‚ùå Imperative (jQuery way):**
```javascript
// Tell the browser HOW to update
$('#counter').text('0')
$('#button').click(() => {
  let count = parseInt($('#counter').text())
  count++
  $('#counter').text(count)  // Manual DOM update
})
```

**‚úÖ Declarative (React way):**
```tsx
// Tell React WHAT the UI should look like
function Counter() {
  const [count, setCount] = useState(0)
  
  return (
    <div>
      <p>{count}</p>
      <button onClick={() => setCount(count + 1)}>
        Increment
      </button>
    </div>
  )
  // React figures out HOW to update the DOM
}
```

### UI as a Function of State

This is React's core principle:

```
UI = f(state)
```

Translation: **Your UI is a pure function of your state.**

```tsx
function CategoryList({ categories }) {
  // Given categories (state),
  // always render the same UI
  return (
    <div>
      {categories.map(cat => <CategoryCard key={cat.id} category={cat} />)}
    </div>
  )
}

// Same input ‚Üí Same output (predictable!)
```

**Benefits:**
- **Predictable**: Same state = same UI
- **Debuggable**: Know state = know UI
- **Testable**: Input state, assert UI
- **Time-travel**: Replay state changes

---

## Breaking Down the Feature

Let's decompose "list categories" into components:

```
CategoriesPage
‚îú‚îÄ PageHeader
‚îÇ  ‚îú‚îÄ Title
‚îÇ  ‚îî‚îÄ CreateButton
‚îú‚îÄ CategoryList
‚îÇ  ‚îú‚îÄ CategoryCard (General Discussion)
‚îÇ  ‚îú‚îÄ CategoryCard (Technical Support)
‚îÇ  ‚îî‚îÄ CategoryCard (Announcements)
‚îî‚îÄ EmptyState (if no categories)
```

**Component hierarchy visualized:**
```tsx
<CategoriesPage>
  <PageHeader />
  <CategoryList>
    <CategoryCard />
    <CategoryCard />
    <CategoryCard />
  </CategoryList>
</CategoriesPage>
```

### Component Responsibility (Single Responsibility Principle)

Each component has **ONE job**:

| Component | Responsibility |
|-----------|---------------|
| `CategoriesPage` | Layout, fetching data (later) |
| `PageHeader` | Page title and actions |
| `CategoryList` | Grid layout for categories |
| `CategoryCard` | Display ONE category |
| `EmptyState` | Show message when no categories |

**Why separate?**
- **Easier to understand**: Each file is small
- **Easier to test**: Test one thing at a time
- **Easier to reuse**: Use `CategoryCard` anywhere
- **Easier to change**: Modify card without touching list

### Breaking UI into Components: The Mental Model

**How to think in React components:**

**Step 1: Draw boxes around every component**

```
‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
‚îÇ CategoriesPage                         ‚îÇ
‚îÇ ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê ‚îÇ
‚îÇ ‚îÇ PageHeader ("Forum Categories")   ‚îÇ ‚îÇ
‚îÇ ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò ‚îÇ
‚îÇ ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê ‚îÇ
‚îÇ ‚îÇ CategoryList                       ‚îÇ ‚îÇ
‚îÇ ‚îÇ ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê ‚îÇ ‚îÇ
‚îÇ ‚îÇ ‚îÇ CategoryCard ‚îÇ ‚îÇ CategoryCard ‚îÇ ‚îÇ ‚îÇ
‚îÇ ‚îÇ ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò ‚îÇ ‚îÇ
‚îÇ ‚îÇ ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê                  ‚îÇ ‚îÇ
‚îÇ ‚îÇ ‚îÇ CategoryCard ‚îÇ                  ‚îÇ ‚îÇ
‚îÇ ‚îÇ ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò                  ‚îÇ ‚îÇ
‚îÇ ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò ‚îÇ
‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò
```

**Step 2: Name each box**
- `CategoriesPage`: The entire page
- `PageHeader`: Title and action buttons
- `CategoryList`: Grid container
- `CategoryCard`: Individual category

**Step 3: Identify hierarchy (parent/child relationships)**
- `CategoriesPage` ‚Üí owns `PageHeader` and `CategoryList`
- `CategoryList` ‚Üí owns multiple `CategoryCard`
- `CategoryCard` ‚Üí leaf component (no children)

**Step 4: Determine data flow**
- `CategoriesPage` has categories array
- Passes array to `CategoryList`
- `CategoryList` passes individual category to each `CategoryCard`

**When to create a new component?**

‚úÖ **Create a new component when:**
- It's used multiple times (reusability)
- It does one clear thing (single responsibility)
- The parent is getting too big (>200 lines)
- You want to test it separately (testability)
- It has its own state or logic (encapsulation)

‚ùå **Don't create a new component when:**
- It's only used once and is tiny (<10 lines)
- It's tightly coupled to parent (no clear boundary)
- It makes code harder to follow (over-abstraction)

**Example decision tree:**

```tsx
// CategoryCard renders the same UI 10+ times ‚Üí Extract to component ‚úÖ
{categories.map(cat => <CategoryCard category={cat} />)}

// CategoryHeader only used once, 5 lines ‚Üí Keep inline ‚ùå
<div className="mb-4">
  <h1>Categories</h1>
</div>
```

---

## TypeScript: Type Safety First

Before building components, define the **data structure**. TypeScript prevents bugs by catching errors at compile time.

### Why TypeScript?

```tsx
// ‚ùå JavaScript: Runtime errors
function CategoryCard({ category }) {
  return <h3>{category.nama}</h3>  // Typo! Crashes at runtime
}

// ‚úÖ TypeScript: Compile-time errors
interface Category {
  name: string
}

function CategoryCard({ category }: { category: Category }) {
  return <h3>{category.nama}</h3>  // Error before running!
  // Property 'nama' does not exist on type 'Category'
}
```

**Benefits:**
- **Catch bugs early**: Before running code
- **Autocomplete**: IDE knows what properties exist
- **Refactoring confidence**: Rename safely
- **Documentation**: Types are living docs
- **Better DX**: IntelliSense, inline errors

---

## Category Type

First, define the data structure. TypeScript ensures we handle data correctly.

```typescript
// src/types/index.ts

/**
 * Category entity from domain model
 * Categories organize forum threads into topics
 */
export interface Category {
  id: string              // UUID v7
  name: string            // "Technical Support"
  slug: string            // URL-friendly: "technical-support"
  description: string | null  // Optional tagline
  parentId: string | null     // For nested categories (null = root)
  order: number           // Display order (lower = first)
  threadCount: number     // Cached count for performance
  createdAt: string       // ISO 8601: "2024-01-15T10:30:00Z"
  updatedAt: string
}
```

**Why these fields?**
- `slug`: SEO-friendly URLs (`/categories/technical-support` not `/categories/abc-123`)
- `parentId`: Enables nested categories (replies to posts pattern)
- `order`: Manual sorting without timestamps
- `threadCount`: Avoid counting on every render

---

## JSX: JavaScript + XML

JSX looks like HTML but it's JavaScript. React transforms it into function calls.

```tsx
// What you write
<div className="card">
  <h2>{category.name}</h2>
</div>

// What React sees
React.createElement('div', { className: 'card' },
  React.createElement('h2', null, category.name)
)
```

**JSX Rules:**
1. **Return single root**: Wrap multiple elements in `<div>` or `<>` (Fragment)
2. **Close all tags**: `<img />` not `<img>`
3. **camelCase attributes**: `className` not `class`, `onClick` not `onclick`
4. **Curly braces for JS**: `{category.name}` not `category.name`

---

## CategoryCard Component

```tsx
// src/components/categories/CategoryCard.tsx

interface CategoryCardProps {
  category: Category
}

/**
 * Displays a single category with icon, name, description, and post count
 * 
 * Design decisions:
 * - Click entire card (not just text) for better UX
 * - Hover effect for discoverability
 * - Icon for visual hierarchy
 * - Post count for activity indicator
 */
export function CategoryCard({ category }: CategoryCardProps) {
  return (
    <Link
      to={`/categories/${category.slug}`}
      className="block p-4 rounded-lg bg-slate-800 hover:bg-slate-700 transition-colors border border-slate-700"
    >
      {/* Icon + Title Row */}
      <div className="flex items-center gap-3 mb-2">
        {/* Folder icon for visual recognition */}
        <div className="text-2xl">üìÅ</div>
        
        {/* Category name - semantic h3 for accessibility */}
        <h3 className="text-lg font-semibold text-slate-100">
          {category.name}
        </h3>
      </div>

      {/* Description - conditional rendering */}
      {category.description && (
        <p className="text-sm text-slate-400 mb-3">
          {category.description}
        </p>
      )}

      {/* Metadata row */}
      <div className="flex items-center gap-4 text-xs text-slate-500">
        {/* Thread count */}
        <span>
          {category.threadCount} {category.threadCount === 1 ? 'thread' : 'threads'}
        </span>
      </div>
    </Link>
  )
}
```

### Breaking Down the Component

**Props Interface:**
```tsx
interface CategoryCardProps {
  category: Category  // Type-safe: only Category objects allowed
}
```

Why interfaces?
- **Type safety**: TypeScript catches errors at compile time
- **Documentation**: Props are self-documenting
- **Autocomplete**: IDE knows what properties exist

**Destructuring:**
```tsx
export function CategoryCard({ category }: CategoryCardProps) {
  // Destructure props in function signature
  // Instead of: props.category.name
  // We write: category.name
}
```

**Conditional Rendering:**
```tsx
{category.description && (
  <p>{category.description}</p>
)}
```

Pattern: `condition && <JSX>` (if condition is truthy, render JSX)

Why not `? :` (ternary)?
- Cleaner for "show or hide" logic
- No need for `: null`

---

## Rendering Lists: map()

React renders arrays of JSX. Use `.map()` to transform data into components.

```tsx
// src/pages/CategoriesPage.tsx

import { CategoryCard } from '@/components/categories/CategoryCard'
import type { Category } from '@/types'

export function CategoriesPage() {
  // Mock data (we'll fetch from API later)
  const categories: Category[] = [
    {
      id: '01HXQK9Z3XAMPLE000001',
      name: 'General Discussion',
      slug: 'general-discussion',
      description: 'General topics and community chat',
      parentId: null,
      order: 1,
      threadCount: 245,
      createdAt: '2024-01-15T10:00:00Z',
      updatedAt: '2024-01-15T10:00:00Z',
    },
    {
      id: '01HXQK9Z3XAMPLE000002',
      name: 'Technical Support',
      slug: 'technical-support',
      description: 'Get help with technical issues',
      parentId: null,
      order: 2,
      threadCount: 89,
      createdAt: '2024-01-15T10:05:00Z',
      updatedAt: '2024-01-15T10:05:00Z',
    },
  ]

  return (
    <div className="container mx-auto px-4 py-8">
      {/* Page header */}
      <h1 className="text-3xl font-bold text-slate-100 mb-6">
        Forum Categories
      </h1>

      {/* Categories grid */}
      <div className="grid gap-4 md:grid-cols-2 lg:grid-cols-3">
        {categories.map((category) => (
          <CategoryCard
            key={category.id}
            category={category}
          />
        ))}
      </div>
    </div>
  )
}
```

### The `key` Prop: Why It Matters

**Every list item MUST have a unique `key`:**

```tsx
{categories.map((category) => (
  <CategoryCard
    key={category.id}  // ‚úÖ Unique, stable identifier
    category={category}
  />
))}
```

**Why keys?**

React uses keys to:
1. **Identify which items changed**: Update only what's different
2. **Preserve component state**: If you reorder, state stays with the correct item
3. **Optimize performance**: Avoid re-creating DOM nodes

**Bad keys:**
```tsx
key={index}  // ‚ùå BAD: Changes when array reorders
key={Math.random()}  // ‚ùå BAD: New key every render ‚Üí full re-mount
```

**Good keys:**
```tsx
key={category.id}  // ‚úÖ GOOD: Stable, unique identifier
```

---

## Component Composition

Break UI into smaller pieces. Each component has **one job**.

```tsx
// ‚ùå BAD: Giant component doing everything
function CategoriesPage() {
  return (
    <div>
      {/* 200 lines of JSX... */}
    </div>
  )
}

// ‚úÖ GOOD: Composed from smaller components
function CategoriesPage() {
  return (
    <div>
      <PageHeader title="Categories" />
      <CategoryList categories={categories} />
    </div>
  )
}

function CategoryList({ categories }) {
  return (
    <div className="grid gap-4">
      {categories.map(category => (
        <CategoryCard key={category.id} category={category} />
      ))}
    </div>
  )
}
```

**Benefits:**
- **Easier to test**: Test `CategoryCard` in isolation
- **Easier to read**: Understand one component at a time
- **Easier to reuse**: Use `CategoryCard` anywhere

---

## Props: Passing Data Down

Props flow **downward** from parent to child (unidirectional data flow).

```tsx
// Parent
<CategoryCard
  category={myCategory}  // Pass data down
/>

// Child
function CategoryCard({ category }) {
  // category is read-only here
  // Child CANNOT modify it
  return <div>{category.name}</div>
}
```

**Props are immutable:**
```tsx
function CategoryCard({ category }) {
  category.name = 'New Name'  // ‚ùå ERROR: Cannot modify props
}
```

Why immutable?
- **Predictable**: Data flows one way (top ‚Üí down)
- **Debuggable**: Know where data comes from
- **Safe**: No accidental mutations

### The React Data Flow: One-Way Street

React's data flows like water downhill: always DOWN, never UP.

```
    CategoriesPage (has categories array)
          ‚Üì props
    CategoryList (receives array)
          ‚Üì props
    CategoryCard (receives one category)
```

**Key principle**: Children cannot directly modify parent state.

**Why one-way?**
- **Easier to debug**: Data comes from ONE place (parent)
- **Easier to reason about**: Follow data down the tree
- **Prevents bugs**: No child can accidentally break parent

### Lifting State Up: When Components Need to Share

**The problem**: What if two components need the same data?

**Example**: Category filter and category list

```tsx
// ‚ùå WRONG: Each component has its own state (out of sync!)
function CategoryFilters() {
  const [filter, setFilter] = useState('all')  // Filter state here
  return <button onClick={() => setFilter('tech')}>Show Tech</button>
}

function CategoryList() {
  const [filter, setFilter] = useState('all')  // Duplicate state!
  // Filter is always 'all' here, even if user clicked button above!
  const filtered = categories.filter(cat => filterMatch(cat, filter))
  return <div>{/* ... */}</div>
}
```

They're **out of sync**! User clicks button, but list doesn't update. üò±

**The solution: Lift state to common parent**

```tsx
// ‚úÖ CORRECT: Parent owns the state, children share it
function CategoriesPage() {
  // State lives in parent (single source of truth)
  const [filter, setFilter] = useState('all')

  // Filter categories based on state
  const filteredCategories = categories.filter(cat => {
    if (filter === 'all') return true
    if (filter === 'tech') return cat.name.includes('Tech')
    return true
  })

  return (
    <>
      {/* Pass state AND setter to filter component */}
      <CategoryFilters 
        filter={filter} 
        onFilterChange={setFilter}  // Child can request changes
      />
      
      {/* Pass filtered data to list */}
      <CategoryList categories={filteredCategories} />
    </>
  )
}

function CategoryFilters({ filter, onFilterChange }) {
  return (
    <button onClick={() => onFilterChange('tech')}>
      Show Tech
    </button>
  )
}

function CategoryList({ categories }) {
  return (
    <div>
      {categories.map(cat => <CategoryCard key={cat.id} category={cat} />)}
    </div>
  )
}
```

**How it works:**

1. **Parent owns state**: `CategoriesPage` has `filter` state
2. **Parent passes data down**: Both children receive props
3. **Child requests changes**: `CategoryFilters` calls `onFilterChange`
4. **Parent updates state**: `setFilter` changes filter
5. **React re-renders**: Both children get new props
6. **UI updates**: List shows filtered categories

**Data flow diagram:**

```
User clicks "Show Tech" button
         ‚Üì
  onFilterChange('tech') called
         ‚Üì
  Parent's setFilter('tech') runs
         ‚Üì
  Parent re-renders with filter='tech'
         ‚Üì
  ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
  ‚Üì                                  ‚Üì
CategoryFilters               CategoryList
gets filter='tech'           gets filtered categories
```

**When to lift state up?**

‚úÖ **Lift state when:**
- Two components need the same data
- A child needs to change parent's data
- You want a single source of truth

‚ùå **Don't lift state when:**
- Only one component needs it (keep it local)
- State is completely independent
- It makes code unnecessarily complex

**Real-world example in our forum:**

```tsx
// Later, when we add filtering:
function CategoriesPage() {
  const [categories, setCategories] = useState([])
  const [searchQuery, setSearchQuery] = useState('')
  const [selectedFilter, setSelectedFilter] = useState('all')

  // Filtered and searched categories
  const displayedCategories = categories
    .filter(cat => cat.name.toLowerCase().includes(searchQuery.toLowerCase()))
    .filter(cat => selectedFilter === 'all' || cat.type === selectedFilter)

  return (
    <>
      <SearchBar query={searchQuery} onQueryChange={setSearchQuery} />
      <FilterButtons selected={selectedFilter} onFilterChange={setSelectedFilter} />
      <CategoryList categories={displayedCategories} />
    </>
  )
}
```

**Benefits of lifting state:**
- ‚úÖ Single source of truth (one place for `filter` state)
- ‚úÖ Synchronized (both components always in sync)
- ‚úÖ Testable (can test parent with both children together)
- ‚úÖ Predictable (clear data flow)

**The React mindset:**
> "When two components need to coordinate, move their state to their common parent."

We'll see this pattern everywhere in React: authentication, forms, filters, modals, and more.

---

## Empty State

Always handle the "no data" case for good UX.

```tsx
export function CategoriesPage() {
  const categories: Category[] = []

  if (categories.length === 0) {
    return (
      <div className="container mx-auto px-4 py-8">
        <div className="text-center py-12">
          <div className="text-6xl mb-4">üìÅ</div>
          <h2 className="text-2xl font-bold text-slate-300 mb-2">
            No categories yet
          </h2>
          <p className="text-slate-500">
            Categories will appear here once created
          </p>
        </div>
      </div>
    )
  }

  return (
    <div className="container mx-auto px-4 py-8">
      <h1 className="text-3xl font-bold text-slate-100 mb-6">
        Forum Categories
      </h1>
      <div className="grid gap-4 md:grid-cols-2 lg:grid-cols-3">
        {categories.map((category) => (
          <CategoryCard key={category.id} category={category} />
        ))}
      </div>
    </div>
  )
}
```

**Pattern: Early return**
- Check error/empty states first
- Return early
- Main logic stays unindented

---

## Advanced: useReducer for Complex Filters

**Problem:** Multiple filters (search, sort, visibility) with interdependent state.

**Without useReducer:**
```tsx
const [searchQuery, setSearchQuery] = useState('')
const [sortBy, setSortBy] = useState('name')
const [showArchived, setShowArchived] = useState(false)
const [showEmpty, setShowEmpty] = useState(true)
// 4 separate state variables = hard to manage!
```

**With useReducer:**
```tsx
const [filters, dispatch] = useReducer(filterReducer, initialFilters)
// Single state object = easier to manage!
```

### What is useReducer?

`useReducer` is like `useState` but for **complex state logic**. Instead of calling `setState`, you dispatch **actions** that describe what happened.

**Analogy:** Redux for a single component.

### How It Works

```tsx
import { useReducer } from 'react'

/**
 * Reducer function: Takes current state and action, returns new state
 * 
 * Pure function: Same input ‚Üí Same output
 */
function filterReducer(state, action) {
  switch (action.type) {
    case 'SET_SEARCH':
      return { ...state, searchQuery: action.payload }
    
    case 'SET_SORT':
      return { ...state, sortBy: action.payload }
    
    case 'TOGGLE_ARCHIVED':
      return { ...state, showArchived: !state.showArchived }
    
    case 'RESET':
      return initialFilters
    
    default:
      return state
  }
}

/**
 * Initial state
 */
const initialFilters = {
  searchQuery: '',
  sortBy: 'name',
  showArchived: false,
  showEmpty: true,
}

function CategoriesPage() {
  /**
   * useReducer returns [state, dispatch]
   * - state: Current filter values
   * - dispatch: Function to send actions
   */
  const [filters, dispatch] = useReducer(filterReducer, initialFilters)

  return (
    <div>
      {/* Search input */}
      <input
        value={filters.searchQuery}
        onChange={(e) => dispatch({
          type: 'SET_SEARCH',
          payload: e.target.value
        })}
        placeholder="Search categories..."
      />

      {/* Sort dropdown */}
      <select
        value={filters.sortBy}
        onChange={(e) => dispatch({
          type: 'SET_SORT',
          payload: e.target.value
        })}
      >
        <option value="name">Name</option>
        <option value="threads">Thread Count</option>
        <option value="recent">Recently Updated</option>
      </select>

      {/* Checkbox */}
      <label>
        <input
          type="checkbox"
          checked={filters.showArchived}
          onChange={() => dispatch({ type: 'TOGGLE_ARCHIVED' })}
        />
        Show Archived
      </label>

      {/* Reset button */}
      <button onClick={() => dispatch({ type: 'RESET' })}>
        Reset Filters
      </button>

      {/* Apply filters */}
      {filteredCategories.map(cat => (
        <CategoryCard key={cat.id} category={cat} />
      ))}
    </div>
  )
}
```

### useReducer vs useState

| Aspect | useState | useReducer |
|--------|----------|-----------|
| **State** | Single value | Complex object |
| **Updates** | Direct (setX) | Actions (dispatch) |
| **Logic** | Inline | Centralized |
| **Best for** | Simple state | Multiple related states |
| **Testability** | Hard | Easy (pure function) |

**Use useReducer when:**
- ‚úÖ Multiple state variables
- ‚úÖ Complex state transitions
- ‚úÖ State depends on previous state
- ‚úÖ Want to optimize performance

**Use useState when:**
- ‚úÖ Single value
- ‚úÖ Simple updates
- ‚úÖ No dependencies between states

### Complete Example with Filtering

```tsx
function CategoriesPage() {
  const [categories] = useState<Category[]>([
    { id: '1', name: 'General', threadCount: 45 },
    { id: '2', name: 'Technical', threadCount: 0 },
    { id: '3', name: 'Announcements', threadCount: 12 },
  ])

  const [filters, dispatch] = useReducer(filterReducer, initialFilters)

  /**
   * Apply filters to categories
   */
  const filteredCategories = categories.filter(cat => {
    // Search filter
    if (filters.searchQuery && !cat.name.toLowerCase().includes(filters.searchQuery.toLowerCase())) {
      return false
    }

    // Hide empty categories
    if (!filters.showEmpty && cat.threadCount === 0) {
      return false
    }

    return true
  })

  /**
   * Sort categories
   */
  const sortedCategories = [...filteredCategories].sort((a, b) => {
    switch (filters.sortBy) {
      case 'threads':
        return b.threadCount - a.threadCount
      case 'recent':
        return new Date(b.updatedAt).getTime() - new Date(a.updatedAt).getTime()
      case 'name':
      default:
        return a.name.localeCompare(b.name)
    }
  })

  return (
    <div className="space-y-4">
      {/* Filter controls */}
      <div className="flex gap-4">
        <input
          value={filters.searchQuery}
          onChange={(e) => dispatch({
            type: 'SET_SEARCH',
            payload: e.target.value
          })}
          placeholder="Search..."
          className="px-3 py-2 bg-slate-900 border border-slate-700 rounded"
        />

        <select
          value={filters.sortBy}
          onChange={(e) => dispatch({
            type: 'SET_SORT',
            payload: e.target.value
          })}
          className="px-3 py-2 bg-slate-900 border border-slate-700 rounded"
        >
          <option value="name">Sort by Name</option>
          <option value="threads">Sort by Threads</option>
        </select>

        <button
          onClick={() => dispatch({ type: 'RESET' })}
          className="px-4 py-2 bg-slate-700 rounded hover:bg-slate-600"
        >
          Reset
        </button>
      </div>

      {/* Results */}
      <div className="grid gap-4">
        {sortedCategories.map(cat => (
          <CategoryCard key={cat.id} category={cat} />
        ))}
      </div>

      {sortedCategories.length === 0 && (
        <p className="text-slate-400">No categories match your filters</p>
      )}
    </div>
  )
}
```

### Key Benefits

‚úÖ **Centralized logic** - All filter logic in one place
‚úÖ **Testable** - Reducer is a pure function
‚úÖ **Scalable** - Easy to add new filters
‚úÖ **Debuggable** - Can log all actions
‚úÖ **Reusable** - Same reducer in multiple components

---

## Testing Your Component

```tsx
// src/components/categories/__tests__/CategoryCard.test.tsx

import { render, screen } from '@testing-library/react'
import { BrowserRouter } from 'react-router-dom'
import { CategoryCard } from '../CategoryCard'
import type { Category } from '@/types'

const mockCategory: Category = {
  id: '01HXQK9Z3XAMPLE000001',
  name: 'General Discussion',
  slug: 'general-discussion',
  description: 'General topics',
  parentId: null,
  order: 1,
  threadCount: 42,
  createdAt: '2024-01-15T10:00:00Z',
  updatedAt: '2024-01-15T10:00:00Z',
}

describe('CategoryCard', () => {
  it('renders category name', () => {
    render(
      <BrowserRouter>
        <CategoryCard category={mockCategory} />
      </BrowserRouter>
    )

    expect(screen.getByText('General Discussion')).toBeInTheDocument()
  })

  it('renders thread count', () => {
    render(
      <BrowserRouter>
        <CategoryCard category={mockCategory} />
      </BrowserRouter>
    )

    expect(screen.getByText(/42 threads/i)).toBeInTheDocument()
  })

  it('renders description when provided', () => {
    render(
      <BrowserRouter>
        <CategoryCard category={mockCategory} />
      </BrowserRouter>
    )

    expect(screen.getByText('General topics')).toBeInTheDocument()
  })

  it('does not render description when null', () => {
    const categoryWithoutDesc = { ...mockCategory, description: null }
    
    render(
      <BrowserRouter>
        <CategoryCard category={categoryWithoutDesc} />
      </BrowserRouter>
    )

    expect(screen.queryByText('General topics')).not.toBeInTheDocument()
  })
})
```

---

## Advanced: Server Components (React 19)

**Problem**: The above example fetches categories on the client with `useEffect`. This causes:
- ‚ùå Waterfall: Page renders ‚Üí JS loads ‚Üí Fetch starts
- ‚ùå Large bundle: Fetch code sent to browser
- ‚ùå Slow first paint: Content loads after JS executes

**Solution**: Use Server Components to fetch on the server.

### Server Component Version

```tsx
// app/categories/page.tsx (Server Component)
// This code NEVER reaches the browser!

import db from '@/lib/database'
import { CategoryCard } from '@/components/categories/CategoryCard'

/**
 * Server Component: Fetch categories on server
 * 
 * Benefits:
 * - ‚úÖ Fetch happens before page renders
 * - ‚úÖ No loading state needed
 * - ‚úÖ Direct database access (no API)
 * - ‚úÖ Smaller bundle (no fetch code)
 * - ‚úÖ Faster first paint
 */
async function CategoriesPage() {
  // Fetch directly from database
  // This runs on server, not in browser!
  const categories = await db.categories.findAll()

  if (categories.length === 0) {
    return (
      <div className="container mx-auto px-4 py-8">
        <div className="text-center py-12">
          <div className="text-6xl mb-4">üìÅ</div>
          <h2 className="text-2xl font-bold text-slate-300 mb-2">
            No categories yet
          </h2>
          <p className="text-slate-500">
            Categories will appear here once created
          </p>
        </div>
      </div>
    )
  }

  return (
    <div className="container mx-auto px-4 py-8">
      <h1 className="text-3xl font-bold text-slate-100 mb-6">
        Forum Categories
      </h1>
      
      <div className="grid gap-4 md:grid-cols-2 lg:grid-cols-3">
        {categories.map((category) => (
          <CategoryCard key={category.id} category={category} />
        ))}
      </div>
    </div>
  )
}

export default CategoriesPage
```

### Client Component (Unchanged)

```tsx
// components/categories/CategoryCard.tsx (Client Component)
// This still runs in browser (for interactivity)

'use client'

import { Link } from 'react-router-dom'
import type { Category } from '@/types'

/**
 * Client Component: Display category card
 * 
 * Receives data from Server Component as props
 * Handles interactivity (clicking, hovering)
 */
export function CategoryCard({ category }: { category: Category }) {
  return (
    <Link
      to={`/categories/${category.slug}`}
      className="block p-4 bg-slate-900 border border-slate-700 rounded-lg hover:border-blue-500 transition-colors"
    >
      <div className="flex items-start justify-between">
        <div className="flex-1">
          <h3 className="text-lg font-semibold text-slate-100">
            {category.name}
          </h3>
          {category.description && (
            <p className="text-sm text-slate-400 mt-1">
              {category.description}
            </p>
          )}
        </div>
        <div className="text-right ml-4">
          <div className="text-2xl font-bold text-blue-400">
            {category.threadCount}
          </div>
          <div className="text-xs text-slate-500">threads</div>
        </div>
      </div>
    </Link>
  )
}
```

### Performance Comparison

**Client-Side Fetching (OLD):**
```
t=0ms:    Browser loads page
t=100ms:  JS downloaded and parsed
t=150ms:  React renders (empty)
t=200ms:  Fetch starts
t=350ms:  Data arrives
t=400ms:  Content visible
Total: 400ms ‚ùå
```

**Server Components (NEW):**
```
t=0ms:    Server receives request
t=50ms:   Fetch from database
t=100ms:  Render to HTML
t=150ms:  Browser receives HTML
t=150ms:  Content visible ‚úÖ
Total: 150ms (2.7x faster!)
```

### Key Differences

| Aspect | Client-Side | Server Components |
|--------|------------|-------------------|
| **Fetch location** | Browser | Server |
| **Loading state** | Needed | Not needed |
| **First paint** | After fetch | Before fetch |
| **Bundle size** | Larger | Smaller |
| **Database access** | Via API | Direct |
| **Code sent to browser** | Fetch logic | None |

### Migration Steps

1. **Convert to Server Component**
   - Remove `'use client'` directive
   - Remove `useState`, `useEffect`
   - Add `async` to component function
   - Fetch data directly

2. **Keep Client Components for Interactivity**
   - Add `'use client'` to interactive components
   - Receive data as props from Server Component
   - Handle user interactions

3. **Compose Together**
   - Server Component fetches data
   - Passes data to Client Components
   - Client Components handle interactivity

---

## Summary: What We Learned

### React Concepts Covered
1. **Components**: JavaScript functions that return JSX
2. **Props**: Data passed from parent to child (immutable)
3. **JSX**: HTML-like syntax in JavaScript
4. **Lists**: Use `.map()` with unique `key` props
5. **Conditional rendering**: `&&` operator for show/hide
6. **Composition**: Break UI into smaller components

### Best Practices Applied
- ‚úÖ TypeScript interfaces for props
- ‚úÖ Semantic HTML (`h1`, `h3`, `Link`)
- ‚úÖ Accessible markup
- ‚úÖ Empty states for better UX
- ‚úÖ Single responsibility per component
- ‚úÖ Test coverage

---

## Next: Create Category

Now that we can **display** categories, let's learn how to **create** them. This introduces:
- `useState` hook (React's memory)
- Forms and controlled components
- React Hook Form + Zod validation
- API calls with error handling

Continue to [Create Category ‚Üí](/en/react/3.categories-module/2.create-category)
