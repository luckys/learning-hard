---
title: Create Category - Forms & State Management
description: Master React's most important hook (useState), form handling patterns, validation, and API integration. Build production-ready forms with React Hook Form and Zod.
---

# Disclaimer

:::u-alert
---
title: Comments in the code are for educational purposes only.
description: In real projects, avoid adding irrelevant or redundant comments.
color: warning
variant: subtle
icon: i-lucide-triangle-alert
---
:::

Now we add **interactivity** to our forum. Creating categories requires forms - one of the most complex parts of React. We'll learn state management, validation, and API integration through a real-world example.

---

## What We're Building

A production-ready category creation form with:
- Name field (3-50 characters, alphanumeric + spaces/hyphens)
- Description field (optional, max 200 characters)
- Parent category selector (for nested categories)
- Real-time validation with error messages
- Loading states during submission
- Error handling and recovery
- Success feedback
- Optimistic UI updates

**Visual:**
```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚ Create New Category                 â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚ Category Name *                     â”‚
â”‚ [Enter category name...] âœ“          â”‚
â”‚ 3-50 characters, alphanumeric       â”‚
â”‚                                     â”‚
â”‚ Description                         â”‚
â”‚ [Optional description...] âœ“         â”‚
â”‚ 0/200 characters                    â”‚
â”‚                                     â”‚
â”‚ Parent Category                     â”‚
â”‚ [Select parent...] â–¼                â”‚
â”‚                                     â”‚
â”‚ [Cancel] [Create Category]          â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

---

## React State: Component Memory

**The core problem:** React components are functions. Functions are stateless - they run, return JSX, then disappear. How do we remember user input between renders?

**The solution:** `useState` hook - React's way of adding memory to functions.

### Without State: The Problem

```tsx
// âŒ This doesn't work!
function CreateCategoryForm() {
  let name = ''  // Regular variable - lost after render
  
  return (
    <input
      value={name}
      onChange={(e) => {
        name = e.target.value  // Updates variable
        // But React doesn't know!
        // No re-render happens
        // Input stays empty!
      }}
    />
  )
}
```

**Why doesn't it work?**
1. Component renders: `name = ''`
2. User types in input: `name = 'General'` (in memory)
3. Component re-renders: `name = ''` (reset to initial!)
4. Input shows empty string again

**The cycle repeats infinitely** - React doesn't know to re-render when `name` changes.

### With State: The Solution

```tsx
import { useState } from 'react'

function CreateCategoryForm() {
  /**
   * useState: Add memory to function component
   * 
   * Returns: [currentValue, functionToUpdate]
   * 
   * React remembers the value between renders!
   */
  const [name, setName] = useState('')

  return (
    <input
      value={name}
      onChange={(e) => {
        setName(e.target.value)  // Tell React to update
      }}
    />
  )
}
```

**Now it works:**
1. Component renders: `name = ''`
2. User types: `setName('General')` called
3. React schedules re-render with `name = 'General'`
4. Component re-renders: `name = 'General'`
5. Input shows 'General'!

### useState: Deep Dive

**Signature:**
```tsx
const [state, setState] = useState(initialValue)
```

**Parameters:**
- `initialValue`: The starting value (any type)

**Returns:**
- `state`: Current value
- `setState`: Function to update it

**Execution flow:**
```tsx
const [count, setCount] = useState(0)

// Render 1: count = 0
console.log(count)  // 0

// User clicks button
setCount(1)

// React schedules re-render

// Render 2: count = 1
console.log(count)  // 1

// User clicks again
setCount(2)

// Render 3: count = 2
console.log(count)  // 2
```

### Key Insight: Closure

React uses **closures** to remember state between renders.

```tsx
function Component() {
  const [count, setCount] = useState(0)
  
  // This function "closes over" the count variable
  // It remembers count even after Component returns
  const handleClick = () => {
    console.log(count)  // Can access count!
  }
  
  return <button onClick={handleClick}>Click</button>
}
```

**How React does it:**
```
Render 1:
  count = 0
  handleClick = () => console.log(0)  // Closes over count=0
  
Render 2:
  count = 1
  handleClick = () => console.log(1)  // Closes over count=1
```

---

## Rules of Hooks: The Contract

Before using multiple hooks, we need to understand React's rules. Break these rules and your app WILL crash.

### Rule #1: Only Call Hooks at the Top Level

**âŒ WRONG: Hook inside condition**
```tsx
function CreateCategoryForm() {
  if (someCondition) {
    const [name, setName] = useState('')  // ERROR!
  }
  
  return <div>{/* ... */}</div>
}
```

**âŒ WRONG: Hook inside loop**
```tsx
function CreateCategoryForm() {
  for (let i = 0; i < 3; i++) {
    const [value, setValue] = useState('')  // ERROR!
  }
  
  return <div>{/* ... */}</div>
}
```

**âŒ WRONG: Hook inside callback**
```tsx
function CreateCategoryForm() {
  const handleSubmit = () => {
    const [submitted, setSubmitted] = useState(false)  // ERROR!
  }
  
  return <div>{/* ... */}</div>
}
```

**âœ… CORRECT: Hook at top level**
```tsx
function CreateCategoryForm() {
  const [name, setName] = useState('')
  const [description, setDescription] = useState('')
  
  if (someCondition) {
    // Use the state here âœ…
    return <div>{name}</div>
  }
  
  return <form>{/* ... */}</form>
}
```

**Why this rule exists:**

React relies on the **order** hooks are called to track state between renders.

```tsx
// React's internal state array
[
  '', // name (useState #1)
  '', // description (useState #2)
  false, // isSubmitting (useState #3)
]
```

React matches hooks by **position**:
```tsx
const [name, setName] = useState('')  // Slot 0
const [description, setDescription] = useState('')  // Slot 1
const [isSubmitting, setIsSubmitting] = useState(false)  // Slot 2
```

**What breaks if you use hooks conditionally:**

```tsx
// Render 1:
const [name, setName] = useState('')  // Slot 0 âœ…
if (true) {
  const [temp, setTemp] = useState('x')  // Slot 1 âœ…
}
const [description, setDescription] = useState('')  // Slot 2 âœ…

// Render 2:
const [name, setName] = useState('')  // Slot 0 âœ…
if (false) {  // Condition changed!
  const [temp, setTemp] = useState('x')  // Slot 1 SKIPPED! âš ï¸
}
const [description, setDescription] = useState('')  // Slot 1 âŒ (was 2!)

// React thinks description is in slot 1 now
// But slot 1 had temp's value from before
// State is CORRUPTED! ğŸ’¥
```

**Visual example:**
```
Render 1:     Render 2 (if false):
â”Œâ”€â”€â”€â”€â”€â”       â”Œâ”€â”€â”€â”€â”€â”
â”‚ nameâ”‚       â”‚ nameâ”‚ â† Still slot 0 âœ…
â”œâ”€â”€â”€â”€â”€â”¤       â”œâ”€â”€â”€â”€â”€â”¤
â”‚ tempâ”‚       â”‚ descâ”‚ â† Now slot 1 (was 2) âŒ
â”œâ”€â”€â”€â”€â”€â”¤       â””â”€â”€â”€â”€â”€â”˜
â”‚ descâ”‚ â† Was slot 2
â””â”€â”€â”€â”€â”€â”˜

ğŸ”¥ description gets temp's old value!
```

### Rule #2: Only Call Hooks from React Functions

**âŒ WRONG: Hook in regular function**
```tsx
function validateForm() {
  const [isValid, setIsValid] = useState(true)  // ERROR!
  return isValid
}

function CreateCategoryForm() {
  const valid = validateForm()  // Won't work
  return <div>{/* ... */}</div>
}
```

**âœ… CORRECT: Hook in React component**
```tsx
function CreateCategoryForm() {
  const [isValid, setIsValid] = useState(true)  // âœ…
  return <div>{/* ... */}</div>
}
```

**âœ… CORRECT: Hook in custom hook**
```tsx
function useFormValidation() {
  const [isValid, setIsValid] = useState(true)  // âœ…
  return { isValid, setIsValid }
}

function CreateCategoryForm() {
  const { isValid } = useFormValidation()  // âœ…
  return <div>{/* ... */}</div>
}
```

**Why this rule exists:**

React tracks hooks by **component instance**. Regular functions don't have component instances, so React can't track their hooks.

**Only these can use hooks:**
- âœ… Function components (`function MyComponent() {}`)
- âœ… Custom hooks (`function useMyHook() {}`)

**These CANNOT use hooks:**
- âŒ Regular JavaScript functions
- âŒ Class methods
- âŒ Event handlers (unless they're inside a component)
- âŒ useEffect callbacks (can't nest hooks)

### How to Remember the Rules

**Think of hooks like a checklist:**

Every render, React goes through your component line by line:
```
âœ“ First useState call  â†’ Slot 0
âœ“ Second useState call â†’ Slot 1
âœ“ First useEffect call â†’ Slot 2
âœ“ Third useState call  â†’ Slot 3
```

If the order changes between renders, React gets confused:
```
âœ“ First useState call  â†’ Slot 0 âœ…
âœ— SKIPPED (was in if-block)
âœ“ Second useState call â†’ Slot 1 âŒ (was Slot 2!)
```

**Mental model:**
> "Hooks are like a numbered list. Every render must check the same boxes in the same order."

### ESLint Plugin: Automatic Enforcement

Instead of remembering rules, let ESLint enforce them:

```bash
npm install eslint-plugin-react-hooks --save-dev
```

```json
// .eslintrc.json
{
  "plugins": ["react-hooks"],
  "rules": {
    "react-hooks/rules-of-hooks": "error",
    "react-hooks/exhaustive-deps": "warn"
  }
}
```

Now ESLint will catch all hook violations at compile time!

---

## Multiple State Variables

Forms usually have multiple fields. We can use multiple `useState` calls:

```tsx
function CreateCategoryForm() {
  const [name, setName] = useState('')
  const [description, setDescription] = useState('')
  const [parentId, setParentId] = useState<string | null>(null)
  const [isSubmitting, setIsSubmitting] = useState(false)
  const [error, setError] = useState<string | null>(null)
  
  // Now we have 5 separate state variables
  // Each manages one piece of data
}
```

**Or group related state:**

```tsx
function CreateCategoryForm() {
  const [formData, setFormData] = useState({
    name: '',
    description: '',
    parentId: null as string | null,
  })
  
  const [isSubmitting, setIsSubmitting] = useState(false)
  const [error, setError] = useState<string | null>(null)
  
  // Fewer state variables, but need to spread when updating
  const updateField = (field: string, value: any) => {
    setFormData(prev => ({
      ...prev,
      [field]: value
    }))
  }
}
```

**When to use which?**
- **Multiple `useState`**: Simple forms, independent fields
- **Single object**: Complex forms, related fields, easier to pass around

---

## Controlled Components

A **controlled component** is one where React controls the input value.

```tsx
// âœ… Controlled: React controls the value
function Input() {
  const [value, setValue] = useState('')
  
  return (
    <input
      value={value}  // React controls this
      onChange={(e) => setValue(e.target.value)}
    />
  )
}

// âŒ Uncontrolled: DOM controls the value
function Input() {
  const inputRef = useRef<HTMLInputElement>(null)
  
  return (
    <input ref={inputRef} />  // DOM controls this
  )
}
```

**Controlled components:**
- âœ… Easy to validate in real-time
- âœ… Easy to disable submit button
- âœ… Easy to reset form
- âœ… Easy to test
- âŒ More verbose (need state + onChange)

**Uncontrolled components:**
- âœ… Less code
- âœ… Better performance (no re-renders on keystroke)
- âŒ Harder to validate
- âŒ Harder to test
- âŒ Harder to reset

**Best practice:** Use controlled components for forms (React Hook Form handles this for us).

---

## Form Validation: The Pyramid

Validation happens at multiple levels:

```
        â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
        â”‚  Server-side    â”‚ (Final check, can't trust client)
        â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
        â”‚  API Response   â”‚ (Catch server errors)
        â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
        â”‚  Submit Handler â”‚ (Before sending to API)
        â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
        â”‚  Real-time      â”‚ (As user types)
        â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
        â”‚  HTML5 Native   â”‚ (type="email", required, etc.)
        â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

**Each level catches different errors:**
- **HTML5**: Catches obvious mistakes (empty required, invalid email)
- **Real-time**: Catches validation errors as user types
- **Submit**: Final check before API call
- **API Response**: Catches server-side errors (duplicate name, permission denied)
- **Server**: Final security check (can't trust client)

---

## Zod: Schema Validation

**Zod** is a TypeScript-first schema validation library. It validates data AND generates types.

```typescript
// src/features/categories/schemas.ts

import { z } from 'zod'

/**
 * Schema: Blueprint for valid data
 * 
 * Defines:
 * - What fields exist
 * - What type each field is
 * - Validation rules for each field
 * - Error messages
 */
export const createCategorySchema = z.object({
  name: z
    .string('Name must be a string')
    .min(3, 'Name must be at least 3 characters')
    .max(50, 'Name must be at most 50 characters')
    .regex(
      /^[a-zA-Z0-9\s\-]+$/,
      'Name can only contain letters, numbers, spaces, and hyphens'
    ),
  
  description: z
    .string()
    .max(200, 'Description must be at most 200 characters')
    .optional()
    .or(z.literal('')),  // Allow empty string as "not provided"
  
  parentId: z
    .string('Parent ID must be a string')
    .uuid('Parent ID must be a valid UUID')
    .nullable()
    .optional(),
})

/**
 * Generate TypeScript type from schema
 * 
 * This creates a type that matches the schema.
 * If schema changes, type automatically updates!
 */
export type CreateCategoryInput = z.infer<typeof createCategorySchema>

// TypeScript now knows:
// type CreateCategoryInput = {
//   name: string
//   description?: string
//   parentId?: string | null
// }
```

**Why Zod?**
- âœ… Single source of truth (schema + types)
- âœ… Runtime validation (catches bad data from API)
- âœ… TypeScript integration (autocomplete, type safety)
- âœ… Reusable on client AND server
- âœ… Clear error messages

---

## React Hook Form: Production Forms

**React Hook Form** manages form state efficiently. It's the industry standard.

```tsx
// src/features/categories/components/CreateCategoryForm.tsx

import { useForm } from 'react-hook-form'
import { zodResolver } from '@hookform/resolvers/zod'
import { createCategorySchema, type CreateCategoryInput } from '../schemas'
import { apiClient } from '@/lib/api-client'
import { toast } from '@/lib/toast'
import type { Category } from '@/types'

interface CreateCategoryFormProps {
  onSuccess: (category: Category) => void
  existingCategories: Category[]
}

/**
 * CreateCategoryForm - Production-ready form
 * 
 * Uses React Hook Form for:
 * - State management
 * - Validation
 * - Error handling
 * - Performance optimization
 * 
 * Uses Zod for:
 * - Schema validation
 * - Type generation
 * - Error messages
 */
export function CreateCategoryForm({
  onSuccess,
  existingCategories,
}: CreateCategoryFormProps) {
  /**
   * useForm: Initialize form
   * 
   * Returns:
   * - register: Function to register inputs
   * - handleSubmit: Wrapper for submit handler
   * - formState: Contains errors, isSubmitting, etc.
   * - reset: Reset form to initial state
   * - watch: Watch field values
   * - setValue: Programmatically set field value
   */
  const {
    register,
    handleSubmit,
    formState: { errors, isSubmitting },
    reset,
    watch,
  } = useForm<CreateCategoryInput>({
    /**
     * zodResolver: Connect Zod schema to React Hook Form
     * 
     * Automatically validates form against schema.
     * Only calls onSubmit if validation passes.
     */
    resolver: zodResolver(createCategorySchema),
    
    /**
     * defaultValues: Initial form state
     */
    defaultValues: {
      name: '',
      description: '',
      parentId: null,
    },
    
    /**
     * mode: When to validate
     * - 'onBlur': Validate when field loses focus
     * - 'onChange': Validate on every keystroke
     * - 'onSubmit': Only validate on form submit
     * - 'onTouched': Validate after first blur
     */
    mode: 'onBlur',
  })

  /**
   * watch: Get current field values
   * 
   * Useful for:
   * - Showing character count
   * - Conditional rendering
   * - Dependent field validation
   */
  const nameValue = watch('name')
  const descriptionValue = watch('description')

  /**
   * onSubmit: Handle form submission
   * 
   * Only called if validation passes!
   * data is already validated and typed.
   */
  const onSubmit = async (data: CreateCategoryInput) => {
    try {
      /**
       * Call API to create category
       */
      const response = await apiClient.post<Category>('/categories', data)
      
      /**
       * Show success message
       */
      toast.success('Category created successfully!')
      
      /**
       * Reset form
       */
      reset()
      
      /**
       * Notify parent component
       */
      onSuccess(response.data)
    } catch (error) {
      /**
       * Handle API errors
       */
      if (error instanceof Error) {
        toast.error(error.message)
      } else {
        toast.error('Failed to create category')
      }
    }
  }

  return (
    <form onSubmit={handleSubmit(onSubmit)} className="space-y-6">
      {/* Name Field */}
      <div>
        <label
          htmlFor="name"
          className="block text-sm font-medium text-slate-200 mb-2"
        >
          Category Name *
        </label>
        
        <input
          id="name"
          type="text"
          placeholder="e.g., General Discussion"
          {...register('name')}
          className={`
            w-full px-4 py-3 bg-slate-900 border rounded-lg text-slate-100
            placeholder-slate-500 focus:outline-none focus:ring-2
            transition-colors
            ${
              errors.name
                ? 'border-red-500 focus:ring-red-500'
                : 'border-slate-700 focus:border-blue-500 focus:ring-blue-500'
            }
          `}
        />
        
        {/* Error message */}
        {errors.name && (
          <p className="mt-2 text-sm text-red-400">{errors.name.message}</p>
        )}
        
        {/* Character count */}
        <p className="mt-2 text-xs text-slate-500">
          {nameValue?.length || 0} / 50 characters
        </p>
      </div>

      {/* Description Field */}
      <div>
        <label
          htmlFor="description"
          className="block text-sm font-medium text-slate-200 mb-2"
        >
          Description (optional)
        </label>
        
        <textarea
          id="description"
          placeholder="A brief description of this category's purpose..."
          rows={3}
          {...register('description')}
          className={`
            w-full px-4 py-3 bg-slate-900 border rounded-lg text-slate-100
            placeholder-slate-500 focus:outline-none focus:ring-2
            resize-none transition-colors
            ${
              errors.description
                ? 'border-red-500 focus:ring-red-500'
                : 'border-slate-700 focus:border-blue-500 focus:ring-blue-500'
            }
          `}
        />
        
        {errors.description && (
          <p className="mt-2 text-sm text-red-400">
            {errors.description.message}
          </p>
        )}
        
        <p className="mt-2 text-xs text-slate-500">
          {descriptionValue?.length || 0} / 200 characters
        </p>
      </div>

      {/* Parent Category Selector */}
      <div>
        <label
          htmlFor="parentId"
          className="block text-sm font-medium text-slate-200 mb-2"
        >
          Parent Category (optional)
        </label>
        
        <select
          id="parentId"
          {...register('parentId')}
          className={`
            w-full px-4 py-3 bg-slate-900 border rounded-lg text-slate-100
            focus:outline-none focus:ring-2 transition-colors
            ${
              errors.parentId
                ? 'border-red-500 focus:ring-red-500'
                : 'border-slate-700 focus:border-blue-500 focus:ring-blue-500'
            }
          `}
        >
          <option value="">None (Root Category)</option>
          
          {/* Only show root categories as parents */}
          {existingCategories
            .filter((cat) => cat.parentId === null)
            .map((category) => (
              <option key={category.id} value={category.id}>
                {category.name}
              </option>
            ))}
        </select>
        
        {errors.parentId && (
          <p className="mt-2 text-sm text-red-400">
            {errors.parentId.message}
          </p>
        )}
      </div>

      {/* Form Actions */}
      <div className="flex gap-3 pt-4">
        <button
          type="button"
          onClick={() => reset()}
          className="px-6 py-3 bg-slate-800 text-slate-200 rounded-lg hover:bg-slate-700 transition-colors font-medium"
        >
          Reset
        </button>
        
        <button
          type="submit"
          disabled={isSubmitting}
          className={`
            flex-1 px-6 py-3 rounded-lg font-medium transition-colors
            ${
              isSubmitting
                ? 'bg-blue-600/50 text-white cursor-not-allowed'
                : 'bg-blue-600 text-white hover:bg-blue-700'
            }
          `}
        >
          {isSubmitting ? 'Creating...' : 'Create Category'}
        </button>
      </div>
    </form>
  )
}
```

---

## API Integration

```typescript
// src/lib/api-client.ts

import axios from 'axios'

/**
 * API Client: Centralized HTTP requests
 * 
 * Benefits:
 * - Single place to configure requests
 * - Add auth tokens automatically
 * - Handle errors globally
 * - Retry logic
 * - Request/response interceptors
 */
export const apiClient = axios.create({
  baseURL: import.meta.env.VITE_API_URL || 'http://localhost:3001/api',
  headers: {
    'Content-Type': 'application/json',
  },
})

/**
 * Request interceptor: Add auth token
 */
apiClient.interceptors.request.use((config) => {
  const token = localStorage.getItem('auth_token')
  if (token) {
    config.headers.Authorization = `Bearer ${token}`
  }
  return config
})

/**
 * Response interceptor: Handle errors
 */
apiClient.interceptors.response.use(
  (response) => response,
  (error) => {
    // Handle 401 Unauthorized
    if (error.response?.status === 401) {
      localStorage.removeItem('auth_token')
      window.location.href = '/sign-in'
    }
    
    // Handle 403 Forbidden
    if (error.response?.status === 403) {
      error.message = 'You do not have permission to perform this action'
    }
    
    // Handle 500 Server Error
    if (error.response?.status >= 500) {
      error.message = 'Server error. Please try again later.'
    }
    
    return Promise.reject(error)
  }
)
```

---

## Toast Notifications

```typescript
// src/lib/toast.ts

import { toast as hotToast } from 'react-hot-toast'

/**
 * Toast: Non-blocking notifications
 * 
 * Show temporary messages to user without blocking interaction.
 * Perfect for success/error feedback.
 */
export const toast = {
  success: (message: string) => {
    hotToast.success(message, {
      duration: 3000,
      position: 'top-right',
    })
  },
  
  error: (message: string) => {
    hotToast.error(message, {
      duration: 4000,
      position: 'top-right',
    })
  },
  
  loading: (message: string) => {
    return hotToast.loading(message, {
      position: 'top-right',
    })
  },
}
```

---

## Testing the Form

```tsx
// src/features/categories/components/__tests__/CreateCategoryForm.test.tsx

import { render, screen, waitFor } from '@testing-library/react'
import userEvent from '@testing-library/user-event'
import { CreateCategoryForm } from '../CreateCategoryForm'
import { apiClient } from '@/lib/api-client'
import { vi } from 'vitest'

vi.mock('@/lib/api-client')

describe('CreateCategoryForm', () => {
  const mockOnSuccess = vi.fn()
  const mockCategories: Category[] = []

  beforeEach(() => {
    vi.clearAllMocks()
  })

  it('validates required name field', async () => {
    const user = userEvent.setup()
    
    render(
      <CreateCategoryForm
        onSuccess={mockOnSuccess}
        existingCategories={mockCategories}
      />
    )

    // Try to submit without filling name
    const submitButton = screen.getByRole('button', { name: /create category/i })
    await user.click(submitButton)

    // Should show validation error
    await waitFor(() => {
      expect(screen.getByText(/name must be at least 3 characters/i)).toBeInTheDocument()
    })

    // Should NOT call API
    expect(apiClient.post).not.toHaveBeenCalled()
  })

  it('submits valid form data', async () => {
    const user = userEvent.setup()
    const mockResponse = {
      data: {
        id: '01HXQK9Z3XAMPLE000001',
        name: 'Test Category',
        slug: 'test-category',
        description: 'Test description',
        parentId: null,
        order: 1,
        threadCount: 0,
        createdAt: '2024-01-15T10:00:00Z',
        updatedAt: '2024-01-15T10:00:00Z',
      },
    }
    
    vi.mocked(apiClient.post).mockResolvedValueOnce(mockResponse)

    render(
      <CreateCategoryForm
        onSuccess={mockOnSuccess}
        existingCategories={mockCategories}
      />
    )

    // Fill form
    await user.type(screen.getByLabelText(/category name/i), 'Test Category')
    await user.type(screen.getByLabelText(/description/i), 'Test description')

    // Submit
    await user.click(screen.getByRole('button', { name: /create category/i }))

    // Verify API call
    await waitFor(() => {
      expect(apiClient.post).toHaveBeenCalledWith('/categories', {
        name: 'Test Category',
        description: 'Test description',
        parentId: null,
      })
    })

    // Verify success callback
    expect(mockOnSuccess).toHaveBeenCalledWith(mockResponse.data)
  })
})
```

---

## Summary

### Key Concepts Learned

1. **useState**: Add memory to function components
   - Returns `[value, setter]`
   - Setter triggers re-render
   - State persists between renders

2. **Controlled Components**: React controls input value
   ```tsx
   <input value={state} onChange={(e) => setState(e.target.value)} />
   ```

3. **Validation Pyramid**: Multiple levels of validation
   - HTML5 native
   - Real-time
   - Submit handler
   - API response
   - Server-side

4. **Zod Schemas**: Single source of truth
   ```tsx
   const schema = z.object({ /* ... */ })
   type Data = z.infer<typeof schema>
   ```

5. **React Hook Form**: Production form management
   - Efficient state management
   - Built-in validation
   - Error handling
   - Performance optimized

### Best Practices

- âœ… Use controlled components for forms
- âœ… Validate at multiple levels
- âœ… Show clear error messages
- âœ… Provide loading states
- âœ… Use React Hook Form for complex forms
- âœ… Use Zod for schema validation
- âœ… Test form validation and submission
- âœ… Provide success/error feedback

### TypeScript Wins

```tsx
// Single source of truth
const schema = z.object({ name: z.string() })
type FormData = z.infer<typeof schema>

// TypeScript knows FormData shape
const onSubmit = (data: FormData) => {
  // data.name is definitely a string!
}
```

---

Next: [Edit Category â†’](/en/react/3.categories-module/3.edit-category)

// React schedules re-render
// Next render: count = 1
console.log(count)  // 1
```

**Key points:**
1. **State persists** between renders (unlike regular variables)
2. **Setting state triggers re-render**
3. **State is isolated** per component instance
4. **Initial value only used on first render**

---

## Form State Management

We need to track multiple form fields. We could use multiple `useState` calls:

```tsx
// âŒ Verbose approach
const [name, setName] = useState('')
const [description, setDescription] = useState('')
const [parentId, setParentId] = useState<string | null>(null)
```

Or use a single state object:

```tsx
// âœ… Better: Single state object
const [formData, setFormData] = useState({
  name: '',
  description: '',
  parentId: null as string | null,
})
```

**But** managing form state manually is tedious:
- Validation logic
- Error messages
- Touched fields
- Submission state

**Solution**: React Hook Form handles this for us.

---

## React Hook Form + Zod

React Hook Form manages form state efficiently. Zod provides runtime validation + TypeScript types.

### Install Dependencies

```bash
npm install react-hook-form @hookform/resolvers zod
```

### Define Validation Schema

```typescript
// src/features/categories/schemas.ts

import { z } from 'zod'

/**
 * Zod schema for category creation
 * 
 * Benefits:
 * 1. Runtime validation (catches bad data from API)
 * 2. TypeScript type generation
 * 3. Reusable on client + server
 */
export const createCategorySchema = z.object({
  name: z
    .string()
    .min(3, 'Name must be at least 3 characters')
    .max(50, 'Name must be at most 50 characters')
    .regex(/^[a-zA-Z0-9\s-]+$/, 'Name can only contain letters, numbers, spaces, and hyphens'),
  
  description: z
    .string()
    .max(200, 'Description must be at most 200 characters')
    .optional()
    .or(z.literal('')),  // Allow empty string
  
  parentId: z
    .string()
    .uuid('Invalid parent category')
    .nullable()
    .optional(),
})

// TypeScript type inferred from schema
export type CreateCategoryInput = z.infer<typeof createCategorySchema>
```

**Why this approach?**

1. **Single source of truth**: Schema defines both validation + types
2. **Runtime safety**: Validates data at runtime (catches API errors)
3. **Type safety**: TypeScript knows the shape
4. **Reusable**: Use same schema on server

**Zod Methods:**
- `.string()`: Must be a string
- `.min(3)`: Minimum length
- `.max(50)`: Maximum length
- `.regex()`: Must match pattern
- `.optional()`: Field is optional
- `.nullable()`: Can be null
- `.or()`: Alternative type

---

## useState for Form: Manual Approach

Before using React Hook Form, let's understand what it does by building it manually.

```tsx
function CreateCategoryFormManual() {
  // State for each field
  const [name, setName] = useState('')
  const [description, setDescription] = useState('')
  const [errors, setErrors] = useState<Record<string, string>>({})
  const [isSubmitting, setIsSubmitting] = useState(false)

  const handleSubmit = async (e: React.FormEvent) => {
    e.preventDefault()  // Prevent page reload
    setErrors({})  // Clear previous errors
    setIsSubmitting(true)

    try {
      // Validate with Zod
      const validData = createCategorySchema.parse({
        name,
        description,
        parentId: null,
      })

      // Call API
      const response = await apiClient.post('/categories', validData)
      
      // Success: redirect or show message
      console.log('Created:', response.data)
    } catch (error) {
      // Handle validation errors
      if (error instanceof z.ZodError) {
        const fieldErrors: Record<string, string> = {}
        error.errors.forEach((err) => {
          if (err.path[0]) {
            fieldErrors[err.path[0] as string] = err.message
          }
        })
        setErrors(fieldErrors)
      }
    } finally {
      setIsSubmitting(false)
    }
  }

  return (
    <form onSubmit={handleSubmit} className="space-y-4">
      {/* Name field */}
      <div>
        <label htmlFor="name" className="block text-sm font-medium text-slate-200">
          Category Name *
        </label>
        <input
          id="name"
          type="text"
          value={name}
          onChange={(e) => setName(e.target.value)}
          className="mt-1 block w-full rounded-md bg-slate-800 border-slate-700 text-slate-100"
        />
        {errors.name && (
          <p className="mt-1 text-sm text-red-500">{errors.name}</p>
        )}
      </div>

      {/* Description field */}
      <div>
        <label htmlFor="description" className="block text-sm font-medium text-slate-200">
          Description
        </label>
        <textarea
          id="description"
          value={description}
          onChange={(e) => setDescription(e.target.value)}
          rows={3}
          className="mt-1 block w-full rounded-md bg-slate-800 border-slate-700 text-slate-100"
        />
        {errors.description && (
          <p className="mt-1 text-sm text-red-500">{errors.description}</p>
        )}
      </div>

      {/* Submit button */}
      <button
        type="submit"
        disabled={isSubmitting}
        className="px-4 py-2 bg-blue-600 text-white rounded-md hover:bg-blue-700 disabled:opacity-50"
      >
        {isSubmitting ? 'Creating...' : 'Create Category'}
      </button>
    </form>
  )
}
```

**Problems with manual approach:**
- ğŸ˜« Repetitive boilerplate for each field
- ğŸ˜« Manual error state management
- ğŸ˜« No built-in touched/dirty tracking
- ğŸ˜« Re-renders on every keystroke (inefficient)

---

## React Hook Form: Production Approach

React Hook Form solves these problems with a cleaner API.

```tsx
// src/features/categories/components/CreateCategoryForm.tsx

import { useForm } from 'react-hook-form'
import { zodResolver } from '@hookform/resolvers/zod'
import { createCategorySchema, type CreateCategoryInput } from '../schemas'
import type { Category } from '@/types'

interface CreateCategoryFormProps {
  onSuccess: (category: Category) => void
  existingCategories: Category[]  // For parent selector
}

export function CreateCategoryForm({ onSuccess, existingCategories }: CreateCategoryFormProps) {
  /**
   * useForm hook from React Hook Form
   * 
   * Returns:
   * - register: Function to register inputs
   * - handleSubmit: Wrapper for submit handler
   * - formState: Contains errors, isSubmitting, etc.
   */
  const {
    register,
    handleSubmit,
    formState: { errors, isSubmitting },
    reset,
  } = useForm<CreateCategoryInput>({
    // zodResolver integrates Zod schema with React Hook Form
    resolver: zodResolver(createCategorySchema),
    
    // Default values
    defaultValues: {
      name: '',
      description: '',
      parentId: null,
    },
  })

  /**
   * Submit handler
   * 
   * Only called if validation passes!
   * Data is already validated and typed
   */
  const onSubmit = async (data: CreateCategoryInput) => {
    try {
      const response = await apiClient.post<Category>('/categories', data)
      
      // Success feedback
      toast.success('Category created successfully!')
      
      // Reset form
      reset()
      
      // Notify parent
      onSuccess(response.data)
    } catch (error) {
      // API error handling
      if (error instanceof Error) {
        toast.error(error.message)
      }
    }
  }

  return (
    <form onSubmit={handleSubmit(onSubmit)} className="space-y-6">
      {/* Name field */}
      <div>
        <label htmlFor="name" className="block text-sm font-medium text-slate-200">
          Category Name *
        </label>
        <input
          id="name"
          type="text"
          {...register('name')}  // Magic! Handles onChange, value, ref
          className="mt-1 block w-full rounded-md bg-slate-800 border-slate-700 text-slate-100 focus:border-blue-500 focus:ring-blue-500"
          placeholder="General Discussion"
        />
        {errors.name && (
          <p className="mt-1 text-sm text-red-500">{errors.name.message}</p>
        )}
      </div>

      {/* Description field */}
      <div>
        <label htmlFor="description" className="block text-sm font-medium text-slate-200">
          Description (optional)
        </label>
        <textarea
          id="description"
          {...register('description')}
          rows={3}
          className="mt-1 block w-full rounded-md bg-slate-800 border-slate-700 text-slate-100 focus:border-blue-500 focus:ring-blue-500"
          placeholder="A place for general topics and discussions"
        />
        {errors.description && (
          <p className="mt-1 text-sm text-red-500">{errors.description.message}</p>
        )}
      </div>

      {/* Parent category selector */}
      <div>
        <label htmlFor="parentId" className="block text-sm font-medium text-slate-200">
          Parent Category (optional)
        </label>
        <select
          id="parentId"
          {...register('parentId')}
          className="mt-1 block w-full rounded-md bg-slate-800 border-slate-700 text-slate-100 focus:border-blue-500 focus:ring-blue-500"
        >
          <option value="">None (Root Category)</option>
          {existingCategories
            .filter((cat) => cat.parentId === null)  // Only root categories can be parents
            .map((category) => (
              <option key={category.id} value={category.id}>
                {category.name}
              </option>
            ))}
        </select>
        {errors.parentId && (
          <p className="mt-1 text-sm text-red-500">{errors.parentId.message}</p>
        )}
      </div>

      {/* Actions */}
      <div className="flex gap-3">
        <button
          type="submit"
          disabled={isSubmitting}
          className="flex-1 px-4 py-2 bg-blue-600 text-white rounded-md hover:bg-blue-700 disabled:opacity-50 disabled:cursor-not-allowed transition-colors"
        >
          {isSubmitting ? 'Creating...' : 'Create Category'}
        </button>
        
        <button
          type="button"
          onClick={() => reset()}
          className="px-4 py-2 bg-slate-700 text-slate-200 rounded-md hover:bg-slate-600 transition-colors"
        >
          Reset
        </button>
      </div>
    </form>
  )
}
```

### How React Hook Form Works

**1. Registration:**
```tsx
{...register('name')}
```

Expands to:
```tsx
{
  name: 'name',
  onChange: (e) => handleChange(e),
  onBlur: (e) => handleBlur(e),
  ref: inputRef,
}
```

**2. Validation:**
- Happens on `submit` by default
- Zod schema validates data
- Only calls `onSubmit` if valid

**3. Error Display:**
```tsx
{errors.name && <p>{errors.name.message}</p>}
```

Errors object structure:
```tsx
{
  name?: { message: string },
  description?: { message: string },
  // ...
}
```

---

## API Integration

```typescript
// src/lib/api-client.ts

import axios from 'axios'

export const apiClient = axios.create({
  baseURL: import.meta.env.VITE_API_URL || 'http://localhost:3001/api',
  headers: {
    'Content-Type': 'application/json',
  },
})

// Add auth token to requests
apiClient.interceptors.request.use((config) => {
  const token = localStorage.getItem('auth_token')
  if (token) {
    config.headers.Authorization = `Bearer ${token}`
  }
  return config
})

// Handle errors globally
apiClient.interceptors.response.use(
  (response) => response,
  (error) => {
    if (error.response?.status === 401) {
      // Redirect to login
      window.location.href = '/sign-in'
    }
    return Promise.reject(error)
  }
)
```

---

## Toast Notifications

```typescript
// src/lib/toast.ts

import { toast as hotToast } from 'react-hot-toast'

export const toast = {
  success: (message: string) => {
    hotToast.success(message, {
      duration: 3000,
      position: 'top-right',
    })
  },
  
  error: (message: string) => {
    hotToast.error(message, {
      duration: 4000,
      position: 'top-right',
    })
  },
}
```

Install:
```bash
npm install react-hot-toast
```

Add to `App.tsx`:
```tsx
import { Toaster } from 'react-hot-toast'

function App() {
  return (
    <>
      <Toaster />
      {/* rest of app */}
    </>
  )
}
```

---

## Page Integration

```tsx
// src/pages/CreateCategoryPage.tsx

import { useState } from 'react'
import { useNavigate } from 'react-router-dom'
import { CreateCategoryForm } from '@/features/categories/components/CreateCategoryForm'
import type { Category } from '@/types'

export function CreateCategoryPage() {
  const navigate = useNavigate()
  const [categories, setCategories] = useState<Category[]>([])  // In real app, fetch from API

  const handleSuccess = (newCategory: Category) => {
    // Navigate back to categories list
    navigate('/categories')
  }

  return (
    <div className="container mx-auto px-4 py-8 max-w-2xl">
      <div className="mb-8">
        <h1 className="text-3xl font-bold text-slate-100 mb-2">
          Create Category
        </h1>
        <p className="text-slate-400">
          Add a new category to organize forum threads
        </p>
      </div>

      <div className="bg-slate-900 rounded-lg border border-slate-800 p-6">
        <CreateCategoryForm
          onSuccess={handleSuccess}
          existingCategories={categories}
        />
      </div>
    </div>
  )
}
```

---

## Testing the Form

```tsx
// src/features/categories/components/__tests__/CreateCategoryForm.test.tsx

import { render, screen, waitFor } from '@testing-library/react'
import userEvent from '@testing-library/user-event'
import { CreateCategoryForm } from '../CreateCategoryForm'
import { apiClient } from '@/lib/api-client'
import { vi } from 'vitest'

vi.mock('@/lib/api-client')

describe('CreateCategoryForm', () => {
  const mockOnSuccess = vi.fn()
  const mockCategories = []

  beforeEach(() => {
    vi.clearAllMocks()
  })

  it('validates required name field', async () => {
    const user = userEvent.setup()
    
    render(
      <CreateCategoryForm
        onSuccess={mockOnSuccess}
        existingCategories={mockCategories}
      />
    )

    // Try to submit without filling name
    const submitButton = screen.getByRole('button', { name: /create category/i })
    await user.click(submitButton)

    // Should show validation error
    await waitFor(() => {
      expect(screen.getByText(/name must be at least 3 characters/i)).toBeInTheDocument()
    })

    expect(apiClient.post).not.toHaveBeenCalled()
  })

  it('submits valid form data', async () => {
    const user = userEvent.setup()
    const mockResponse = {
      data: {
        id: '01HXQK9Z3XAMPLE000001',
        name: 'Test Category',
        slug: 'test-category',
        description: 'Test description',
        parentId: null,
        order: 1,
        threadCount: 0,
        createdAt: '2024-01-15T10:00:00Z',
        updatedAt: '2024-01-15T10:00:00Z',
      },
    }
    
    vi.mocked(apiClient.post).mockResolvedValueOnce(mockResponse)

    render(
      <CreateCategoryForm
        onSuccess={mockOnSuccess}
        existingCategories={mockCategories}
      />
    )

    // Fill form
    await user.type(screen.getByLabelText(/category name/i), 'Test Category')
    await user.type(screen.getByLabelText(/description/i), 'Test description')

    // Submit
    await user.click(screen.getByRole('button', { name: /create category/i }))

    // Verify API call
    await waitFor(() => {
      expect(apiClient.post).toHaveBeenCalledWith('/categories', {
        name: 'Test Category',
        description: 'Test description',
        parentId: null,
      })
    })

    // Verify success callback
    expect(mockOnSuccess).toHaveBeenCalledWith(mockResponse.data)
  })
})

---

## Custom Hooks: Reusable Logic

We've used many hooks (`useState`, `useForm`, etc.). Now let's create **our own hooks** to reuse logic across components.

### What is a Custom Hook?

A **custom hook** is a JavaScript function that:

1. **Name starts with `use`**: `useSomething` (required by React)
2. **Can use other hooks**: `useState`, `useEffect`, etc.
3. **Returns anything**: values, functions, objects
4. **Encapsulates reusable logic**: Don't repeat yourself

**Simple example:**

```tsx
// âŒ Repeating logic in every component
function CreateCategoryForm() {
  const [isLoading, setIsLoading] = useState(false)
  const [error, setError] = useState(null)
  
  const submitForm = async (data) => {
    setIsLoading(true)
    setError(null)
    try {
      await apiClient.post('/categories', data)
    } catch (e) {
      setError(e.message)
    } finally {
      setIsLoading(false)
    }
  }
}

function EditCategoryForm() {
  const [isLoading, setIsLoading] = useState(false)
  const [error, setError] = useState(null)
  
  const submitForm = async (data) => {
    setIsLoading(true)
    setError(null)
    try {
      await apiClient.put('/categories/123', data)
    } catch (e) {
      setError(e.message)
    } finally {
      setIsLoading(false)
    }
  }
}

// âœ… Extract to custom hook
function useApiRequest() {
  const [isLoading, setIsLoading] = useState(false)
  const [error, setError] = useState(null)
  
  const execute = async (apiCall) => {
    setIsLoading(true)
    setError(null)
    try {
      return await apiCall()
    } catch (e) {
      setError(e.message)
      throw e
    } finally {
      setIsLoading(false)
    }
  }
  
  return { isLoading, error, execute }
}

// Now both components can use it:
function CreateCategoryForm() {
  const { isLoading, error, execute } = useApiRequest()
  
  const handleSubmit = (data) => {
    execute(() => apiClient.post('/categories', data))
  }
}
```

### Custom Hook for Form State

**Problem**: Managing form fields is repetitive.

```tsx
// âŒ Repetitive
const [name, setName] = useState('')
const [description, setDescription] = useState('')
const [parentId, setParentId] = useState(null)
```

**Solution**: Custom hook for form fields.

```tsx
// src/hooks/useFormField.ts

import { useState } from 'react'

/** 
 * useFormField - Manage a single form field
 * 
 * Returns:
 * - value: Current value
 * - setValue: Update function
 * - onChange: Handler for input onChange
 * - reset: Reset to initial value
 */
export function useFormField<T>(initialValue: T) {
  const [value, setValue] = useState<T>(initialValue)
  
  const onChange = (e: React.ChangeEvent<HTMLInputElement | HTMLTextAreaElement>) => {
    setValue(e.target.value as T)
  }
  
  const reset = () => {
    setValue(initialValue)
  }
  
  return {
    value,
    setValue,
    onChange,
    reset,
  }
}

// Usage:
function CreateCategoryForm() {
  const name = useFormField('')
  const description = useFormField('')
  
  return (
    <form>
      <input value={name.value} onChange={name.onChange} />
      <textarea value={description.value} onChange={description.onChange} />
      <button onClick={() => {
        name.reset()
        description.reset()
      }}>Reset</button>
    </form>
  )
}
```

### Custom Hook for Category Creation

Let's create a hook specific to our forum - creating categories:

```tsx
// src/features/categories/hooks/useCreateCategory.ts

import { useState } from 'react'
import { apiClient } from '@/lib/api-client'
import { toast } from '@/lib/toast'
import type { Category, CreateCategoryInput } from '@/types'

/** 
 * useCreateCategory - Handle category creation logic
 * 
 * Encapsulates:
 * - API call
 * - Loading state
 * - Error handling
 * - Success feedback
 * - Optimistic updates
 * 
 * Returns:
 * - createCategory: Function to call
 * - isCreating: Loading state
 * - error: Error if any
 * - reset: Clear error
 */
export function useCreateCategory() {
  const [isCreating, setIsCreating] = useState(false)
  const [error, setError] = useState<string | null>(null)

  const createCategory = async (data: CreateCategoryInput): Promise<Category | null> => {
    setIsCreating(true)
    setError(null)

    try {
      const response = await apiClient.post<Category>('/categories', data)
      
      // Success feedback
      toast.success(`Category "${data.name}" created!`)
      
      return response.data
    } catch (err) {
      const message = err instanceof Error ? err.message : 'Failed to create category'
      setError(message)
      toast.error(message)
      return null
    } finally {
      setIsCreating(false)
    }
  }

  const reset = () => {
    setError(null)
  }

  return {
    createCategory,
    isCreating,
    error,
    reset,
  }
}

// Usage in component:
function CreateCategoryForm({ onSuccess }) {
  const { createCategory, isCreating, error } = useCreateCategory()
  const { register, handleSubmit, formState } = useForm()

  const onSubmit = async (data) => {
    const newCategory = await createCategory(data)
    if (newCategory) {
      onSuccess(newCategory)
    }
  }

  return (
    <form onSubmit={handleSubmit(onSubmit)}>
      {/* Form fields */}
      {error && <p className="text-red-400">{error}</p>}
      <button disabled={isCreating}>
        {isCreating ? 'Creating...' : 'Create Category'}
      </button>
    </form>
  )
}
```

### Custom Hook with Multiple Hooks Inside

Custom hooks can use as many hooks as needed:

```tsx
// src/hooks/useCategoryForm.ts

import { useState, useEffect } from 'react'
import { useNavigate } from 'react-router-dom'
import { useForm } from 'react-hook-form'
import { zodResolver } from '@hookform/resolvers/zod'
import { createCategorySchema } from '../schemas'

/** 
 * useCategoryForm - Complete form logic
 * 
 * Combines multiple hooks:
 * - useState (loading, error)
 * - useForm (form state, validation)
 * - useNavigate (navigation after success)
 * - useEffect (cleanup on unmount)
 */
export function useCategoryForm(mode: 'create' | 'edit') {
  const navigate = useNavigate()
  const [isSubmitting, setIsSubmitting] = useState(false)
  const [serverError, setServerError] = useState<string | null>(null)

  const form = useForm({
    resolver: zodResolver(createCategorySchema),
    defaultValues: {
      name: '',
      description: '',
      parentId: null,
    },
  })

  // Cleanup on unmount
  useEffect(() => {
    return () => {
      form.reset()
      setServerError(null)
    }
  }, [])

  const handleSubmit = async (data) => {
    setIsSubmitting(true)
    setServerError(null)

    try {
      const endpoint = mode === 'create' ? '/categories' : `/categories/${data.id}`
      const method = mode === 'create' ? 'post' : 'put'
      
      await apiClient[method](endpoint, data)
      
      toast.success(`Category ${mode === 'create' ? 'created' : 'updated'}!`)
      navigate('/categories')
    } catch (error) {
      setServerError(error.message)
    } finally {
      setIsSubmitting(false)
    }
  }

  return {
    form,
    isSubmitting,
    serverError,
    handleSubmit,
  }
}
```

### When to Create Custom Hooks

âœ… **Create a custom hook when:**

- Logic is used in multiple components
- State management is complex
- You want to test logic separately
- Code becomes more readable

```tsx
// âœ… Good: Logic reused across components
function useWindowSize() {
  const [size, setSize] = useState({ width: 0, height: 0 })
  
  useEffect(() => {
    const handleResize = () => {
      setSize({ width: window.innerWidth, height: window.innerHeight })
    }
    
    window.addEventListener('resize', handleResize)
    handleResize()
    
    return () => window.removeEventListener('resize', handleResize)
  }, [])
  
  return size
}

// Now ANY component can check window size:
function Sidebar() {
  const { width } = useWindowSize()
  return width < 768 ? <MobileSidebar /> : <DesktopSidebar />
}
```

âŒ **Don't create a custom hook when:**

- Logic is only used once
- It's simpler to keep inline
- It doesn't use any hooks

```tsx
// âŒ Bad: Doesn't use hooks, just a helper function
function useFormatDate(date: string) {
  return new Date(date).toLocaleDateString()
}

// âœ… Better: Regular function
function formatDate(date: string) {
  return new Date(date).toLocaleDateString()
}
```

### Custom Hook Rules

1. **Must start with `use`**: `useMyHook()` âœ…, `myHook()` âŒ
2. **Can only be called from:**
   - React components
   - Other custom hooks
3. **Must follow Rules of Hooks:**
   - Call at top level
   - Don't call conditionally

**Example violations:**

```tsx
// âŒ WRONG: Doesn't start with "use"
function fetchData() {
  const [data, setData] = useState(null)  // ERROR!
  return data
}

// âŒ WRONG: Called conditionally
function Component() {
  if (condition) {
    const data = useMyHook()  // ERROR!
  }
}

// âŒ WRONG: Called in regular function
function helper() {
  const data = useMyHook()  // ERROR!
}

// âœ… CORRECT: Custom hook called at top level
function Component() {
  const data = useMyHook()  // âœ…
  
  if (condition) {
    return <div>{data}</div>
  }
}
```

### Real-World Custom Hooks for Our Forum

```tsx
// 1. useDebounce - Delay search queries
function useDebounce(value: string, delay: number) {
  const [debouncedValue, setDebouncedValue] = useState(value)
  
  useEffect(() => {
    const timer = setTimeout(() => setDebouncedValue(value), delay)
    return () => clearTimeout(timer)
  }, [value, delay])
  
  return debouncedValue
}

// 2. useLocalStorage - Persist draft posts
function useLocalStorage<T>(key: string, initialValue: T) {
  const [value, setValue] = useState<T>(() => {
    const stored = localStorage.getItem(key)
    return stored ? JSON.parse(stored) : initialValue
  })
  
  useEffect(() => {
    localStorage.setItem(key, JSON.stringify(value))
  }, [key, value])
  
  return [value, setValue] as const
}

// 3. useAuth - Check authentication
function useAuth() {
  const [user, setUser] = useState<User | null>(null)
  const [isLoading, setIsLoading] = useState(true)
  
  useEffect(() => {
    // Check if user is logged in
    const token = localStorage.getItem('auth_token')
    if (token) {
      fetchUser(token).then(setUser)
    }
    setIsLoading(false)
  }, [])
  
  return { user, isLoading, isAuthenticated: !!user }
}
```

**Benefits of custom hooks:**

- âœ… **DRY** (Don't Repeat Yourself)
- âœ… **Testable** (test hook independently)
- âœ… **Composable** (combine multiple hooks)
- âœ… **Readable** (clear intent from name)
- âœ… **Reusable** (use across components)

---

## Summary: What We Learned

### React Concepts
1. **useState**: React's memory system
   - Returns `[value, setter]`
   - Setter triggers re-render
   - State persists between renders

2. **Controlled Components**: React controls input value
   ```tsx
   <input value={state} onChange={(e) => setState(e.target.value)} />
   ```

3. **Form Handling**:
   - React Hook Form for state management
   - Zod for validation + types
   - zodResolver to connect them

### Best Practices
- âœ… Single state object for related fields
- âœ… Validate with Zod schemas
- âœ… Show loading states during submission
- âœ… Provide user feedback (toasts)
- âœ… Reset form after success
- âœ… Handle API errors gracefully

### TypeScript Wins
```tsx
type CreateCategoryInput = z.infer<typeof createCategorySchema>
```
Single source of truth for validation + types!

---

## Next: Edit Category

Now we know how to create categories. Next, we'll learn how to **edit** existing ones. This introduces:
- Populating forms with existing data
- PUT requests
- Optimistic UI updates

Continue to [Edit Category â†’](/en/react/3.categories-module/3.edit-category)
