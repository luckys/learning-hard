---
title: Display Posts & Nested Replies
description: Master recursive components, tree structures, and component composition by building a nested comment system.
---

# Disclaimer

:::u-alert
---
title: Comments in the code are for educational purposes only.
description: In real projects, avoid adding irrelevant or redundant comments.
color: warning
variant: subtle
icon: i-lucide-triangle-alert
---
:::

Posts (replies to threads) can have nested replies, creating tree structures. We'll use **recursion** - one of React's most powerful patterns.

---

## What We're Building

A comment/reply system like Reddit or Hacker News:

```
Thread: "How do I learn React?"
├─ Post #1 by @alice: "Start with the official docs!"
│  ├─ Reply by @bob: "I found videos more helpful"
│  │  └─ Reply by @alice: "Fair point! Any recommendations?"
│  └─ Reply by @charlie: "Docs + building projects is key"
├─ Post #2 by @david: "What's your background?"
└─ Post #3 by @eve: "Build a todo app first"
```

Each post can have replies, and those replies can have replies, and so on (infinite nesting).

---

## The Challenge: Nested Data

### Flat vs Nested Data Structures

**Option 1: Flat list with `parentId` (our choice)**
```typescript
[
  { id: '1', parentId: null, content: 'Start with docs!' },
  { id: '2', parentId: '1', content: 'I prefer videos' },
  { id: '3', parentId: '2', content: 'Any recommendations?' },
]
```

**Option 2: Nested structure**
```typescript
[
  {
    id: '1',
    content: 'Start with docs!',
    replies: [
      {
        id: '2',
        content: 'I prefer videos',
        replies: [
          { id: '3', content: 'Any recommendations?', replies: [] }
        ]
      }
    ]
  }
]
```

**Why flat is better:**
- ✅ Easier to update specific posts
- ✅ Easier to fetch from database
- ✅ Easier to implement optimistic updates
- ✅ No need to traverse tree to find post
- ❌ Need recursion to render (but that's okay!)

---

## Post Type Definition

```typescript
// src/types/index.ts

export interface Post {
  id: string
  threadId: string
  authorId: string
  author: {
    id: string
    username: string
    displayName: string
    avatarUrl: string | null
    role: 'user' | 'moderator' | 'admin'
  }
  content: string
  contentHtml: string  // Rendered markdown
  parentId: string | null  // null = root post, otherwise reply to parentId
  depth: number  // 0 = root, 1 = reply to root, 2 = reply to reply, etc.
  voteScore: number  // Net score (upvotes - downvotes)
  userVote: 'up' | 'down' | null  // Current user's vote
  replyCount: number  // Direct replies count
  createdAt: string
  updatedAt: string
  isEdited: boolean
  isDeleted: boolean
}
```

**Key fields:**
- `parentId`: Forms the tree structure
- `depth`: Helps with indentation and max-depth limits
- `voteScore`: For sorting by popularity
- `userVote`: For showing vote state to user
- `contentHtml`: Pre-rendered markdown (security!)

---

## Recursion: The Pattern for Trees

**Recursion** = A function that calls itself.

### Recursion 101

```typescript
// Example: Countdown
function countdown(n: number) {
  // BASE CASE: When to stop
  if (n === 0) {
    console.log('Blastoff!')
    return
  }
  
  // RECURSIVE CASE: Do work + call itself
  console.log(n)
  countdown(n - 1)  // Call itself with simpler input
}

countdown(3)
// Output: 3, 2, 1, Blastoff!
```

**Every recursive function needs:**
1. **Base case**: Condition to stop
2. **Recursive case**: Call itself with simpler input
3. **Progress**: Each call gets closer to base case

### Recursion for Trees

Trees are **naturally recursive**:
- A tree is a node with children
- Each child is a tree
- Base case: Node with no children

```
        Root
       /    \
     Child1  Child2
     /  \
  Grand1 Grand2
```

**Recursive definition:**
```
render(node):
  1. Render this node
  2. For each child:
     render(child)  // Recursive!
```

---

## PostCard: Recursive Component

```tsx
// src/components/posts/PostCard.tsx

import { useState } from 'react'
import { Link } from 'react-router-dom'
import { formatDistanceToNow } from 'date-fns'
import { VoteButtons } from './VoteButtons'
import { ReplyForm } from './ReplyForm'
import type { Post } from '@/types'

interface PostCardProps {
  post: Post
  allPosts: Post[]  // Needed to find children
  threadId: string
  depth?: number  // Current nesting level
  maxDepth?: number  // Maximum nesting before flattening
}

/**
 * Recursive Post Card Component
 * 
 * Renders a single post and recursively renders all its replies.
 * This creates the nested comment tree structure.
 * 
 * How recursion works here:
 * 1. Render this post
 * 2. Find all direct children (posts where parentId === this post's id)
 * 3. For each child, render PostCard (recursive call!)
 * 4. Each child repeats steps 1-3
 * 5. Base case: Post with no children (stops recursion)
 */
export function PostCard({
  post,
  allPosts,
  threadId,
  depth = 0,
  maxDepth = 10,
}: PostCardProps) {
  const [showReplyForm, setShowReplyForm] = useState(false)

  /**
   * Find direct children of this post
   * 
   * Filter all posts to find those whose parentId matches this post's id.
   * This is the key to building the tree structure from flat data!
   */
  const children = allPosts.filter((p) => p.parentId === post.id)

  /**
   * Check if we've hit max depth
   * 
   * After certain depth (e.g. 10), flatten remaining replies
   * to prevent excessive indentation and stack overflow
   */
  const isMaxDepth = depth >= maxDepth

  /**
   * Calculate indentation
   * 
   * Each level adds 20px of left padding
   * Level 0: 0px, Level 1: 20px, Level 2: 40px, etc.
   */
  const indentPx = depth * 20

  /**
   * Determine author badge
   */
  const authorBadge = {
    admin: { label: 'Admin', color: 'bg-red-600' },
    moderator: { label: 'Mod', color: 'bg-blue-600' },
    user: null,
  }[post.author.role]

  return (
    <div
      style={{ marginLeft: `${indentPx}px` }}
      className="border-l-2 border-slate-800 pl-4 py-3"
    >
      {/* Post header */}
      <div className="flex items-center gap-2 mb-2">
        {/* Avatar */}
        <img
          src={post.author.avatarUrl || '/avatars/default.png'}
          alt={post.author.displayName}
          className="w-8 h-8 rounded-full"
        />

        {/* Author info */}
        <div className="flex items-center gap-2 text-sm">
          <Link
            to={`/users/${post.author.username}`}
            className="font-medium text-slate-200 hover:text-blue-400"
          >
            {post.author.displayName}
          </Link>

          {/* Role badge */}
          {authorBadge && (
            <span className={`px-2 py-0.5 text-xs text-white rounded ${authorBadge.color}`}>
              {authorBadge.label}
            </span>
          )}

          {/* Timestamp */}
          <span className="text-slate-500">
            {formatDistanceToNow(new Date(post.createdAt), { addSuffix: true })}
          </span>

          {/* Edited indicator */}
          {post.isEdited && (
            <span className="text-slate-500 text-xs">(edited)</span>
          )}
        </div>
      </div>

      {/* Post content */}
      <div className="mb-3">
        {post.isDeleted ? (
          <p className="text-slate-500 italic">[deleted]</p>
        ) : (
          <div
            className="prose prose-sm prose-invert max-w-none"
            dangerouslySetInnerHTML={{ __html: post.contentHtml }}
          />
        )}
      </div>

      {/* Post actions */}
      <div className="flex items-center gap-4">
        {/* Vote buttons */}
        <VoteButtons
          postId={post.id}
          score={post.voteScore}
          userVote={post.userVote}
        />

        {/* Reply button */}
        <button
          onClick={() => setShowReplyForm(!showReplyForm)}
          className="text-sm text-slate-400 hover:text-slate-200"
        >
          {showReplyForm ? 'Cancel' : 'Reply'}
        </button>

        {/* Reply count */}
        {children.length > 0 && (
          <span className="text-sm text-slate-500">
            {children.length} {children.length === 1 ? 'reply' : 'replies'}
          </span>
        )}
      </div>

      {/* Reply form */}
      {showReplyForm && (
        <div className="mt-4">
          <ReplyForm
            threadId={threadId}
            parentId={post.id}
            onSuccess={() => setShowReplyForm(false)}
          />
        </div>
      )}

      {/* RECURSIVE PART: Render children */}
      {children.length > 0 && !isMaxDepth && (
        <div className="mt-4 space-y-4">
          {children.map((child) => (
            <PostCard
              key={child.id}
              post={child}
              allPosts={allPosts}
              threadId={threadId}
              depth={depth + 1}  // Increment depth
              maxDepth={maxDepth}
            />
          ))}
        </div>
      )}

      {/* Max depth warning */}
      {children.length > 0 && isMaxDepth && (
        <div className="mt-4 p-3 bg-slate-900 rounded-lg border border-slate-800">
          <p className="text-sm text-slate-400">
            {children.length} more {children.length === 1 ? 'reply' : 'replies'}...
          </p>
          <Link
            to={`/threads/${threadId}/post/${post.id}`}
            className="text-sm text-blue-400 hover:text-blue-300"
          >
            View thread →
          </Link>
        </div>
      )}
    </div>
  )
}
```

---

## How Recursion Works: Visual Trace

Let's trace how the recursion builds the tree:

**Data:**
```typescript
[
  { id: '1', parentId: null, content: 'Start with docs!' },
  { id: '2', parentId: '1', content: 'I prefer videos' },
  { id: '3', parentId: '2', content: 'Any recommendations?' },
]
```

**Execution:**
```
PostCard(post#1, depth=0)
  → Renders post#1
  → Finds children: [post#2]
  → Calls PostCard(post#2, depth=1)
      → Renders post#2
      → Finds children: [post#3]
      → Calls PostCard(post#3, depth=2)
          → Renders post#3
          → Finds children: []
          → Base case! No children, stop recursion
          → Returns
      → post#2 done rendering
      → Returns
  → post#1 done rendering
  → Returns
```

**Result:**
```
Post #1
  └─ Post #2
      └─ Post #3
```

---

## PostList: Entry Point

```tsx
// src/components/posts/PostList.tsx

import { PostCard } from './PostCard'
import type { Post } from '@/types'

interface PostListProps {
  posts: Post[]
  threadId: string
}

/**
 * PostList: Renders the root of the tree
 * 
 * Only renders TOP-LEVEL posts (parentId === null).
 * PostCard handles rendering children recursively.
 */
export function PostList({ posts, threadId }: PostListProps) {
  /**
   * Filter to root posts only
   * 
   * We don't want to render all posts flat here.
   * PostCard will recursively render the children.
   */
  const rootPosts = posts.filter((post) => post.parentId === null)

  /**
   * Sort by vote score (popular first) or by date (recent first)
   */
  const sortedPosts = [...rootPosts].sort((a, b) => {
    return b.voteScore - a.voteScore  // Highest score first
  })

  if (posts.length === 0) {
    return (
      <div className="text-center py-12 bg-slate-900 rounded-lg border border-slate-800">
        <p className="text-slate-400">No replies yet. Be the first!</p>
      </div>
    )
  }

  return (
    <div className="space-y-6">
      <h2 className="text-2xl font-bold text-slate-100">
        {posts.length} {posts.length === 1 ? 'Reply' : 'Replies'}
      </h2>

      <div className="space-y-4">
        {sortedPosts.map((post) => (
          <PostCard
            key={post.id}
            post={post}
            allPosts={posts}  // Pass ALL posts for children lookup
            threadId={threadId}
            depth={0}  // Start at depth 0
          />
        ))}
      </div>
    </div>
  )
}
```

---

## Performance: Avoiding Re-Renders

### Problem: Re-rendering the entire tree

Every time ANY post updates, the entire tree re-renders. For large threads (1000+ posts), this is slow.

### Solution: React.memo

```tsx
import { memo } from 'react'

/**
 * Memoized PostCard
 * 
 * Only re-renders if props change.
 * Prevents unnecessary re-renders of children when parent updates.
 */
export const PostCard = memo(function PostCard({
  post,
  allPosts,
  threadId,
  depth = 0,
  maxDepth = 10,
}: PostCardProps) {
  // ... component code
})
```

**How React.memo works:**
```
Parent updates
  → React checks if PostCard props changed
    → No change? Skip re-render!
    → Changed? Re-render this card and children
```

### Advanced: Custom comparison

```tsx
export const PostCard = memo(
  function PostCard(props) {
    // ... component code
  },
  (prevProps, nextProps) => {
    // Custom comparison
    // Return true if props are equal (skip re-render)
    return (
      prevProps.post.id === nextProps.post.id &&
      prevProps.post.voteScore === nextProps.post.voteScore &&
      prevProps.post.content === nextProps.post.content
    )
  }
)
```

---

## Advanced: useDeferredValue for Large Lists

**Problem:** With 1000+ posts, rendering takes time. Input becomes laggy while React renders the tree.

**Solution:** `useDeferredValue` defers rendering large lists, keeping input responsive.

### What is useDeferredValue?

`useDeferredValue` lets you defer updating a non-critical value. React will:
1. Keep urgent updates (input) responsive
2. Process deferred updates (large list) in background
3. Show stale data while processing

**Similar to useTransition, but for values instead of state updates.**

### How It Works

```tsx
import { useDeferredValue, useState } from 'react'

function ThreadPosts({ threadId }) {
  const [sortBy, setSortBy] = useState('newest')
  
  // Fetch all posts
  const [posts] = useState<Post[]>([...1000 posts...])
  
  /**
   * useDeferredValue: Defer sorting/filtering
   * 
   * When sortBy changes:
   * 1. Input updates immediately
   * 2. deferredSortBy updates in background
   * 3. Large list re-renders with new sort
   * 
   * Result: Input always responsive!
   */
  const deferredSortBy = useDeferredValue(sortBy)
  
  // Expensive operation: Sort 1000 posts
  const sortedPosts = useMemo(() => {
    console.log('Sorting posts...')
    return [...posts].sort((a, b) => {
      if (deferredSortBy === 'newest') {
        return new Date(b.createdAt).getTime() - new Date(a.createdAt).getTime()
      }
      if (deferredSortBy === 'oldest') {
        return new Date(a.createdAt).getTime() - new Date(b.createdAt).getTime()
      }
      if (deferredSortBy === 'popular') {
        return b.voteScore - a.voteScore
      }
      return 0
    })
  }, [posts, deferredSortBy])
  
  // Show loading indicator while deferring
  const isPending = sortBy !== deferredSortBy
  
  return (
    <div>
      {/* Sort dropdown - always responsive */}
      <select 
        value={sortBy}
        onChange={(e) => setSortBy(e.target.value)}
      >
        <option value="newest">Newest First</option>
        <option value="oldest">Oldest First</option>
        <option value="popular">Most Popular</option>
      </select>
      
      {/* Loading indicator */}
      {isPending && <p className="text-slate-400">Sorting...</p>}
      
      {/* Large list - renders in background */}
      <div className={isPending ? 'opacity-50' : 'opacity-100'}>
        {sortedPosts.map(post => (
          <PostCard key={post.id} post={post} allPosts={sortedPosts} />
        ))}
      </div>
    </div>
  )
}
```

### Visual Timeline

```
WITHOUT useDeferredValue:
User clicks "Popular"
  → Input updates
  → Sorting 1000 posts (slow!)
  → Input freezes ❌
  → Sorting finishes
  → Input responsive again

WITH useDeferredValue:
User clicks "Popular"
  → Input updates immediately ✅
  → Sorting starts in background
  → Input stays responsive ✅
  → Sorting finishes
  → List updates with new sort
```

### useDeferredValue vs useTransition

| Aspect | useTransition | useDeferredValue |
|--------|---------------|-----------------|
| **What it defers** | State updates | Values |
| **Syntax** | `startTransition(() => setState())` | `const deferred = useDeferredValue(value)` |
| **Use case** | Multiple state updates | Single expensive value |
| **Example** | Search results | Sorted list |
| **Pending state** | `isPending` | Check `value !== deferredValue` |

### Complete Example: Sortable Thread Posts

```tsx
function ThreadPosts({ threadId }: { threadId: string }) {
  const [posts, setPostsState] = useState<Post[]>([])
  const [sortBy, setSortBy] = useState<'newest' | 'oldest' | 'popular'>('newest')
  const [filterAuthor, setFilterAuthor] = useState<string | null>(null)
  
  // Defer expensive sorting/filtering
  const deferredSortBy = useDeferredValue(sortBy)
  const deferredFilterAuthor = useDeferredValue(filterAuthor)
  
  // Expensive: Filter + Sort 1000 posts
  const processedPosts = useMemo(() => {
    let result = [...posts]
    
    // Filter by author
    if (deferredFilterAuthor) {
      result = result.filter(p => p.author.id === deferredFilterAuthor)
    }
    
    // Sort
    result.sort((a, b) => {
      switch (deferredSortBy) {
        case 'newest':
          return new Date(b.createdAt).getTime() - new Date(a.createdAt).getTime()
        case 'oldest':
          return new Date(a.createdAt).getTime() - new Date(b.createdAt).getTime()
        case 'popular':
          return b.voteScore - a.voteScore
      }
    })
    
    return result
  }, [posts, deferredSortBy, deferredFilterAuthor])
  
  // Check if currently deferring
  const isProcessing = 
    sortBy !== deferredSortBy || 
    filterAuthor !== deferredFilterAuthor
  
  return (
    <div className="space-y-4">
      {/* Controls - always responsive */}
      <div className="flex gap-4">
        <select 
          value={sortBy}
          onChange={(e) => setSortBy(e.target.value as any)}
          className="px-3 py-2 bg-slate-900 border border-slate-700 rounded"
        >
          <option value="newest">Newest</option>
          <option value="oldest">Oldest</option>
          <option value="popular">Popular</option>
        </select>
        
        <select 
          value={filterAuthor || ''}
          onChange={(e) => setFilterAuthor(e.target.value || null)}
          className="px-3 py-2 bg-slate-900 border border-slate-700 rounded"
        >
          <option value="">All Authors</option>
          {/* Author options */}
        </select>
      </div>
      
      {/* Processing indicator */}
      {isProcessing && (
        <p className="text-slate-400 text-sm">Processing...</p>
      )}
      
      {/* Large list - renders with deferred values */}
      <div className={isProcessing ? 'opacity-60' : 'opacity-100'}>
        {processedPosts.map(post => (
          <PostCard 
            key={post.id} 
            post={post} 
            allPosts={processedPosts}
            threadId={threadId}
          />
        ))}
      </div>
    </div>
  )
}
```

### Key Benefits

✅ **Input always responsive** - No lag while processing
✅ **Smooth UX** - Shows stale data while updating
✅ **Automatic** - React handles the deferring
✅ **Simple** - Just wrap the value
✅ **Scalable** - Works with any list size

### When to Use

- ✅ Large lists (1000+ items)
- ✅ Expensive filtering/sorting
- ✅ Want responsive input
- ✅ Can show stale data temporarily

---

## Summary

### Key Concepts

1. **Recursion**: Function calls itself
   - Base case: When to stop
   - Recursive case: Call itself with simpler input

2. **Tree Structures**: Naturally recursive
   - Node with children
   - Each child is a tree

3. **Flat Data + Recursion**: Best of both worlds
   - Store data flat (easier updates)
   - Render recursively (tree structure)

4. **React.memo**: Prevent unnecessary re-renders
   - Memoize components
   - Custom comparison for optimization

### Best Practices

- ✅ Use flat data structure with `parentId`
- ✅ Implement recursion carefully (avoid infinite loops!)
- ✅ Set max depth to prevent excessive nesting
- ✅ Memoize recursive components for performance
- ✅ Sort at each level (not just root)
- ✅ Handle empty states gracefully

---

Next: [Create Reply →](/en/react/5.posts-module/2.create-reply)
