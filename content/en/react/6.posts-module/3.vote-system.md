---
title: Vote System - Optimistic UI & Complex State Management
description: Master optimistic updates, vote toggle logic, score calculations, conflict resolution, and instant feedback patterns. Build Reddit-style voting with perfect UX.
---

# Disclaimer

:::u-alert
---
title: Comments in the code are for educational purposes only.
description: In real projects, avoid adding irrelevant or redundant comments.
color: warning
variant: subtle
icon: i-lucide-triangle-alert
---
:::

Voting is deceptively complex. It looks simple (two arrows and a number), but requires careful state management: **optimistic updates** for instant feedback, **toggle logic** for changing votes, **score calculations** that consider previous state, and **conflict resolution** when things go wrong.

---

## What We're Building

A Reddit/Hacker News-style voting system:

**Visual:**
```
   ▲  Upvote (active: blue, inactive: gray)
  +5   Score (green if positive, red if negative, gray if zero)
   ▼  Downvote (active: red, inactive: gray)
```

**User interactions:**
1. **First upvote**: `score: 0 → 1`, `userVote: null → 'up'`
2. **Click upvote again**: `score: 1 → 0`, `userVote: 'up' → null` (toggle off)
3. **Switch to downvote**: `score: 1 → -1`, `userVote: 'up' → 'down'` (removes +1, adds -1 = net -2)

**Requirements:**
- **Instant feedback**: UI updates before API responds
- **Toggle behavior**: Click same button twice to remove vote
- **Switch votes**: Click opposite button to change vote
- **Correct math**: Score adjusts based on previous vote
- **Rollback on error**: Revert UI if API fails
- **Optimistic UI**: Show new state immediately
- **No double-voting**: Prevent spam clicks

---

## The Challenge: Vote State Mathematics

### Understanding the State Transitions

Voting isn't just "add 1" or "subtract 1". You must consider the **previous vote**:

**Scenario 1: First upvote**
```
Before: score = 0, userVote = null
Action: User clicks upvote
After:  score = 1, userVote = 'up'
Change: +1
```

**Scenario 2: Toggle off upvote**
```
Before: score = 1, userVote = 'up'
Action: User clicks upvote again
After:  score = 0, userVote = null
Change: -1
```

**Scenario 3: Switch from upvote to downvote**
```
Before: score = 1, userVote = 'up'
Action: User clicks downvote
After:  score = -1, userVote = 'down'
Change: -2 (remove +1, add -1)
```

**Scenario 4: Switch from downvote to upvote**
```
Before: score = -1, userVote = 'down'
Action: User clicks upvote
After:  score = 1, userVote = 'up'
Change: +2 (remove -1, add +1)
```

### The Algorithm

```typescript
function calculateNewScore(
  currentScore: number,
  oldVote: 'up' | 'down' | null,
  newVote: 'up' | 'down' | null
): number {
  let score = currentScore

  // Step 1: Remove old vote effect
  if (oldVote === 'up') score -= 1
  if (oldVote === 'down') score += 1

  // Step 2: Add new vote effect
  if (newVote === 'up') score += 1
  if (newVote === 'down') score -= 1

  return score
}
```

**Why two steps?**
- Always start from "neutral" state (remove old vote)
- Then apply new vote
- Handles all cases consistently

---

## Vote Buttons Component

```tsx
// src/components/posts/VoteButtons.tsx

import { useState } from 'react'
import { useMutation, useQueryClient } from '@tanstack/react-query'
import { apiClient } from '@/lib/api-client'
import { toast } from '@/lib/toast'

interface VoteButtonsProps {
  postId: string
  score: number
  userVote: 'up' | 'down' | null
}

/**
 * VoteButtons - Reddit-style upvote/downvote system
 * 
 * Features:
 * - Instant feedback (optimistic updates)
 * - Toggle behavior (click again to remove)
 * - Correct score math (considers previous vote)
 * - Error handling (rollback on failure)
 * - Spam prevention (disable during request)
 * - Visual feedback (colors, hover states)
 * 
 * State management:
 * - Server state: React Query (cache + mutations)
 * - Optimistic updates: Update cache before API responds
 * - Rollback: Restore previous state on error
 */
export function VoteButtons({ postId, score, userVote }: VoteButtonsProps) {
  const queryClient = useQueryClient()
  
  /**
   * Vote mutation
   * 
   * Handles three operations:
   * 1. Add upvote: POST /posts/:id/vote { type: 'up' }
   * 2. Add downvote: POST /posts/:id/vote { type: 'down' }
   * 3. Remove vote: DELETE /posts/:id/vote
   */
  const voteMutation = useMutation({
    /**
     * mutationFn: The API call
     * 
     * Takes new vote type (or null to remove)
     * Returns API response
     */
    mutationFn: async (voteType: 'up' | 'down' | null) => {
      if (voteType === null) {
        // Remove vote
        return apiClient.delete(`/posts/${postId}/vote`)
      } else {
        // Add/change vote
        return apiClient.post(`/posts/${postId}/vote`, { type: voteType })
      }
    },

    /**
     * onMutate: Runs BEFORE API call
     * 
     * This is where we do optimistic updates:
     * 1. Cancel outgoing queries (prevent race conditions)
     * 2. Save current state (for rollback)
     * 3. Update cache with new value
     * 
     * Returns context (previous state) for rollback
     */
    onMutate: async (newVote) => {
      /**
       * Cancel outgoing queries
       * 
       * If there's already a query fetching this post,
       * cancel it to prevent it from overwriting our
       * optimistic update with stale data
       */
      await queryClient.cancelQueries({ queryKey: ['post', postId] })

      /**
       * Snapshot current state
       * 
       * Save it so we can rollback if API call fails
       */
      const previousPost = queryClient.getQueryData(['post', postId])

      /**
       * Optimistically update cache
       * 
       * Update the UI immediately, before API responds
       */
      queryClient.setQueryData(['post', postId], (old: any) => {
        if (!old) return old

        /**
         * Calculate new score
         * 
         * Must consider previous vote:
         * - If switching from up to down, change is -2
         * - If toggling off, change is -1 or +1
         * - If first vote, change is +1 or -1
         */
        let newScore = old.score
        const oldVote = old.userVote

        // Remove old vote effect
        if (oldVote === 'up') newScore -= 1
        if (oldVote === 'down') newScore += 1

        // Add new vote effect
        if (newVote === 'up') newScore += 1
        if (newVote === 'down') newScore -= 1

        return {
          ...old,
          score: newScore,
          userVote: newVote,
        }
      })

      /**
       * Return context for rollback
       * 
       * If API fails, we'll use this to restore state
       */
      return { previousPost }
    },

    /**
     * onError: Runs if API call fails
     * 
     * Rollback optimistic update
     */
    onError: (err, newVote, context) => {
      /**
       * Restore previous state
       * 
       * The optimistic update failed, so revert UI
       */
      if (context?.previousPost) {
        queryClient.setQueryData(['post', postId], context.previousPost)
      }

      /**
       * Show error message
       */
      toast.error('Failed to vote. Please try again.')
    },

    /**
     * onSuccess: Runs if API call succeeds
     * 
     * Update cache with real data from server
     * (In case server calculated score differently)
     */
    onSuccess: (response) => {
      /**
       * Replace optimistic data with real data
       */
      queryClient.setQueryData(['post', postId], response.data)
    },
  })

  /**
   * Handle vote click
   * 
   * Implements toggle logic:
   * - Click same button twice: remove vote
   * - Click opposite button: switch vote
   */
  const handleVote = (type: 'up' | 'down') => {
    /**
     * Toggle logic
     * 
     * If user clicks same button they already voted:
     *   newVote = null (remove vote)
     * Else:
     *   newVote = type (add or switch vote)
     */
    const newVote = userVote === type ? null : type

    /**
     * Trigger mutation
     * 
     * This will:
     * 1. Run onMutate (optimistic update)
     * 2. Call API
     * 3. Run onSuccess or onError
     */
    voteMutation.mutate(newVote)
  }

  /**
   * Disable buttons during mutation
   * 
   * Prevents spam clicks and race conditions
   */
  const isDisabled = voteMutation.isPending

  return (
    <div className="flex items-center gap-2">
      {/* Upvote Button */}
      <button
        onClick={() => handleVote('up')}
        disabled={isDisabled}
        className={`
          p-1.5 rounded transition-colors
          ${isDisabled ? 'cursor-not-allowed opacity-50' : ''}
          ${
            userVote === 'up'
              ? 'text-blue-500'  // Active: blue
              : 'text-slate-500 hover:text-blue-400'  // Inactive: gray, hover blue
          }
        `}
        aria-label="Upvote"
        aria-pressed={userVote === 'up'}
      >
        ▲
      </button>

      {/* Score Display */}
      <span
        className={`
          text-sm font-medium min-w-[2ch] text-center
          ${
            score > 0
              ? 'text-green-400'  // Positive: green
              : score < 0
              ? 'text-red-400'  // Negative: red
              : 'text-slate-400'  // Zero: gray
          }
        `}
      >
        {score > 0 ? `+${score}` : score}
      </span>

      {/* Downvote Button */}
      <button
        onClick={() => handleVote('down')}
        disabled={isDisabled}
        className={`
          p-1.5 rounded transition-colors
          ${isDisabled ? 'cursor-not-allowed opacity-50' : ''}
          ${
            userVote === 'down'
              ? 'text-red-500'  // Active: red
              : 'text-slate-500 hover:text-red-400'  // Inactive: gray, hover red
          }
        `}
        aria-label="Downvote"
        aria-pressed={userVote === 'down'}
      >
        ▼
      </button>
    </div>
  )
}
```

---

## Testing Vote Logic

```tsx
// src/components/posts/__tests__/VoteButtons.test.tsx

import { render, screen, waitFor } from '@testing-library/react'
import userEvent from '@testing-library/user-event'
import { VoteButtons } from '../VoteButtons'
import { apiClient } from '@/lib/api-client'
import { QueryClient, QueryClientProvider } from '@tanstack/react-query'

vi.mock('@/lib/api-client')

describe('VoteButtons', () => {
  const queryClient = new QueryClient()

  function renderVoteButtons(props: Partial<VoteButtonsProps> = {}) {
    return render(
      <QueryClientProvider client={queryClient}>
        <VoteButtons
          postId="post123"
          score={0}
          userVote={null}
          {...props}
        />
      </QueryClientProvider>
    )
  }

  it('upvotes from neutral', async () => {
    const user = userEvent.setup()
    vi.mocked(apiClient.post).mockResolvedValueOnce({
      data: { score: 1, userVote: 'up' },
    })

    renderVoteButtons()

    await user.click(screen.getByLabelText('Upvote'))

    // Should show +1 optimistically
    expect(screen.getByText('+1')).toBeInTheDocument()

    // Should call API
    await waitFor(() => {
      expect(apiClient.post).toHaveBeenCalledWith(
        '/posts/post123/vote',
        { type: 'up' }
      )
    })
  })

  it('toggles off upvote', async () => {
    const user = userEvent.setup()
    vi.mocked(apiClient.delete).mockResolvedValueOnce({
      data: { score: 0, userVote: null },
    })

    renderVoteButtons({ score: 1, userVote: 'up' })

    await user.click(screen.getByLabelText('Upvote'))

    // Should show 0 optimistically
    expect(screen.getByText('0')).toBeInTheDocument()

    // Should call DELETE
    await waitFor(() => {
      expect(apiClient.delete).toHaveBeenCalledWith('/posts/post123/vote')
    })
  })

  it('switches from upvote to downvote', async () => {
    const user = userEvent.setup()
    vi.mocked(apiClient.post).mockResolvedValueOnce({
      data: { score: -1, userVote: 'down' },
    })

    renderVoteButtons({ score: 1, userVote: 'up' })

    await user.click(screen.getByLabelText('Downvote'))

    // Should show -1 (removed +1, added -1)
    expect(screen.getByText('-1')).toBeInTheDocument()
  })

  it('rolls back on error', async () => {
    const user = userEvent.setup()
    vi.mocked(apiClient.post).mockRejectedValueOnce(new Error('Network error'))

    renderVoteButtons({ score: 0, userVote: null })

    await user.click(screen.getByLabelText('Upvote'))

    // Should revert to 0 after error
    await waitFor(() => {
      expect(screen.getByText('0')).toBeInTheDocument()
    })
  })
})
```

---

## Summary

### Key Concepts Mastered

1. **Optimistic Updates**: Update UI before API responds
   - Instant feedback (better UX)
   - Rollback on error (reliability)

2. **Toggle Logic**: Click same button twice to remove
   ```tsx
   const newVote = userVote === type ? null : type
   ```

3. **Score Mathematics**: Consider previous vote
   ```tsx
   // Remove old vote effect
   if (oldVote === 'up') score -= 1
   if (oldVote === 'down') score += 1
   
   // Add new vote effect
   if (newVote === 'up') score += 1
   if (newVote === 'down') score -= 1
   ```

4. **React Query Mutations**: Handle async state
   - `onMutate`: Optimistic update
   - `onError`: Rollback
   - `onSuccess`: Update with real data

5. **Race Condition Prevention**: Cancel outgoing queries
   ```tsx
   await queryClient.cancelQueries({ queryKey: ['post', postId] })
   ```

### Best Practices

- ✅ Optimistic updates for instant feedback
- ✅ Rollback on error (don't leave UI in bad state)
- ✅ Disable buttons during mutation (prevent spam)
- ✅ Visual feedback (colors for vote state)
- ✅ Accessibility (aria-label, aria-pressed)
- ✅ Test all scenarios (neutral, toggle, switch)
- ✅ Handle network errors gracefully

### Common Pitfalls

- ❌ Forgetting to consider previous vote in calculations
- ❌ Not canceling outgoing queries (race conditions)
- ❌ Not disabling buttons (double-click bugs)
- ❌ Not rolling back on error (corrupted UI)
- ❌ Hardcoding score changes (+1/-1) instead of calculating

---

Next: [Edit & Delete Posts →](/en/react/6.posts-module/4.edit-delete)
